<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solver · Thunderbolt.jl</title><meta name="title" content="Solver · Thunderbolt.jl"/><meta property="og:title" content="Solver · Thunderbolt.jl"/><meta property="twitter:title" content="Solver · Thunderbolt.jl"/><meta name="description" content="Documentation for Thunderbolt.jl."/><meta property="og:description" content="Documentation for Thunderbolt.jl."/><meta property="twitter:description" content="Documentation for Thunderbolt.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Thunderbolt.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Thunderbolt.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/">Overview</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Topic Guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../topics/">Overview</a></li><li><a class="tocitem" href="../../topics/operators/">Operators</a></li><li><a class="tocitem" href="../../topics/couplers/">Couplers</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../mesh/">Mesh</a></li><li><a class="tocitem" href="../discretization/">Discretization</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li class="is-active"><a class="tocitem" href>Solver</a></li><li><a class="tocitem" href="../utility/">Utility</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/">Overview</a></li><li><a class="tocitem" href="../../howto/benchmarking/">Benchmarking</a></li></ul></li><li><a class="tocitem" href="../../devdocs/">Developer documentation</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solver</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/termi-official/Thunderbolt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/termi-official/Thunderbolt.jl/blob/main/docs/src/api-reference/solver.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solver"><a class="docs-heading-anchor" href="#Solver">Solver</a><a id="Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Solver" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>BackwardEulerSolver</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ForwardEulerSolver</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ForwardEulerCellSolver</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Thunderbolt.AdaptiveForwardEulerReactionSubCellSolver</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Thunderbolt.ThreadedForwardEulerCellSolver</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Thunderbolt.LTGOSSolver" href="#Thunderbolt.LTGOSSolver"><code>Thunderbolt.LTGOSSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Classical Lie-Trotter-Godunov operator splitting in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/termi-official/Thunderbolt.jl/blob/19475ded4ab6ed3945e98142cfbc8f5a2ee07dd6/src/solver/operator_splitting.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Thunderbolt.LoadDrivenSolver" href="#Thunderbolt.LoadDrivenSolver"><code>Thunderbolt.LoadDrivenSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LoadDrivenSolver{IS, T, PFUN}</code></pre><p>Solve the nonlinear problem <code>F(u,t)=0</code> with given time increments <code>Δt</code>on some interval <code>[t_begin, t_end]</code> where <code>t</code> is some pseudo-time parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/termi-official/Thunderbolt.jl/blob/19475ded4ab6ed3945e98142cfbc8f5a2ee07dd6/src/solver/load_stepping.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Thunderbolt.NewtonRaphsonSolver" href="#Thunderbolt.NewtonRaphsonSolver"><code>Thunderbolt.NewtonRaphsonSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NewtonRaphsonSolver{T}</code></pre><p>Classical Newton-Raphson solver to solve nonlinear problems of the form <code>F(u) = 0</code>. To use the Newton-Raphson solver you have to dispatch on</p><ul><li><a href="@ref">update_linearization!</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/termi-official/Thunderbolt.jl/blob/19475ded4ab6ed3945e98142cfbc8f5a2ee07dd6/src/solver/newton_raphson.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.solve" href="#CommonSolve.solve"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CommonSolve.solve(args...; kwargs...)</code></pre><p>Solves an equation or other mathematical problem using the algorithm specified in the arguments. Generally, the interface is:</p><pre><code class="language-julia hljs">CommonSolve.solve(prob::ProblemType,alg::SolverType; kwargs...)::SolutionType</code></pre><p>where the keyword arguments are uniform across all choices of algorithms.</p><p>By default, <code>solve</code> defaults to using <code>solve!</code> on the iterator form, i.e.:</p><pre><code class="language-julia hljs">solve(args...; kwargs...) = solve!(init(args...; kwargs...))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/CommonSolve.jl/blob/v0.2.4/src/CommonSolve.jl#L3-L22">source</a></section><section><div><pre><code class="language-julia hljs">solve(prob::OptimizationProblem, alg::AbstractOptimizationAlgorithm, args...; kwargs...)</code></pre><p><strong>Keyword Arguments</strong></p><p>The arguments to <code>solve</code> are common across all of the optimizers. These common arguments are:</p><ul><li><code>maxiters</code> (the maximum number of iterations)</li><li><code>maxtime</code> (the maximum of time the optimization runs for)</li><li><code>abstol</code> (absolute tolerance in changes of the objective value)</li><li><code>reltol</code> (relative tolerance  in changes of the objective value)</li><li><code>callback</code> (a callback function)</li></ul><p>If the chosen global optimizer employs a local optimization method, a similar set of common local optimizer arguments exists. The common local optimizer arguments are:</p><ul><li><code>local_method</code> (optimizer used for local optimization in global method)</li><li><code>local_maxiters</code> (the maximum number of iterations)</li><li><code>local_maxtime</code> (the maximum of time the optimization runs for)</li><li><code>local_abstol</code> (absolute tolerance in changes of the objective value)</li><li><code>local_reltol</code> (relative tolerance  in changes of the objective value)</li><li><code>local_options</code> (NamedTuple of keyword arguments for local optimizer)</li></ul><p>Some optimizer algorithms have special keyword arguments documented in the solver portion of the documentation and their respective documentation. These arguments can be passed as <code>kwargs...</code> to <code>solve</code>. Similarly, the special keyword arguments for the <code>local_method</code> of a global optimizer are passed as a <code>NamedTuple</code> to <code>local_options</code>.</p><p>Over time, we hope to cover more of these keyword arguments under the common interface.</p><p>If a common argument is not implemented for a optimizer, a warning will be shown.</p><p><strong>Callback Functions</strong></p><p>The callback function <code>callback</code> is a function which is called after every optimizer step. Its signature is:</p><pre><code class="language-julia hljs">callback = (u, loss_val, other_args) -&gt; false</code></pre><p>where <code>u</code> and <code>loss_val</code> are the current optimization variables and loss/objective value in the optimization loop and <code>other_args</code> can be the extra things returned from the optimization <code>f</code>. This allows for saving values from the optimization and using them for plotting and display without recalculating. The callback should return a Boolean value, and the default should be <code>false</code>, such that the optimization gets stopped if it returns <code>true</code>.</p><p><strong>Callback Example</strong></p><p>Here we show an example a callback function that plots the prediction at the current value of the optimization variables. The loss function here returns the loss and the prediction i.e. the solution of the <code>ODEProblem</code> <code>prob</code>, so we can use the prediction in the callback.</p><pre><code class="language-julia hljs">function predict(u)
    Array(solve(prob, Tsit5(), p = u))
end

function loss(u, p)
    pred = predict(u)
    sum(abs2, batch .- pred), pred
end

callback = function (p, l, pred; doplot = false) #callback function to observe training
    display(l)
    # plot current prediction against data
    if doplot
        pl = scatter(t, ode_data[1, :], label = &quot;data&quot;)
        scatter!(pl, t, pred[1, :], label = &quot;prediction&quot;)
        display(plot(pl))
    end
    return false
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLBase.jl/blob/v2.15.2/src/solve.jl#L11-L90">source</a></section><section><div><pre><code class="language-julia hljs">solve(prob::AbstractDEProblem, alg::Union{AbstractDEAlgorithm,Nothing}; kwargs...)</code></pre><p><strong>Arguments</strong></p><p>The only positional argument is <code>alg</code> which is optional. By default, <code>alg = nothing</code>. If <code>alg = nothing</code>, then <code>solve</code> dispatches to the DifferentialEquations.jl automated algorithm selection (if <code>using DifferentialEquations</code> was done, otherwise it will error with a <code>MethodError</code>).</p><p><strong>Keyword Arguments</strong></p><p>The DifferentialEquations.jl universe has a large set of common arguments available for the <code>solve</code> function. These arguments apply to <code>solve</code> on any problem type and are only limited by limitations of the specific implementations.</p><p>Many of the defaults depend on the algorithm or the package the algorithm derives from. Not all of the interface is provided by every algorithm. For more detailed information on the defaults and the available options for specific algorithms / packages, see the manual pages for the solvers of specific problems. To see whether a specific package is compatible with the use of a given option, see the <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/compatibility_chart/#Solver-Compatibility-Chart">Solver Compatibility Chart</a></p><p><strong>Default Algorithm Hinting</strong></p><p>To help choose the default algorithm, the keyword argument <code>alg_hints</code> is provided to <code>solve</code>. <code>alg_hints</code> is a <code>Vector{Symbol}</code> which describe the problem at a high level to the solver. The options are:</p><ul><li><code>:auto</code> vs <code>:nonstiff</code> vs <code>:stiff</code> - Denotes the equation as nonstiff/stiff. <code>:auto</code> allow the default handling algorithm to choose stiffness detection algorithms. The default handling defaults to using <code>:auto</code>.</li></ul><p>Currently unused options include:</p><ul><li><code>:interpolant</code> - Denotes that a high-precision interpolation is important.</li><li><code>:memorybound</code> - Denotes that the solver will be memory bound.</li></ul><p>This functionality is derived via the benchmarks in <a href="https://github.com/SciML/SciMLBenchmarks.jl">SciMLBenchmarks.jl</a></p><p><strong>SDE Specific Alghints</strong></p><ul><li><code>:additive</code> - Denotes that the underlying SDE has additive noise.</li><li><code>:stratonovich</code> - Denotes that the solution should adhere to the Stratonovich interpretation.</li></ul><p><strong>Output Control</strong></p><p>These arguments control the output behavior of the solvers. It defaults to maximum output to give the best interactive user experience, but can be reduced all the way to only saving the solution at the final timepoint.</p><p>The following options are all related to output control. See the &quot;Examples&quot; section at the end of this page for some example usage.</p><ul><li><code>dense</code>: Denotes whether to save the extra pieces required for dense (continuous) output. Default is <code>save_everystep &amp;&amp; isempty(saveat)</code> for algorithms which have the ability to produce dense output, i.e. by default it&#39;s <code>true</code> unless the user has turned off saving on steps or has chosen a <code>saveat</code> value. If <code>dense=false</code>, the solution still acts like a function, and <code>sol(t)</code> is a linear interpolation between the saved time points.</li><li><code>saveat</code>: Denotes specific times to save the solution at, during the solving phase. The solver will save at each of the timepoints in this array in the most efficient manner available to the solver. If only <code>saveat</code> is given, then the arguments <code>save_everystep</code> and <code>dense</code> are <code>false</code> by default. If <code>saveat</code> is given a number, then it will automatically expand to <code>tspan[1]:saveat:tspan[2]</code>. For methods where interpolation is not possible, <code>saveat</code> may be equivalent to <code>tstops</code>. The default value is <code>[]</code>.</li><li><code>save_idxs</code>: Denotes the indices for the components of the equation to save. Defaults to saving all indices. For example, if you are solving a 3-dimensional ODE, and given <code>save_idxs = [1, 3]</code>, only the first and third components of the solution will be outputted. Notice that of course in this case the outputted solution will be two-dimensional.</li><li><code>tstops</code>: Denotes <em>extra</em> times that the timestepping algorithm must step to. This should be used to help the solver deal with discontinuities and singularities, since stepping exactly at the time of the discontinuity will improve accuracy. If a method cannot change timesteps (fixed timestep multistep methods), then <code>tstops</code> will use an interpolation, matching the behavior of <code>saveat</code>. If a method cannot change timesteps and also cannot interpolate, then <code>tstops</code> must be a multiple of <code>dt</code> or else an error will be thrown. Default is <code>[]</code>.</li><li><code>d_discontinuities:</code> Denotes locations of discontinuities in low order derivatives. This will force FSAL algorithms which assume derivative continuity to re-evaluate the derivatives at the point of discontinuity. The default is <code>[]</code>.</li><li><code>save_everystep</code>: Saves the result at every step. Default is true if <code>isempty(saveat)</code>.</li><li><code>save_on</code>: Denotes whether intermediate solutions are saved. This overrides the settings of <code>dense</code>, <code>saveat</code> and <code>save_everystep</code> and is used by some applications to manually turn off saving temporarily. Everyday use of the solvers should leave this unchanged. Defaults to <code>true</code>.</li><li><code>save_start</code>: Denotes whether the initial condition should be included in the solution type as the first timepoint. Defaults to <code>true</code>.</li><li><code>save_end</code>: Denotes whether the final timepoint is forced to be saved, regardless of the other saving settings. Defaults to <code>true</code>.</li><li><code>initialize_save</code>: Denotes whether to save after the callback initialization phase (when <code>u_modified=true</code>). Defaults to <code>true</code>.</li></ul><p>Note that <code>dense</code> requires <code>save_everystep=true</code> and <code>saveat=false</code>. If you need additional saving while keeping dense output, see <a href="https://docs.sciml.ai/DiffEqCallbacks/stable/output_saving/#DiffEqCallbacks.SavingCallback">the SavingCallback in the Callback Library</a>.</p><p><strong>Stepsize Control</strong></p><p>These arguments control the timestepping routines.</p><p><strong>Basic Stepsize Control</strong></p><p>These are the standard options for controlling stepping behavior. Error estimates do the comparison</p><p class="math-container">\[err_{scaled} = err/(abstol + max(uprev,u)*reltol)\]</p><p>The scaled error is guaranteed to be <code>&lt;1</code> for a given local error estimate (note: error estimates are local unless the method specifies otherwise). <code>abstol</code> controls the non-scaling error and thus can be thought of as the error around zero. <code>reltol</code> scales with the size of the dependent variables and so one can interpret <code>reltol=1e-3</code> as roughly being (locally) correct to 3 digits. Note tolerances can be specified element-wise by passing a vector whose size matches <code>u0</code>.</p><ul><li><code>adaptive</code>: Turns on adaptive timestepping for appropriate methods. Default is true.</li><li><code>abstol</code>: Absolute tolerance in adaptive timestepping. This is the tolerance on local error estimates, not necessarily the global error (though these quantities are related). Defaults to <code>1e-6</code> on deterministic equations (ODEs/DDEs/DAEs) and <code>1e-2</code> on stochastic equations (SDEs/RODEs).</li><li><code>reltol</code>: Relative tolerance in adaptive timestepping.  This is the tolerance on local error estimates, not necessarily the global error (though these quantities are related). Defaults to <code>1e-3</code> on deterministic equations (ODEs/DDEs/DAEs) and <code>1e-2</code> on stochastic equations (SDEs/RODEs).</li><li><code>dt</code>: Sets the initial stepsize. This is also the stepsize for fixed timestep methods. Defaults to an automatic choice if the method is adaptive.</li><li><code>dtmax</code>: Maximum dt for adaptive timestepping. Defaults are package-dependent.</li><li><code>dtmin</code>: Minimum dt for adaptive timestepping. Defaults are package-dependent.</li><li><code>force_dtmin</code>: Declares whether to continue, forcing the minimum <code>dt</code> usage. Default is <code>false</code>, which has the solver throw a warning and exit early when encountering the minimum <code>dt</code>. Setting this true allows the solver to continue, never letting <code>dt</code> go below <code>dtmin</code> (and ignoring error tolerances in those cases). Note that <code>true</code> is not compatible with most interop packages.</li></ul><p><strong>Fixed Stepsize Usage</strong></p><p>Note that if a method does not have adaptivity, the following rules apply:</p><ul><li>If <code>dt</code> is set, then the algorithm will step with size <code>dt</code> each iteration.</li><li>If <code>tstops</code> and <code>dt</code> are both set, then the algorithm will step with either a size <code>dt</code>, or use a smaller step to hit the <code>tstops</code> point.</li><li>If <code>tstops</code> is set without <code>dt</code>, then the algorithm will step directly to each value in <code>tstops</code></li><li>If neither <code>dt</code> nor <code>tstops</code> are set, the solver will throw an error.</li></ul><p><strong><a href="https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/">Advanced Adaptive Stepsize Control</a></strong></p><p>These arguments control more advanced parts of the internals of adaptive timestepping and are mostly used to make it more efficient on specific problems. For detained explanations of the timestepping algorithms, see the <a href="https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/#timestepping">timestepping descriptions</a></p><ul><li><code>internalnorm</code>: The norm function <code>internalnorm(u,t)</code> which error estimates are calculated. Required are two dispatches: one dispatch for the state variable and the other on the elements of the state variable (scalar norm). Defaults are package-dependent.</li><li><code>controller</code>: Possible examples are <a href="https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/#OrdinaryDiffEq.IController"><code>IController</code></a>, <a href="https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/#OrdinaryDiffEq.PIController"><code>PIController</code></a>, <a href="https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/#OrdinaryDiffEq.PIDController"><code>PIDController</code></a>, <a href="https://docs.sciml.ai/DiffEqDocs/stable/extras/timestepping/#OrdinaryDiffEq.PredictiveController"><code>PredictiveController</code></a>. Default is algorithm-dependent.</li><li><code>gamma</code>: The risk-factor γ in the q equation for adaptive timestepping of the controllers using it. Default is algorithm-dependent.</li><li><code>beta1</code>: The Lund stabilization α parameter. Default is algorithm-dependent.</li><li><code>beta2</code>: The Lund stabilization β parameter. Default is algorithm-dependent.</li><li><code>qmax</code>: Defines the maximum value possible for the adaptive q. Default is algorithm-dependent.</li><li><code>qmin</code>: Defines the minimum value possible for the adaptive q. Default is algorithm-dependent.</li><li><code>qsteady_min</code>: Defines the minimum for the range around 1 where the timestep is held constant. Default is algorithm-dependent.</li><li><code>qsteady_max</code>: Defines the maximum for the range around 1 where the timestep is held constant. Default is algorithm-dependent.</li><li><code>qoldinit</code>: The initial <code>qold</code> in stabilization stepping. Default is algorithm-dependent.</li><li><code>failfactor</code>: The amount to decrease the timestep by if the Newton iterations of an implicit method fail. Default is 2.</li></ul><p><strong>Memory Optimizations</strong></p><ul><li><code>calck</code>: Turns on and off the internal ability for intermediate interpolations (also known as intermediate density). Not the same as <code>dense</code>, which is post-solution interpolation. This defaults to <code>dense || !isempty(saveat) ||  &quot;no custom callback is given&quot;</code>. This can be used to turn off interpolations (to save memory) if one isn&#39;t using interpolations when a custom callback is used. Another case where this may be used is to turn on interpolations for usage in the integrator interface even when interpolations are used nowhere else. Note that this is only required if the algorithm doesn&#39;t have a free or lazy interpolation (<code>DP8()</code>). If <code>calck = false</code>, <code>saveat</code> cannot be used. The rare keyword <code>calck</code> can be useful in event handling.</li><li><code>alias_u0</code>: allows the solver to alias the initial condition array that is contained in the problem struct. Defaults to false.</li></ul><p><strong>Miscellaneous</strong></p><ul><li><code>maxiters</code>: Maximum number of iterations before stopping. Defaults to 1e5.</li><li><code>callback</code>: Specifies a callback. Defaults to a callback function which performs the saving routine. For more information, see the <a href="https://docs.sciml.ai/DiffEqCallbacks/stable/">Event Handling and Callback Functions manual page</a>.</li><li><code>isoutofdomain</code>: Specifies a function <code>isoutofdomain(u,p,t)</code> where, when it returns true, it will reject the timestep. Disabled by default.</li><li><code>unstable_check</code>: Specifies a function <code>unstable_check(dt,u,p,t)</code> where, when it returns true, it will cause the solver to exit and throw a warning. Defaults to <code>any(isnan,u)</code>, i.e. checking if any value is a NaN.</li><li><code>verbose</code>: Toggles whether warnings are thrown when the solver exits early. Defaults to true.</li><li><code>merge_callbacks</code>: Toggles whether to merge <code>prob.callback</code> with the <code>solve</code> keyword argument <code>callback</code>. Defaults to <code>true</code>.</li><li><code>wrap</code>: Toggles whether to wrap the solution if <code>prob.problem_type</code> has a preferred alternate wrapper type for the solution. Useful when speed, but not shape of solution is important. Defaults to <code>Val(true)</code>. <code>Val(false)</code> will cancel wrapping the solution.</li></ul><p><strong>Progress Monitoring</strong></p><p>These arguments control the usage of the progressbar in ProgressLogging.jl compatible environments.</p><ul><li><code>progress</code>: Turns on/off the Juno progressbar. Default is false.</li><li><code>progress_steps</code>: Numbers of steps between updates of the progress bar. Default is 1000.</li><li><code>progress_name</code>: Controls the name of the progressbar. Default is the name of the problem type.</li><li><code>progress_message</code>: Controls the message with the progressbar. Defaults to showing <code>dt</code>, <code>t</code>, the maximum of <code>u</code>.</li><li><code>progress_id</code>: Controls the ID of the progress log message to distinguish simultaneous simulations.</li></ul><p><strong>Error Calculations</strong></p><p>If you are using the test problems (ex: <code>ODETestProblem</code>), then the following options control the errors which are calculated:</p><ul><li><code>timeseries_errors</code>: Turns on and off the calculation of errors at the steps which were taken, such as the <code>l2</code> error. Default is true.</li><li><code>dense_errors</code>: Turns on and off the calculation of errors at the steps which require dense output and calculate the error at 100 evenly-spaced points throughout <code>tspan</code>. An example is the <code>L2</code> error. Default is false.</li></ul><p><strong>Sensitivity Algorithms (<code>sensealg</code>)</strong></p><p><code>sensealg</code> is used for choosing the way the automatic differentiation is performed. For more information, see the documentation for SciMLSensitivity: https://docs.sciml.ai/SciMLSensitivity/stable/</p><p><strong>Examples</strong></p><p>The following lines are examples of how one could use the configuration of <code>solve()</code>. For these examples a 3-dimensional ODE problem is assumed, however the extension to other types is straightforward.</p><ol><li><code>solve(prob, AlgorithmName())</code> : The &quot;default&quot; setting, with a user-specified</li></ol><p>algorithm (given by <code>AlgorithmName()</code>). All parameters get their default values.   This means that the solution is saved at the steps the Algorithm stops internally   and dense output is enabled if the chosen algorithm allows for it.</p><p>All other integration parameters (e.g. stepsize) are chosen automatically.</p><ol><li><code>solve(prob, saveat = 0.01, abstol = 1e-9, reltol = 1e-9)</code> : Standard setting</li></ol><p>for accurate output at specified (and equidistant) time intervals, used for   e.g. Fourier Transform. The solution is given every 0.01 time units,   starting from <code>tspan[1]</code>. The solver used is <code>Tsit5()</code> since no keyword   <code>alg_hits</code> is given.</p><ol><li><code>solve(prob, maxiters = 1e7, progress = true, save_idxs = [1])</code> : Using longer</li></ol><p>maximum number of solver iterations can be useful when a given <code>tspan</code> is very   long. This example only saves the first of the variables of the system, either   to save size or because the user does not care about the others. Finally, with   <code>progress = true</code> you are enabling the progress bar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqBase.jl/blob/v6.145.6/src/solve.jl#L689-L969">source</a></section><section><div><pre><code class="language-julia hljs">solve(prob::NonlinearProblem, alg::Union{AbstractNonlinearAlgorithm,Nothing}; kwargs...)</code></pre><p><strong>Arguments</strong></p><p>The only positional argument is <code>alg</code> which is optional. By default, <code>alg = nothing</code>. If <code>alg = nothing</code>, then <code>solve</code> dispatches to the NonlinearSolve.jl automated algorithm selection (if <code>using NonlinearSolve</code> was done, otherwise it will error with a <code>MethodError</code>).</p><p><strong>Keyword Arguments</strong></p><p>The NonlinearSolve.jl universe has a large set of common arguments available for the <code>solve</code> function. These arguments apply to <code>solve</code> on any problem type and are only limited by limitations of the specific implementations.</p><p>Many of the defaults depend on the algorithm or the package the algorithm derives from. Not all of the interface is provided by every algorithm. For more detailed information on the defaults and the available options for specific algorithms / packages, see the manual pages for the solvers of specific problems.</p><p><strong>Error Control</strong></p><ul><li><code>abstol</code>: Absolute tolerance.</li><li><code>reltol</code>: Relative tolerance.</li></ul><p><strong>Miscellaneous</strong></p><ul><li><code>maxiters</code>: Maximum number of iterations before stopping. Defaults to 1e5.</li><li><code>verbose</code>: Toggles whether warnings are thrown when the solver exits early. Defaults to true.</li></ul><p><strong>Sensitivity Algorithms (<code>sensealg</code>)</strong></p><p><code>sensealg</code> is used for choosing the way the automatic differentiation is performed.     For more information, see the documentation for SciMLSensitivity:     https://docs.sciml.ai/SciMLSensitivity/stable/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqBase.jl/blob/v6.145.6/src/solve.jl#L986-L1026">source</a></section><section><div><pre><code class="language-julia hljs">solve(problem, solver, Δt, time_span, initial_condition[, callback])</code></pre><p>Main entry point for solvers in Thunderbolt.jl. The design is inspired by DifferentialEquations.jl. We try to upstream as much content as possible to make it available for packages.</p><p>TODO iterator syntax instead of callback</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/termi-official/Thunderbolt.jl/blob/19475ded4ab6ed3945e98142cfbc8f5a2ee07dd6/src/solver/interface.jl#L6-L14">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">« Operators</a><a class="docs-footer-nextpage" href="../utility/">Utility »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 27 May 2024 14:20">Monday 27 May 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
