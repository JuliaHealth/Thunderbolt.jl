var documenterSearchIndex = {"docs":
[{"location":"vroom/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"Many algorithms in Thunderbolt run in shared memory parallel by default if you launch julia with threads, e.g. via\n\njulia --thread=<num_physical_cores>\n\nIn our experience exceeding the number of physical cores breaks performance for most simulations. Depending on your cache size simulations can even run faster if not all physical cores are utilized.\n\nWe also recommend to pin to cores for threaded simulations.\n\nusing ThreadPinning\npinthreads(:cores)","category":"section"},{"location":"references/#References","page":"References","title":"References","text":"R.Â Chadwick. Mechanics of the left ventricle. BiophysicalÂ journal 39, 279â€“288 (1982).\n\n\n\nJ.Â M.Â Guccione, L.Â K.Â Waldman and A.Â D.Â McCulloch. Mechanics of Active Contraction in Cardiac Muscle: Part IIâ€”Cylindrical Models of the Systolic Left Ventricle. JournalÂ ofÂ BiomechanicalÂ Engineering 115, 82â€“90 (1993).\n\n\n\nF.Â Regazzoni, M.Â Salvador, P.Â C.Â Africa, M.Â Fedele, L.Â DedÃ¨ and A.Â Quarteroni. A cardiac electromechanical model coupled with a lumped-parameter model for closed-loop blood circulation. JournalÂ ofÂ ComputationalÂ Physics 457, 111083 (2022).\n\n\n\nA.Â V.Â Ponnaluri, I.Â A.Â Verzhbinsky, J.Â D.Â Eldredge, A.Â Garfinkel, D.Â B.Â Ennis and L.Â E.Â Perotti. Model of left ventricular contraction: Validation criteria and boundary conditions. In: Functional Imaging and Modeling of the Heart: 10th International Conference, FIMH 2019, Bordeaux, France, June 6â€“8, 2019, Proceedings 10 (Springer, 2019); pp.Â 294â€“303.\n\n\n\nS.Â Lie. Theorie der Transformationsgruppen I. MathematischeÂ Annalen 16, 441â€“528 (1880).\n\n\n\nH.Â F.Â Trotter. On the Product of Semi-Groups of Operators. ProceedingsÂ ofÂ theÂ AmericanÂ MathematicalÂ Society 10, 545â€“551 (1959).\n\n\n\nS.Â K.Â Godunov. A difference method for numerical calculation of discontinuous solutions of the equations of hydrodynamics. MatematicheskiiÂ Sbornik 89, 271â€“306 (1959).\n\n\n\nN.Â Rabbat, A.Â Sangiovanni-Vincentelli and H.Â Hsieh. A multilevel Newton algorithm with macromodeling and latency for the analysis of large-scale nonlinear circuits in the time domain. IEEEÂ TransactionsÂ onÂ CircuitsÂ andÂ Systems 26, 733â€“741 (1979).\n\n\n\nD.Â Ogiermann, D.Â Balzani and L.Â E.Â Perotti. An Extended Generalized Hill Model for Cardiac Tissue: Comparison with Different Approaches Based on Experimental Data. In: Functional Imaging and Modeling of the Heart, edited by O.Â Bernard, P.Â Clarysse, N.Â Duchateau, J.Â Ohayon and M.Â Viallon (Cham, 2023); pp.Â 555â€“564.\n\n\n\nJ.Â StÃ¥lhand, A.Â Klarbring and G.Â A.Â Holzapfel. Smooth muscle contraction: mechanochemical formulation for homogeneous finite strains. ProgressÂ inÂ biophysicsÂ andÂ molecularÂ biology 96, 465â€“481 (2008).\n\n\n\nS.Â GÃ¶ktepe, A.Â Menzel and E.Â Kuhl. The Generalized Hill Model: A Kinematic Approach towards Active Muscle Contraction. JournalÂ ofÂ theÂ MechanicsÂ andÂ PhysicsÂ ofÂ Solids 72, 20â€“39 (2014).\n\n\n\nG.Â A.Â Holzapfel and R.Â W.Â Ogden. Constitutive modelling of passive myocardium: a structurally based framework for material characterization. PhilosophicalÂ TransactionsÂ ofÂ theÂ RoyalÂ SocietyÂ A:Â Mathematical,Â PhysicalÂ andÂ EngineeringÂ Sciences 367, 3445â€“3475 (2009).\n\n\n\nD.Â H.Â Lin and F.Â C.Â Yin. A Multiaxial Constitutive Law for Mammalian Left Ventricular Myocardium in Steady-State Barium Contracture or Tetanus. JournalÂ ofÂ BiomechanicalÂ Engineering 120, 504â€“517 (1998).\n\n\n\nJ.Â D.Â Humphrey, R.Â K.Â Strumpf and F.Â C.Â Yin. Determination of a Constitutive Relation for Passive Myocardium: I. A New Functional Form. JournalÂ ofÂ BiomechanicalÂ Engineering 112, 333â€“339 (1990).\n\n\n\nJ.Â M.Â Guccione, A.Â D.Â McCulloch and L.Â K.Â Waldman. Passive Material Properties of Intact Ventricular Myocardium Determined From a Cylindrical Model. JournalÂ ofÂ BiomechanicalÂ Engineering 113, 42â€“55 (1991).\n\n\n\nY.Â Zheng, W.Â X.Â Chan, S.Â Nielles-Vallespin, A.Â D.Â Scott, P.Â F.Â Ferreira, H.Â L.Â Leo and C.Â H.Â Yap. Effects of myocardial sheetlet sliding on left ventricular function. BiomechanicsÂ andÂ ModelingÂ inÂ Mechanobiology, 1â€“20 (2023).\n\n\n\nS.Â Rossi, T.Â Lassila, R.Â Ruiz-Baier, A.Â Sequeira and A.Â Quarteroni. Thermodynamically consistent orthotropic activation model capturing ventricular systolic wall thickening in cardiac electromechanics. EuropeanÂ JournalÂ ofÂ Mechanics-A/Solids 48, 129â€“142 (2014).\n\n\n\nR.Â Piersanti, F.Â Regazzoni, M.Â Salvador, A.Â F.Â Corno, C.Â Vergara and A.Â Quarteroni. 3Dâ€“0D closed-loop model for the simulation of cardiac biventricular electromechanics. ComputerÂ MethodsÂ inÂ AppliedÂ MechanicsÂ andÂ Engineering 391, 114607 (2022).\n\n\n\nS.Â Hartmann and P.Â Neff. Polyconvexity of generalized polynomial-type hyperelastic strain energy functions for near-incompressibility. InternationalÂ journalÂ ofÂ solidsÂ andÂ structures 40, 2767â€“2791 (2003).\n\n\n\nR.Â FitzHugh. Impulses and physiological states in theoretical models of nerve membrane. BiophysicalÂ journal 1, 445â€“466 (1961).\n\n\n\nJ.Â Nagumo, S.Â Arimoto and S.Â Yoshizawa. An active pulse transmission line simulating nerve axon. ProceedingsÂ ofÂ theÂ IRE 50, 2061â€“2070 (1962).\n\n\n\nP.Â Pathmanathan, J.Â M.Â Cordeiro and R.Â A.Â Gray. Comprehensive uncertainty quantification and sensitivity analysis for cardiac action potential models. FrontiersÂ inÂ physiology 10, 721 (2019).\n\n\n\nM.Â Hirschvogel, M.Â Bassilious, L.Â Jagschies, S.Â M.Â Wildhirt and M.Â W.Â Gee. A monolithic 3D-0D coupled closed-loop model of the heart and the vascular system: experiment-based parameter estimation for patient-specific cardiac mechanics. InternationalÂ journalÂ forÂ numericalÂ methodsÂ inÂ biomedicalÂ engineering 33, e2842 (2017).\n\n\n\nA.Â H.Â Baker, R.Â D.Â Falgout, T.Â V.Â Kolev and U.Â M.Â Yang. Multigrid Smoothers for Ultraparallel Computing. SIAMÂ JournalÂ onÂ ScientificÂ Computing 33, 2864â€“2887 (2011), arXiv:https://doi.org/10.1137/100798806.\n\n\n\nD.Â Ogiermann, L.Â E.Â Perotti and D.Â Balzani. A simple and efficient adaptive time stepping technique for low-order operator splitting schemes applied to cardiac electrophysiology. InternationalÂ JournalÂ forÂ NumericalÂ MethodsÂ inÂ BiomedicalÂ Engineering (2023).\n\n\n\nM.Â Potse, B.Â Dube, J.Â Richer, A.Â Vinet and R.Â M.Â Gulrajani. A Comparison of Monodomain and Bidomain Reaction-Diffusion Models for Action Potential Propagation in the Human Heart. IEEEÂ TransactionsÂ onÂ BiomedicalÂ Engineering 53, 2425â€“2435 (2006).\n\n\n\nD.Â Ogiermann, D.Â Balzani and L.Â E.Â Perotti. The Effect of Modeling Assumptions on the ECG in Monodomain and Bidomain Simulations. In: Functional Imaging and Modeling of the Heart, Vol.Â 12738, edited by D.Â B.Â Ennis, L.Â E.Â Perotti and V.Â Y.Â Wang (Springer, Cham, 2021); pp.Â 503â€“514.\n\n\n\nR.Â Plonsey. Volume Conductor Fields of Action Currents. BiophysicalÂ Journal 4, 317â€“328 (1964).\n\n\n\nD.Â Geselowitz. On the theory of the electrocardiogram. ProceedingsÂ ofÂ theÂ IEEE 77, 857â€“876 (1989).\n\n\n\n","category":"section"},{"location":"topics/nonlinear-solver/#Nonlinear-Solver","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"","category":"section"},{"location":"topics/nonlinear-solver/#Multi-Level-Newton-Raphson","page":"Nonlinear Solver","title":"Multi-Level Newton-Raphson","text":"A quadratically convergent Newton-Raphson scheme has been proposed by Rabbat et al. [8]. Let us assume we have a block-nonlinear problem with unknowns hatbmu and hatbmq of the following form:\n\nbeginaligned\n    bmhatf_textrmG(hatbmu hatbmq) = 0 \n    bmhatf_textrmL(hatbmu hatbmq) = 0\nendaligned\n\nwhere solving bmhatf_textrmL(hatbmu hatbmq) = 0 is easy to solve for fixed hatbmu. If we can enforce this constraint, then we can rewrite the first equation by implicit function theorem as:\n\nbmhatf_textrmG(hatbmu hatbmq(hatbmu)) = 0\n\nSolving this modified problem with a Newton-Raphson algorithm requires a linearization around hatbmu, such that we have to solve at each Newton step the following linear problem\n\nleft( fracpartial  bmhatf_textrmG partial hatbmu + fracpartial bmhatf_textrmG partial hatbmq fracmathrmd hatbmq mathrmd hatbmu right) Delta hatbmu = -bmhatf_textrmG(hatbmu hatbmq(hatbmu))\n\nIn the continuum mechanics community the system matrix is also known as the consistent linearization.\n\nThe last missing piece the implicit function part for the system matrix, which is determined by solving an additional linear system:\n\nfracpartial bmhatf_textrmL(hatbmu^i hatbmq^i) partial hatbmq fracmathrmd hatbmq mathrmd hatbmu = -fracpartial bmhatf_textrmL(hatbmu^i hatbmq^i) partial hatbmu","category":"section"},{"location":"topics/nonlinear-solver/#Using-finite-element-structure","page":"Nonlinear Solver","title":"Using finite-element structure","text":"Time discretization schemes applied to finite element semi-discretizations with L_2 variables (called internal variables) usually lead to block-nonlinear problems with local-global structure, as described above. This is commonly found in continuum mechanics problems. The local-global structure is simply a result of the algebraic decoupling of the internal variables, as they are associated with the quadrature points. For the resulting nonlinear form of the space-time discretization with field unknowns u and internal unknowns q = (q_1  q_nqp), we can write the finite element discretization formally as\n\nbeginaligned\n    f_G(uqpt) =  \n    f_Q(uqpt) =  \nendaligned\n\nTODO picture with the fundamental decomposition operators\n\nThe internal unknowns q are located at the quadrature points which implies the following structure\n\nbeginaligned\n    f_Q_1(uq_1pt) =  \n    f_Q_2(uq_2pt) =  \n    vdots \n    f_Q_nqp(uq_nqppt) =  \nendaligned","category":"section"},{"location":"topics/nonlinear-solver/#Example:-Creep-Test-of-1D-Linear-Viscoelasticity","page":"Nonlinear Solver","title":"Example: Creep Test of 1D Linear Viscoelasticity","text":"A simple linear viscoelastic material model in 1D in weak form is:\n\nbeginaligned\n                0 = int_Omega (E_0 partial_x u(xt) + E_1 (partial_x u(xt) + q(xt))) cdot partial_x delta u(x) textrmdx + Neumann \npartial_t q(xt) = fracE_1eta_1 (partial_x u(xt)-q(xt))\nendaligned\n\nAssuming we have a single 1D element Omega = -11 with linear ansatz functions and Gauss-Legendre quadrature (i.e. 2 points) the Neumann condition partial_x u(1t) = 1 and the Dirichlet condition u(-1t) = 0, then applying a Galerkin semi-discretization yields the following linear DAE in mass matrix form:\n\nbeginaligned\n            0   =  tildeu_1 \n            0   =  05left(-(E_0 + E_1) tildeu_1 + (E_0 + E_1) tildeu_2 - E_1 tildeq_1 - E_1 tildeq_2 + 1right) \nd_t tildeq_1 = fracE_1eta_1 (-tildeu_1+tildeu_2-tildeq_1) \nd_t tildeq_2 = fracE_1eta_1 (-tildeu_1+tildeu_2-tildeq_2)\nendaligned\n\nor, after condensing the first equation,\n\nbeginaligned\n            0   = 05left((E_0 + E_1) tildeu_2(t) - E_1 tildeq_1(t) - E_1 tildeq_2(t) + 1right) \nd_t tildeq_1(t) = fracE_1eta_1 (-tildeu_1+tildeu_2(t)-tildeq_1(t)) \nd_t tildeq_2(t) = fracE_1eta_1 (-tildeu_1+tildeu_2(t)-tildeq_2(t))\nendaligned\n\nApplying the Backward Euler in time to this system we obtain the ,,nonlinear'' system\n\nbeginaligned\n 0 = 05left((E_0 + E_1) hattildeu^n_2 - E_1 hattildeq_1 - E_1 hattildeq_2 + f(t_n)right) = f_G(hattildeu_2 hattildeq_1 hattildeq_2) \n 0 = hattildeq^n_1 - hattildeq^n-1_1 - Delta t_n fracE_1eta_1 (-hattildeu_1+hattildeu_2-hattildeq_1) = f_Q_1(hattildeu_2 hattildeq_1) \n 0 = hattildeq^n_2 - hattildeq^n-1_2 - Delta t_n fracE_1eta_1 (-hattildeu_1+hattildeu_2-hattildeq_2) = f_Q_2(hattildeu_2 hattildeq_2) \nendaligned\n\nwhere we can observe that the internal problems are decoupled. The system can now be solved with the multi-level Newton-Raphson as described above.","category":"section"},{"location":"devdocs/#Developer-documentation","page":"Overview","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/#Design-details","page":"Overview","title":"Design details","text":"","category":"section"},{"location":"devdocs/#Models","page":"Overview","title":"Models","text":"In Thunderbolt a model essentially describes a set of PDEs, their boundary conditions and their coupling information on a high level.","category":"section"},{"location":"devdocs/#Functions","page":"Overview","title":"Functions","text":"Functions are simply semidiscretizations together with boundary condition and coupling information for the semidiscrete form.","category":"section"},{"location":"devdocs/#Problems","page":"Overview","title":"Problems","text":"A function equipped with a time interval and an initial guess.","category":"section"},{"location":"devdocs/#Operators","page":"Overview","title":"Operators","text":"Operators decouple the function description from their evaluation.\n\nassemble_element\n\nQuestions:\n\nHow to deal with quasi-static problems which also need velocities?\nHow to make recursive assemble_element definitions for volume coupled problems?","category":"section"},{"location":"devdocs/#Solver","page":"Overview","title":"Solver","text":"Solvers construct operators from given functions and solve some problem with the function info.\n\nsetup_solver_caches(problem, solver, tâ‚€) takes the problem and a solver to setup the operators needed during solve.\n\nQuestions: \n\nHow to control which exact operator?\nWhen and how to check if the operator is compatible with the solver?\n\nSee also my brain flushing in real time some design decisions.","category":"section"},{"location":"howto/custom-sarcomere/#how-to-custom-sarcomere","page":"Adding Sarcomeres","title":"Adding Sarcomeres","text":"todo: Todo\nFinalize the sarcomere interface and document some examples here.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorials/ep04_geselowitz-ecg/#ep-tutorial_geselowitz-ecg","page":"EP04: Monodomain ECG","title":"Electrophysiology Tutorial 4: Geselowitz ECG with Monodomain Model","text":"todo: Todo\nShow computed ECG.\n\nThis tutorial shows how to setup ECG problems with monodomain models as the source and compute the QRS complex in a simple toy problem.\n\ntodo: Todo\nProvide context.","category":"section"},{"location":"tutorials/ep04_geselowitz-ecg/#Commented-Program","page":"EP04: Monodomain ECG","title":"Commented Program","text":"using Thunderbolt, LinearAlgebra, StaticArrays, OrdinaryDiffEqOperatorSplitting\n\ntodo: Todo\nThe initializer API is not yet finished and hence we deconstruct stuff here manually. Please note that this method is quite fragile w.r.t. to many changes you can make in the code below.\n\nfunction steady_state_initializer!(uâ‚€, f::GenericSplitFunction)\n    # TODO cleaner implementation. We need to extract this from the types or via dispatch.\n    heatfun = f.functions[1]\n    heat_dofrange = f.solution_indices[1]\n    odefun = f.functions[2]\n    ionic_model = odefun.ode\n\n    Ï†â‚€ = @view uâ‚€[heat_dofrange];\n    # TODO extraction these via utility functions\n    dh = heatfun.dh\n    sâ‚€flat = @view uâ‚€[(ndofs(dh)+1):end];\n    # Should not be reshape but some array of arrays fun\n    sâ‚€ = reshape(sâ‚€flat, (ndofs(dh), Thunderbolt.num_states(ionic_model)-1));\n    default_values = Thunderbolt.default_initial_state(ionic_model)\n\n    Ï†â‚€ .= default_values[1]\n    for i âˆˆ 1:(Thunderbolt.num_states(ionic_model)-1)\n        sâ‚€[:, i] .= default_values[i+1]\n    end\nend\n\nWe start by defining a custom activation function\n\nBase.@kwdef struct UniformEndocardialActivation <: Function\n    transmural_depth::Float64 = 0.15\nend\nfunction (p::UniformEndocardialActivation)(x::Vec{3}, t)\n    Ï„á¶  = 0.25\n    # TODO source for this\n    if t â‰¤ 2.0 && x[1] < p.transmural_depth\n        return 0.5/Ï„á¶  * exp(t/Ï„á¶ )\n    else\n        return 0.0\n    end\nend\nprotocol = Thunderbolt.AnalyticalTransmembraneStimulationProtocol(\n    AnalyticalCoefficient(\n        UniformEndocardialActivation(),\n        CartesianCoordinateSystem{3}()\n    ),\n    [SVector((-Inf, Inf))],\n)\n\nWe also generate both meshes\n\nnum_elements_heart = (32,16,16)\nnum_elements_heart = (8,4,4) # hide\nheart_mesh = generate_mesh(Tetrahedron, num_elements_heart, Vec((1.5, 1.5, 0.0)), Vec((5.5, 3.5, 2.0)))\nnum_elements_torso = (56,40,28)\nnum_elements_torso = (14,10,7) # hide\ntorso_mesh = generate_mesh(Hexahedron,  num_elements_torso, Vec((0.0, 0.0, 0.0)), Vec((7.0, 5.0, 3.5)))\n\nThen we place some electrodes and leads.\n\nground_vertex = Thunderbolt.get_closest_vertex(Vec(0.0, 0.0, 0.0), torso_mesh)\nleads = [\n    [Vec( 0.,   0.,  1.5), Vec( 7.,   0.,  1.5)],\n    [Vec( 3.5,  0.,  1.5), Vec( 3.5,  5.,  1.5)],\n]\n\nFor our toy problem we use a very simple microstructure.\n\nmicrostructure = OrthotropicMicrostructureModel(\n    ConstantCoefficient((Vec(0.0,0.0,1.0))),\n    ConstantCoefficient((Vec(0.0,1.0,0.0))),\n    ConstantCoefficient((Vec(1.0,0.0,0.0))),\n)\n\nWith the microstructure we setup the diffusion tensor field in spectral form.\n\ntodo: Todo\ncitation\n\nÎºâ‚ = 0.17 * 0.62 / (0.17 + 0.62)\nÎºáµ£ = 0.019 * 0.24 / (0.019 + 0.24)\ndiffusion_tensor_field = SpectralTensorCoefficient(\n    microstructure,\n    ConstantCoefficient(SVector(Îºâ‚, Îºáµ£, Îºáµ£))\n)\n\nNow we setup our monodomain solver as usual.\n\ncellmodel = Thunderbolt.PCG2019()\nheart_model = MonodomainModel(\n    ConstantCoefficient(1.0),\n    ConstantCoefficient(1.0),\n    diffusion_tensor_field,\n    protocol,\n    cellmodel,\n    :Ï†â‚˜, :s\n)\nheart_odeform = semidiscretize(\n    ReactionDiffusionSplit(heart_model),\n    FiniteElementDiscretization(Dict(:Ï†â‚˜ => LagrangeCollection{1}())),\n    heart_mesh,\n)\nuâ‚€ = zeros(Float64, solution_size(heart_odeform))\nsteady_state_initializer!(uâ‚€, heart_odeform)\ndtâ‚€ = 0.01\ndtvis = 0.5\nTâ‚˜â‚â‚“ = 50.0\nTâ‚˜â‚â‚“ = dtvis # hide\ntspan = (0.0, Tâ‚˜â‚â‚“)\nproblem = OperatorSplittingProblem(heart_odeform, uâ‚€, tspan)\ntimestepper = LieTrotterGodunov((\n    BackwardEulerSolver(),\n    ForwardEulerCellSolver(),\n))\nintegrator = init(problem, timestepper, dt=dtâ‚€, verbose=true)\n\nNow that the time integrator is ready we setup the ECG problem.\n\ntorso_mesh_Îºáµ¢ = ConstantCoefficient(1.0)\ntorso_mesh_Îº  = ConstantCoefficient(1.0)\n\ntodo: Todo\nShow how to transfer diffusion_tensor_field onto the torso mesh.\n\ngeselowitz_ecg = Thunderbolt.Geselowitz1989ECGLeadCache(\n    heart_odeform,\n    torso_mesh,\n    torso_mesh_Îºáµ¢,\n    torso_mesh_Îº,\n    leads;\n    ground = Thunderbolt.OrderedSet([ground_vertex])\n)\n\ntodo: Todo\nImprove the ECG API to not spill all the internals. :)\n\nWe compute the ECG online as follows.\n\nio = ParaViewWriter(\"ep04_ecg\")\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    dh = heart_odeform.functions[1].dh\n    Ï† = u[heart_odeform.solution_indices[1]]\n    store_timestep!(io, t, dh.grid) do file\n        Thunderbolt.store_timestep_field!(file, t, dh, Ï†, :Ï†â‚˜)\n    end\n\n    # To compute the ECG we just need to update the ecg cache\n    Thunderbolt.update_ecg!(geselowitz_ecg, Ï†)\n    # which then allows us to evaluate the leads like this\n    electrode_values = Thunderbolt.evaluate_ecg(geselowitz_ecg)\n    @info \"$t: Lead 1=$(electrode_values[1]) | Lead 2= $(electrode_values[2])\"\nend","category":"section"},{"location":"tutorials/ep04_geselowitz-ecg/#References","page":"EP04: Monodomain ECG","title":"References","text":"","category":"section"},{"location":"tutorials/ep04_geselowitz-ecg/#ep-tutorial_geselowitz-ecg-plain-program","page":"EP04: Monodomain ECG","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: ep04_geselowitz-ecg.jl.\n\nusing Thunderbolt, LinearAlgebra, StaticArrays, OrdinaryDiffEqOperatorSplitting\n\nfunction steady_state_initializer!(uâ‚€, f::GenericSplitFunction)\n    # TODO cleaner implementation. We need to extract this from the types or via dispatch.\n    heatfun = f.functions[1]\n    heat_dofrange = f.solution_indices[1]\n    odefun = f.functions[2]\n    ionic_model = odefun.ode\n\n    Ï†â‚€ = @view uâ‚€[heat_dofrange];\n    # TODO extraction these via utility functions\n    dh = heatfun.dh\n    sâ‚€flat = @view uâ‚€[(ndofs(dh)+1):end];\n    # Should not be reshape but some array of arrays fun\n    sâ‚€ = reshape(sâ‚€flat, (ndofs(dh), Thunderbolt.num_states(ionic_model)-1));\n    default_values = Thunderbolt.default_initial_state(ionic_model)\n\n    Ï†â‚€ .= default_values[1]\n    for i âˆˆ 1:(Thunderbolt.num_states(ionic_model)-1)\n        sâ‚€[:, i] .= default_values[i+1]\n    end\nend\n\nBase.@kwdef struct UniformEndocardialActivation <: Function\n    transmural_depth::Float64 = 0.15\nend\nfunction (p::UniformEndocardialActivation)(x::Vec{3}, t)\n    Ï„á¶  = 0.25\n    # TODO source for this\n    if t â‰¤ 2.0 && x[1] < p.transmural_depth\n        return 0.5/Ï„á¶  * exp(t/Ï„á¶ )\n    else\n        return 0.0\n    end\nend\nprotocol = Thunderbolt.AnalyticalTransmembraneStimulationProtocol(\n    AnalyticalCoefficient(\n        UniformEndocardialActivation(),\n        CartesianCoordinateSystem{3}()\n    ),\n    [SVector((-Inf, Inf))],\n)\n\nnum_elements_heart = (32,16,16)\nnum_elements_heart = (8,4,4) # hide\nheart_mesh = generate_mesh(Tetrahedron, num_elements_heart, Vec((1.5, 1.5, 0.0)), Vec((5.5, 3.5, 2.0)))\nnum_elements_torso = (56,40,28)\nnum_elements_torso = (14,10,7) # hide\ntorso_mesh = generate_mesh(Hexahedron,  num_elements_torso, Vec((0.0, 0.0, 0.0)), Vec((7.0, 5.0, 3.5)))\n\nground_vertex = Thunderbolt.get_closest_vertex(Vec(0.0, 0.0, 0.0), torso_mesh)\nleads = [\n    [Vec( 0.,   0.,  1.5), Vec( 7.,   0.,  1.5)],\n    [Vec( 3.5,  0.,  1.5), Vec( 3.5,  5.,  1.5)],\n]\n\nmicrostructure = OrthotropicMicrostructureModel(\n    ConstantCoefficient((Vec(0.0,0.0,1.0))),\n    ConstantCoefficient((Vec(0.0,1.0,0.0))),\n    ConstantCoefficient((Vec(1.0,0.0,0.0))),\n)\n\nÎºâ‚ = 0.17 * 0.62 / (0.17 + 0.62)\nÎºáµ£ = 0.019 * 0.24 / (0.019 + 0.24)\ndiffusion_tensor_field = SpectralTensorCoefficient(\n    microstructure,\n    ConstantCoefficient(SVector(Îºâ‚, Îºáµ£, Îºáµ£))\n)\n\ncellmodel = Thunderbolt.PCG2019()\nheart_model = MonodomainModel(\n    ConstantCoefficient(1.0),\n    ConstantCoefficient(1.0),\n    diffusion_tensor_field,\n    protocol,\n    cellmodel,\n    :Ï†â‚˜, :s\n)\nheart_odeform = semidiscretize(\n    ReactionDiffusionSplit(heart_model),\n    FiniteElementDiscretization(Dict(:Ï†â‚˜ => LagrangeCollection{1}())),\n    heart_mesh,\n)\nuâ‚€ = zeros(Float64, solution_size(heart_odeform))\nsteady_state_initializer!(uâ‚€, heart_odeform)\ndtâ‚€ = 0.01\ndtvis = 0.5\nTâ‚˜â‚â‚“ = 50.0\nTâ‚˜â‚â‚“ = dtvis # hide\ntspan = (0.0, Tâ‚˜â‚â‚“)\nproblem = OperatorSplittingProblem(heart_odeform, uâ‚€, tspan)\ntimestepper = LieTrotterGodunov((\n    BackwardEulerSolver(),\n    ForwardEulerCellSolver(),\n))\nintegrator = init(problem, timestepper, dt=dtâ‚€, verbose=true)\n\ntorso_mesh_Îºáµ¢ = ConstantCoefficient(1.0)\ntorso_mesh_Îº  = ConstantCoefficient(1.0)\n\ngeselowitz_ecg = Thunderbolt.Geselowitz1989ECGLeadCache(\n    heart_odeform,\n    torso_mesh,\n    torso_mesh_Îºáµ¢,\n    torso_mesh_Îº,\n    leads;\n    ground = Thunderbolt.OrderedSet([ground_vertex])\n)\n\nio = ParaViewWriter(\"ep04_ecg\")\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    dh = heart_odeform.functions[1].dh\n    Ï† = u[heart_odeform.solution_indices[1]]\n    store_timestep!(io, t, dh.grid) do file\n        Thunderbolt.store_timestep_field!(file, t, dh, Ï†, :Ï†â‚˜)\n    end\n\n    # To compute the ECG we just need to update the ecg cache\n    Thunderbolt.update_ecg!(geselowitz_ecg, Ï†)\n    # which then allows us to evaluate the leads like this\n    electrode_values = Thunderbolt.evaluate_ecg(geselowitz_ecg)\n    @info \"$t: Lead 1=$(electrode_values[1]) | Lead 2= $(electrode_values[2])\"\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"howto/benchmarking/#Benchmarking","page":"Benchmarking","title":"Benchmarking","text":"To investiage the performance we can use the following code snippet, which should be self-explanatory\n\nusing Thunderbolt.TimerOutputs\nTimerOutputs.enable_debug_timings(Thunderbolt)\nTimerOutputs.reset_timer!()\nrun_simulation()\nTimerOutputs.print_timer()\nTimerOutputs.disable_debug_timings(Thunderbolt)\n\nIt makes sense to make sure the code is properly precompiled before benchmarkins, e.g. by calling run_simulation() once before running the code snippet.\n\nInternally we use TimerOutputs.jl for code annotations, marking performance critical sections.\n\nMore guides coming soon...","category":"section"},{"location":"tutorials/cm04_pericardium/#mechanics-tutorial_pericardium","page":"CM04: Pericadium (TODO)","title":"Mechanics Tutorial 4: Pericardial Boundary Conditions","text":"todo: Todo\nshow pericardium\n\nThis tutorial shows how to couple include prestress in your simulations and how to recover the correct initial condition.\n\ntodo: Todo\nProvide context.","category":"section"},{"location":"tutorials/cm04_pericardium/#Commented-Program","page":"CM04: Pericadium (TODO)","title":"Commented Program","text":"todo: Todo\nImplement [4]","category":"section"},{"location":"tutorials/cm04_pericardium/#References","page":"CM04: Pericadium (TODO)","title":"References","text":"A.Â V.Â Ponnaluri, I.Â A.Â Verzhbinsky, J.Â D.Â Eldredge, A.Â Garfinkel, D.Â B.Â Ennis and L.Â E.Â Perotti. Model of left ventricular contraction: Validation criteria and boundary conditions. In: Functional Imaging and Modeling of the Heart: 10th International Conference, FIMH 2019, Bordeaux, France, June 6â€“8, 2019, Proceedings 10 (Springer, 2019); pp.Â 294â€“303.\n\n\n\n","category":"section"},{"location":"tutorials/cm04_pericardium/#mechanics-tutorial_pericardium-plain-program","page":"CM04: Pericadium (TODO)","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: cm04_pericardium.jl.\n\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api-reference/models/#models-api","page":"Models","title":"Models","text":"","category":"section"},{"location":"api-reference/models/#Coefficient","page":"Models","title":"Coefficient","text":"","category":"section"},{"location":"api-reference/models/#microstructure-api","page":"Models","title":"Microstructure","text":"","category":"section"},{"location":"api-reference/models/#Boundary-Conditions","page":"Models","title":"Boundary Conditions","text":"","category":"section"},{"location":"api-reference/models/#Solid-Mechanics","page":"Models","title":"Solid Mechanics","text":"","category":"section"},{"location":"api-reference/models/#Passive-Energies","page":"Models","title":"Passive Energies","text":"","category":"section"},{"location":"api-reference/models/#Active-Energies","page":"Models","title":"Active Energies","text":"","category":"section"},{"location":"api-reference/models/#Active-Deformation-Gradients","page":"Models","title":"Active Deformation Gradients","text":"","category":"section"},{"location":"api-reference/models/#Active-Stresses","page":"Models","title":"Active Stresses","text":"","category":"section"},{"location":"api-reference/models/#Compression","page":"Models","title":"Compression","text":"","category":"section"},{"location":"api-reference/models/#Electrophysiology","page":"Models","title":"Electrophysiology","text":"","category":"section"},{"location":"api-reference/models/#Cells","page":"Models","title":"Cells","text":"warning: Warning\nThese are intended to be replaced by ModelingToolkit analogues!","category":"section"},{"location":"api-reference/models/#Fluid-Mechanics","page":"Models","title":"Fluid Mechanics","text":"","category":"section"},{"location":"api-reference/models/#Lumped-Models","page":"Models","title":"Lumped Models","text":"","category":"section"},{"location":"api-reference/models/#Multiphysics","page":"Models","title":"Multiphysics","text":"","category":"section"},{"location":"api-reference/models/#Generic-Interface","page":"Models","title":"Generic Interface","text":"","category":"section"},{"location":"api-reference/models/#FSI","page":"Models","title":"FSI","text":"","category":"section"},{"location":"api-reference/models/#Thunderbolt.ConstantCoefficient","page":"Models","title":"Thunderbolt.ConstantCoefficient","text":"ConstantCoefficient(value)\n\nEvaluates to the same value in space and time everywhere.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.FieldCoefficient","page":"Models","title":"Thunderbolt.FieldCoefficient","text":"FieldCoefficient(data, interpolation)\n\nA constant in time data field, interpolated per element with a given interpolation.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.AnalyticalCoefficient","page":"Models","title":"Thunderbolt.AnalyticalCoefficient","text":"AnalyticalCoefficient(f::Function, cs::CoordinateSystemCoefficient)\n\nA coefficient given as the analytical function f(x,t) in the specified coordiante system.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.SpectralTensorCoefficient","page":"Models","title":"Thunderbolt.SpectralTensorCoefficient","text":"SpectralTensorCoefficient(eigenvector_coefficient, eigenvalue_coefficient)\n\nRepresent a tensor A via spectral decomposition âˆ‘áµ¢ Î»áµ¢ váµ¢ âŠ— váµ¢.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.SpatiallyHomogeneousDataField","page":"Models","title":"Thunderbolt.SpatiallyHomogeneousDataField","text":"SpatiallyHomogeneousDataField(timings::Vector, data::Vector)\n\nA data field which is constant in space and piecewise constant in time.\n\nThe value during the time interval [táµ¢,táµ¢â‚Šâ‚] is dataáµ¢, where tâ‚€ is negative infinity and the last time point+1 is positive infinity.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.create_microstructure_model","page":"Models","title":"Thunderbolt.create_microstructure_model","text":"create_microstructure_model(coordinate_system::CoordinateSystemCoefficient, ip::VectorInterpolationCollection, parameters)\n\nCreate a rotating fiber field by deducing the circumferential direction from apicobasal and transmural gradients.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/models/#Thunderbolt.ODB25LTMicrostructureParameters","page":"Models","title":"Thunderbolt.ODB25LTMicrostructureParameters","text":"Linear transmural distribution of the microstructure with three angles to describe all reachable physiological angles.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.RobinBC","page":"Models","title":"Thunderbolt.RobinBC","text":"RobinBC(Î±, boundary_name::String)\n\nbmP(bmu) cdot bmn_0 = - alpha bmu quad textbfx in partial Omega_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.NormalSpringBC","page":"Models","title":"Thunderbolt.NormalSpringBC","text":"NormalSpringBC(kâ‚› boundary_name::String)\n\nbmP(bmu) cdot bmn_0 = - k_s bmu cdot n_0 quad textbfx in partial Omega_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.BendingSpringBC","page":"Models","title":"Thunderbolt.BendingSpringBC","text":"BendingSpringBC(káµ‡, boundary_name::String)\n\nbmP(bmu) cdot bmn_0 = - partial_F frac12 k_b left (cof(F) n_0 - n_0 right) quad textbfx in partial Omega_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ConstantPressureBC","page":"Models","title":"Thunderbolt.ConstantPressureBC","text":"ConstantPressureBC(p::Real, boundary_name::String)\n\nbmP(bmu) cdot bmn_0 = - p n_0 quad textbfx in partial Omega_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.PressureFieldBC","page":"Models","title":"Thunderbolt.PressureFieldBC","text":"PressureFieldBC(pressure_field, boundary_name::String)\n\nbmP(bmu) cdot bmn_0 = - k_s bmu cdot n_0 quad textbfx in partial Omega_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.QuasiStaticModel","page":"Models","title":"Thunderbolt.QuasiStaticModel","text":"QuasiStaticModel(displacement_sym, mechanical_model, facet_models)\n\nA generic model for quasi-static mechanical problems.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ExtendedHillModel","page":"Models","title":"Thunderbolt.ExtendedHillModel","text":"ExtendedHillModel(passive_spring_model, active_spring_model, active_deformation_gradient_model,contraction_model, microstructure_model)\n\nThe extended (generalized) Hill model as proposed by Ogiermann et al. [9]. The original formulation dates back to StÃ¥lhand et al. [10] for smooth muscle tissues.\n\nIn this framework the model is formulated as an energy minimization problem with the following additively split energy:\n\nW(mathbfF mathbfF^rma) = W_rmpassive(mathbfF) + mathcalN(bmalpha)W_rmactive(mathbfFmathbfF^-rma)\n\nWhere W_rmpassive is the passive material response and W_rmactive the active response respectvely. mathcalN is the amount of formed crossbridges. We refer to the original paper [9] for more details.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.GeneralizedHillModel","page":"Models","title":"Thunderbolt.GeneralizedHillModel","text":"GeneralizedHillModel(passive_spring_model, active_spring_model, active_deformation_gradient_model,contraction_model, microstructure_model)\n\nThe generalized Hill framework as proposed by GÃ¶ktepe et al. [11].\n\nIn this framework the model is formulated as an energy minimization problem with the following additively split energy:\n\nW(mathbfF mathbfF^rma) = W_rmpassive(mathbfF) + W_rmactive(mathbfFmathbfF^-rma)\n\nWhere W_rmpassive is the passive material response and W_rmactive the active response respectvely.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ActiveStressModel","page":"Models","title":"Thunderbolt.ActiveStressModel","text":"ActiveStressModel(material_model, active_stress_model, contraction_model, microstructure_model)\n\nThe active stress model as originally proposed by Guccione et al. [2].\n\nIn this framework the model is formulated via balance of linear momentum in the first Piola Kirchhoff mathbfP:\n\nmathbfP(mathbfFT^rma) = partial_mathbfF W_rmpassive(mathbfF) + mathbfP^rma(mathbfF T^rma)\n\nwhere the passive material response can be described by an energy W_rmpassive and T^rma the active tension generated by the contraction model.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.PK1Model","page":"Models","title":"Thunderbolt.PK1Model","text":"PK1Model(material, coefficient_field)\nPK1Model(material, internal_model, coefficient_field)\n\nModels the stress formulated in the 1st Piola-Kirchhoff stress tensor. If the material is energy-based, then the term is formulated as follows: $\\int{\\Omega0} P(u,s) \\cdot \\delta F dV = \\int{\\Omega0} \\partial_{F} \\psi(u,s) \\cdot \\delta \\nabla u $\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.PrestressedMechanicalModel","page":"Models","title":"Thunderbolt.PrestressedMechanicalModel","text":"PrestressedMechanicalModel(inner_model, prestress_field)\n\nModels the stress formulated in the 1st Piola-Kirchhoff stress tensor based on a multiplicative split of the deformation gradient F = F_textrme F_0 where we compute P(F_textrme) = P(F F^-1_0).\n\nPlease note that it is assumed that F^-1_0 is the quantity computed by prestress_field.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.NullEnergyModel","page":"Models","title":"Thunderbolt.NullEnergyModel","text":"A simple dummy energy with Psi = 0.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.LinearSpringModel","page":"Models","title":"Thunderbolt.LinearSpringModel","text":"A simple linear fiber spring model for testing purposes.\n\nPsi^rma = fraca^rmf2(I_e^rme-1)^2\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.TransverseIsotopicNeoHookeanModel","page":"Models","title":"Thunderbolt.TransverseIsotopicNeoHookeanModel","text":"https://onlinelibrary.wiley.com/doi/epdf/10.1002/cnm.2866\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.HolzapfelOgden2009Model","page":"Models","title":"Thunderbolt.HolzapfelOgden2009Model","text":"The well-known orthotropic material model for the passive response of cardiac tissues by Holzapfel and Ogden [12].\n\nPsi = fraca2b e^b(I_1-3) + sum_iinrmfrms fraca^i2b^i(e^b^iI_4^i - 1^2-1) + fraca^rmfs2b^rmfs(e^b^rmfsI_8^rmfs^2-1)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.LinYinPassiveModel","page":"Models","title":"Thunderbolt.LinYinPassiveModel","text":"This is the Fung-type transverse isotropic material model for the passive  response of cardiac tissue proposed by Lin and Yin [13].\n\nPsi = C_1(e^C_2(I_1-3)^2 + C_3(I_1-3)(I_4-1) + C_4(I_4-1)^2-1)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.LinYinActiveModel","page":"Models","title":"Thunderbolt.LinYinActiveModel","text":"This is the transverse isotropic material model for the active  response of cardiac tissue proposed by Lin and Yin [13].\n\nPsi=C_0 + C_1*(I_1-3)(I_4-1) + C_2(I_1-3)^2 + C_3*(I_4-1)^2 + C_3*(I_1-3) + C_5*(I_4-1)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.HumphreyStrumpfYinModel","page":"Models","title":"Thunderbolt.HumphreyStrumpfYinModel","text":"This is the transverse isotropic material model for the active  response of cardiac tissue proposed by Humphrey et al. [14].\n\nPsi = C_1(sqrtI_4-1)^2 + C_2(sqrtI_4-1)^3 + C_3(sqrtI_4-1)(I_1-3) + C_3(I_1-3)^2\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.Guccione1991PassiveModel","page":"Models","title":"Thunderbolt.Guccione1991PassiveModel","text":"An orthotropic material model for the passive myocardial tissue response by Guccione et al. [15].\n\nPsi = B^rmff E^rmff^2 + B^rmssE^rmss^2 + B^rmnnE^rmnn^2 + B^rmns(E^rmns^2+E^rmsn^2) + B^rmfs(E^rmfs^2+E^rmsf^2) + B^rmfn(E^rmfn^2+E^rmnf^2)\n\nThe default parameterization is taken from from [16].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.BioNeoHookean","page":"Models","title":"Thunderbolt.BioNeoHookean","text":"BioNeoHookean\n\nA simple isotropic Neo-Hookean model of the form\n\nPsi = alpha (barI_1-3)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.SimpleActiveSpring","page":"Models","title":"Thunderbolt.SimpleActiveSpring","text":"SimpleActiveSpring\n\nA simple linear fiber spring as for example found in [11].\n\nPsi^rma = fraca^rmf2(I_e^rme-1)^2\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ActiveMaterialAdapter","page":"Models","title":"Thunderbolt.ActiveMaterialAdapter","text":"A simple helper to use a passive material model as an active material for GeneralizedHillModel, ExtendedHillModel and ActiveStressModel.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.GMKActiveDeformationGradientModel","page":"Models","title":"Thunderbolt.GMKActiveDeformationGradientModel","text":"The active deformation gradient formulation by GÃ¶ktepe et al. [11].\n\nF^rma = (lambda^rma-1) f_0 otimes f_0\n\nI$\n\nSee also [9] for a further analysis.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.GMKIncompressibleActiveDeformationGradientModel","page":"Models","title":"Thunderbolt.GMKIncompressibleActiveDeformationGradientModel","text":"An incompressivle version of the active deformation gradient formulation by GÃ¶ktepe et al. [11].\n\nF^rma = lambda^rma f_0 otimes f_0 + frac1sqrtlambda^rma(s_0 otimes s_0 + n_0 otimes n_0)\n\nSee also [9] for a further analysis.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.RLRSQActiveDeformationGradientModel","page":"Models","title":"Thunderbolt.RLRSQActiveDeformationGradientModel","text":"The active deformation gradient formulation by Rossi et al. [17].\n\nF^rma = lambda^rma f_0 otimes f_0 + (1+kappa(lambda^rma-1)) s_0 otimes s_0 + frac11+kappa(lambda^rma-1))lambda^rma n_0 otimes n_0\n\nWhere kappa geq 0 is the sheelet part.\n\nSee also [9] for a further analysis.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.SimpleActiveStress","page":"Models","title":"Thunderbolt.SimpleActiveStress","text":"A simple active stress component.\n\nT^rma = T^rmmax  Ca_rmi frac(F cdot f_0) otimes f_0F cdot f_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.PiersantiActiveStress","page":"Models","title":"Thunderbolt.PiersantiActiveStress","text":"The active stress component described by Piersanti et al. [18] (Eq. 3).\n\nT^rma = T^rmmax  Ca_rmi left(p^f frac(F cdot f_0) otimes f_0F cdot f_0 + p^rms frac(F cdot s_0) otimes s_0F cdot s_0 + p^rmn frac(F cdot n_0) otimes n_0F cdot n_0right)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.Guccione1993ActiveModel","page":"Models","title":"Thunderbolt.Guccione1993ActiveModel","text":"The active stress component as described by Guccione et al. [2].\n\nT^rma = T^rmmax  Ca_rmi (F cdot f_0) otimes f_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.NullCompressionPenalty","page":"Models","title":"Thunderbolt.NullCompressionPenalty","text":"A simple dummy compression model with U(I_3) = 0.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.SimpleCompressionPenalty","page":"Models","title":"Thunderbolt.SimpleCompressionPenalty","text":"A compression model with U(I_3) = beta (I_3 -1 - 2log(sqrtI_3))^a.\n\nnote: Note\nCitation missing. How is this one called in literature?\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.HartmannNeffCompressionPenalty1","page":"Models","title":"Thunderbolt.HartmannNeffCompressionPenalty1","text":"An isochoric compression model where\n\nU(I_3) = beta (I_3^b + I_3^-b -2)^a\n\nwith ab geq 1.\n\nEntry 1 from table 3 in [19].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.HartmannNeffCompressionPenalty2","page":"Models","title":"Thunderbolt.HartmannNeffCompressionPenalty2","text":"An isochoric compression model where \n\nU(I_3) = beta (sqrtI_3-1)^a\n\nwith a  1.\n\nEntry 2 from table 3 in [19].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.HartmannNeffCompressionPenalty3","page":"Models","title":"Thunderbolt.HartmannNeffCompressionPenalty3","text":"An isochoric compression model where \n\nU(I_3) = beta (I_3 - 2log(sqrtI_3) + 4log(sqrtI_3)^2) - 1)\n\nEntry 3 from table 3 in [19].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.TransientDiffusionModel","page":"Models","title":"Thunderbolt.TransientDiffusionModel","text":"TransientDiffusionModel(conductivity_coefficient, source_term, solution_variable_symbol)\n\nModel formulated as partial_t u = nabla cdot kappa(x) nabla u + f\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.SteadyDiffusionModel","page":"Models","title":"Thunderbolt.SteadyDiffusionModel","text":"SteadyDiffusionModel(conductivity_coefficient, source_term, solution_variable_symbol)\n\nModel formulated as nabla cdot kappa(x) nabla u = f\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.MonodomainModel","page":"Models","title":"Thunderbolt.MonodomainModel","text":"Simplification of the bidomain model with the structure\n\nÏ‡Câ‚˜âˆ‚â‚œÏ†â‚˜ = âˆ‡â‹…Îºâˆ‡Ï†â‚˜ + Ï‡(Iáµ¢â‚’â‚™(Ï†â‚˜,ğ¬) + Iâ‚›â‚œáµ¢â‚˜(t))     âˆ‚â‚œğ¬  = g(Ï†â‚˜,ğ¬)\n\n(TODO citation). Can be derived through the assumption (TODO), but also when the assumption is violated we can construct optimal Îº (TODO citation+example) for the reconstruction of Ï†â‚˜.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ParabolicParabolicBidomainModel","page":"Models","title":"Thunderbolt.ParabolicParabolicBidomainModel","text":"The original model formulation (TODO citation) with the structure\n\nÏ‡Câ‚˜âˆ‚â‚œÏ†â‚˜ = âˆ‡â‹…Îºáµ¢âˆ‡Ï†áµ¢ + Ï‡(Iáµ¢â‚’â‚™(Ï†â‚˜,ğ¬,x) + Iâ‚›â‚œáµ¢â‚˜,áµ¢(x,t))  Ï‡Câ‚˜âˆ‚â‚œÏ†â‚˜ = âˆ‡â‹…Îºâ‚‘âˆ‡Ï†â‚‘ - Ï‡(Iáµ¢â‚’â‚™(Ï†â‚˜,ğ¬,x) + Iâ‚›â‚œáµ¢â‚˜,â‚‘(x,t))     âˆ‚â‚œğ¬  = g(Ï†â‚˜,ğ¬,x)  Ï†áµ¢ - Ï†â‚‘ = Ï†â‚˜\n\nwarn: Warn\nNot implemented yet.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ParabolicEllipticBidomainModel","page":"Models","title":"Thunderbolt.ParabolicEllipticBidomainModel","text":"Transformed bidomain model with the structure\n\nÏ‡Câ‚˜âˆ‚â‚œÏ†â‚˜ = âˆ‡â‹…Îºáµ¢âˆ‡Ï†â‚˜ + âˆ‡â‹…Îºáµ¢âˆ‡Ï†â‚‘      + Ï‡(Iáµ¢â‚’â‚™(Ï†â‚˜,ğ¬,x) + Iâ‚›â‚œáµ¢â‚˜(x,t))       0  = âˆ‡â‹…Îºáµ¢âˆ‡Ï†â‚˜ + âˆ‡â‹…(Îºáµ¢+Îºâ‚‘)âˆ‡Ï†â‚‘ +  Iâ‚›â‚œáµ¢â‚˜,â‚‘(t) - Iâ‚›â‚œáµ¢â‚˜,áµ¢(t)     âˆ‚â‚œğ¬  = g(Ï†â‚˜,ğ¬,x)       Ï†áµ¢ = Ï†â‚˜ + Ï†â‚‘\n\nThis formulation is a transformation of the parabolic-parabolic form (c.f. TODO citation) and has been derived by (TODO citation) first.\n\nwarn: Warn\nNot implemented yet.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ReactionDiffusionSplit","page":"Models","title":"Thunderbolt.ReactionDiffusionSplit","text":"ReactionDiffusionSplit(model)\nReactionDiffusionSplit(model, coeff)\n\nAnnotation for the classical reaction-diffusion split of a given model. The second argument is a coefficient describing the input x for the reaction model rhs, which is usually some generalized coordinate.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.NoStimulationProtocol","page":"Models","title":"Thunderbolt.NoStimulationProtocol","text":"A dummy protocol describing the absence of stimuli for a simulation.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.TransmembraneStimulationProtocol","page":"Models","title":"Thunderbolt.TransmembraneStimulationProtocol","text":"Supertype for all stimulation protocols fulfilling I_rmstime = I_rmstimi.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.AnalyticalTransmembraneStimulationProtocol","page":"Models","title":"Thunderbolt.AnalyticalTransmembraneStimulationProtocol","text":"Describe the transmembrane stimulation by some analytical function on a given set of time intervals.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ParametrizedFHNModel","page":"Models","title":"Thunderbolt.ParametrizedFHNModel","text":"The classical neuron electrophysiology model independently found by FitzHugh [20] and Nagumo et al. [21]. This model is less stiff and cheaper than any cardiac electrophysiology model, which maks it  a good choice for quick testing if things work at all.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ParametrizedPCG2019Model","page":"Models","title":"Thunderbolt.ParametrizedPCG2019Model","text":"The canine ventricular cardiomyocyte electrophysiology model by Pathmanathan et al. [22].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.DummyLumpedCircuitModel","page":"Models","title":"Thunderbolt.DummyLumpedCircuitModel","text":"DummyLumpedCircuitModel(volume_fun)\n\nLock the volume at a certain value.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.MTKLumpedCicuitModel","page":"Models","title":"Thunderbolt.MTKLumpedCicuitModel","text":"MTKLumpedCicuitModel\n\nA lumped (0D) circulatory model for LV simulations as presented in Regazzoni et al. [3].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.RSAFDQ2022LumpedCicuitModel","page":"Models","title":"Thunderbolt.RSAFDQ2022LumpedCicuitModel","text":"RSAFDQ2022LumpedCicuitModel\n\nA lumped (0D) circulatory model for LV simulations as presented in Regazzoni et al. [3].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.InterfaceCoupler","page":"Models","title":"Thunderbolt.InterfaceCoupler","text":"Abstract supertype for all interface coupling schemes.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.VolumeCoupler","page":"Models","title":"Thunderbolt.VolumeCoupler","text":"Abstract supertype for all volume coupling schemes.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.Coupling","page":"Models","title":"Thunderbolt.Coupling","text":"Helper to describe the coupling between problems.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.CoupledModel","page":"Models","title":"Thunderbolt.CoupledModel","text":"A descriptor for a coupled model.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.LumpedFluidSolidCoupler","page":"Models","title":"Thunderbolt.LumpedFluidSolidCoupler","text":"Enforce the constraints that   chamber volume 3D (solid model) = chamber volume 0D (lumped circuit) via Lagrange multiplied, where a surface pressure integral is introduced such that   âˆ«  âˆ‚Î©endo Here chamber_volume_method is responsible to compute the 3D volume.\n\nThis approach has been proposed by Regazzoni et al. [3].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.Hirschvogel2017SurrogateVolume","page":"Models","title":"Thunderbolt.Hirschvogel2017SurrogateVolume","text":"Chamber volume estimator as presented in [23].\n\nCompute the chamber volume as a surface integral via the integral\n\nâˆ« (x + d) det(F) cof(F) N âˆ‚Î©endo\n\nwhere it is assumed that the chamber is convex, zero displacement in apicobasal direction at the valvular plane occurs and the plane normal is aligned with the z axis, where the origin is at z=0.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.RSAFDQ2022SurrogateVolume","page":"Models","title":"Thunderbolt.RSAFDQ2022SurrogateVolume","text":"Compute the chamber volume as a surface integral via the integral   -âˆ« det(F) ((h âŠ— h)(x + d - b)) adj(F) N âˆ‚Î©endo\n\nas proposed by Regazzoni et al. [3].\n\nnote: Note\nThis integral basically measures the volume via displacement on a given axis.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.RSAFDQ2022Split","page":"Models","title":"Thunderbolt.RSAFDQ2022Split","text":"Annotation for the split described by Regazzoni et al. [3].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.RSAFDQ2022Model","page":"Models","title":"Thunderbolt.RSAFDQ2022Model","text":"The split model described by Regazzoni et al. [3] alone.\n\n\n\n\n\n","category":"type"},{"location":"topics/couplers/#Couplers","page":"Couplers","title":"Couplers","text":"Many multiphysics problems can be described by having individual physics + coupling terms. Couplers act as the abstraction layer to describe these terms.\n\nMore detailed information coming soon...","category":"section"},{"location":"tutorials/ep03_bidomain/#ep-tutorial_defibrillation","page":"EP03: Defibrillation (TODO)","title":"Electrophysiology Tutorial 3: Defibrillation with Bidomain Models","text":"todo: Todo\nShow ECG and shock.\n\nThis tutorial shows how to setup Bidomain models and how to induce Spitzenumkehrtachykardie.\n\ntodo: Todo\nProvide context.","category":"section"},{"location":"tutorials/ep03_bidomain/#Commented-Program","page":"EP03: Defibrillation (TODO)","title":"Commented Program","text":"todo: Todo\nImplement bidomain model. Should be quite easy. We should also showcase subdomain managmeent and some ECG here.","category":"section"},{"location":"tutorials/ep03_bidomain/#References","page":"EP03: Defibrillation (TODO)","title":"References","text":"","category":"section"},{"location":"tutorials/ep03_bidomain/#ep-tutorial_bidomain-plain-program","page":"EP03: Defibrillation (TODO)","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: ep03_bidomain.jl.\n\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"howto/custom-ep-cell-model/#how-to-custom-ep-cell-model","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"using Thunderbolt\n\nWe first need to define a struct holding all the parameters. If you want to have parameters with spatial variation, which can be exchanged easily, then simply add a field with custom type and a function which accepts a coordinate x and a time t as input, as for example here for the parameter e:\n\ntip: Tip\nParametrize the cell model parameters with the used float type to easily change precision for GPU simulations, as some GPUs perform very bad with Float64.\n\nBase.@kwdef struct HeterogeneousFHNModel{T, T2} <: Thunderbolt.AbstractIonicModel\n    a::T = T(0.1)\n    b::T = T(0.5)\n    c::T = T(1.0)\n    d::T = T(0.0)\n    e::T2 = (x,t)->0.01\nend\nHeterogeneousFHNModel(::Type{T}, e::F) where {T,F} = HeterogeneousFHNModel{T,F}(0.1,0.5,1.0,0.0,e)\n\nWe now need to dispatch all functions of the cell EP API. First we need to give an index for the transmembrane potential, which we e.g. need for operator splitting methods and during post-processing.\n\nThunderbolt.transmembranepotential_index(cell_model::HeterogeneousFHNModel) = 1\n\nNow we need the number of state variables in the model. Here we have only a single internal state s.\n\nThunderbolt.num_states(::HeterogeneousFHNModel) = 1\n\nFor convenience, we should dispatch this function which contains some admissible initial state for the model in its default parametrization.\n\nThunderbolt.default_initial_state(::HeterogeneousFHNModel) = [0.0, 0.0]\n\nFinally we also need to provide the right hand side of the model. The API is similar to what we have in SciML, but we have one additional input x. x contains spatial information to distinguish individual cells, allowing spatial gradients of cellular behavior. If no spatial information is provded, then x === nothing. Usually the types for x are either Vec{sdim}, if the coordinate is carthesian, or some generalized coordinate. Please consult the coordinate system API docs for more details.\n\nnote: Note\nYou may have noticed that all inputs are parametrized. This seems to be necessary to force specialization for the GPU code â€“ removing the type parameters leads to cryptic CUDA.jl errors.\n\nfunction Thunderbolt.cell_rhs!(du::TD,u::TU,x::TX,t::TT,p::TP) where {TD,TU,TX,TT,TP <: HeterogeneousFHNModel}\n    # Flatten out parameters ...\n    (;a,b,c,d) = p\n    # ... and the state variables\n    Ï†â‚˜ = u[1]\n    s  = u[2]\n    # Now we assign the rates.\n    du[1] = Ï†â‚˜*(1-Ï†â‚˜)*(Ï†â‚˜-a) - s\n    du[2] = p.e(x,t)*(b*Ï†â‚˜ - c*s - d)\n    # Return nothing so no oopsies happen. :)\n    return nothing\nend\n\ntodo: Todo\nShow how users can control which the coordiante system information is passed into the cell model.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorials/cm03_3d0d-coupling/#mechanics-tutorial_3d0dcoupling","page":"CM03: 0D Blood Circuit","title":"Mechanics Tutorial 3: Coupling with Lumped Blood Circuits","text":"(Image: Pressure Volume Loop)\n\nThis tutorial shows how to couple 3d chamber models with 0d fluid models.","category":"section"},{"location":"tutorials/cm03_3d0d-coupling/#Introduction","page":"CM03: 0D Blood Circuit","title":"Introduction","text":"In this tutorial we will reproduce a simplified version of the model presented by Regazzoni et al. [3].\n\nwarning: Warning\nThe API for 3D-0D coupling is work in progress and is hence subject to potential breaking changes.","category":"section"},{"location":"tutorials/cm03_3d0d-coupling/#Commented-Program","page":"CM03: 0D Blood Circuit","title":"Commented Program","text":"We start by loading Thunderbolt and LinearSolve to use a custom direct solver of our choice.\n\nusing Thunderbolt, LinearSolve\n\nFinally, we try to approach a valid initial state by solving a simpler model first.\n\nusing OrdinaryDiffEqTsit5, OrdinaryDiffEqOperatorSplitting\n\nfluid_model_init = RSAFDQ2022LumpedCicuitModel()\nu0 = zeros(Thunderbolt.num_states(fluid_model_init))\nThunderbolt.default_initial_condition!(u0, fluid_model_init)\nprob = ODEProblem((du, u, p, t) -> Thunderbolt.lumped_driver!(du, u, t, [], p), u0, (0.0, 100*fluid_model_init.THB), fluid_model_init)\nsol = solve(prob, Tsit5())\n\nplot(sol, idxs=[1,2,3,4], tspan=(99fluidmodelinit.THB, 100fluidmodelinit.THB))\n\n# Precomputed initial guess\nuâ‚€fluid = sol.u[end]\n@info \"Total blood volume: $(sum(uâ‚€fluid[1:4])) + $(fluid_model_init.Csysâ‚áµ£*uâ‚€fluid[5]) + $(fluid_model_init.Csysáµ¥â‚‘â‚™*uâ‚€fluid[6]) + $(fluid_model_init.Cpulâ‚áµ£*uâ‚€fluid[7]) + $(fluid_model_init.Cpuláµ¥â‚‘â‚™*uâ‚€fluid[8])\"\n\nWe now generate the mechanical subproblem as in the first tutorial\n\nscaling_factor = 3.7;\nnothing #hide\n\nwarning: Warning\nTuning parameter until all bugs are fixed in this tutorial :)\n\nmesh = generate_ideal_lv_mesh(8,2,5;\n    inner_radius = scaling_factor*0.7,\n    outer_radius = scaling_factor*1.0,\n    longitudinal_upper = 0.4,\n    apex_inner = scaling_factor* 1.3,\n    apex_outer = scaling_factor*1.5\n)\nmesh = Thunderbolt.hexahedralize(mesh)\n\ntodo: Todo\nThe 3D0D coupling does not yet support multiple subdomains.\n\ncoordinate_system = compute_lv_coordinate_system(mesh)\nmicrostructure    = create_microstructure_model(\n    coordinate_system,\n    LagrangeCollection{1}()^3,\n    ODB25LTMicrostructureParameters(),\n);\npassive_material_model = Guccione1991PassiveModel()\nactive_material_model  = Guccione1993ActiveModel()\nfunction calcium_profile_function(x::LVCoordinate,t_global)\n    linear_interpolation(t,y1,y2,t1,t2) = y1 + (t-t1) * (y2-y1)/(t2-t1)\n    ca_peak(x)                          = 1.0\n    t = t_global % 800.0\n    if 0 â‰¤ t â‰¤ 120.0\n        return linear_interpolation(t,        0.0, ca_peak(x),   0.0, 120.0)\n    elseif t â‰¤ 272.0\n        return linear_interpolation(t, ca_peak(x),        0.0, 120.0, 272.0)\n    else\n        return 0.0\n    end\nend\ncalcium_field = AnalyticalCoefficient(\n    calcium_profile_function,\n    coordinate_system,\n)\nsarcomere_model = CaDrivenInternalSarcomereModel(ConstantStretchModel(), calcium_field)\nactive_stress_model = ActiveStressModel(\n    passive_material_model,\n    active_material_model,\n    sarcomere_model,\n    microstructure,\n)\nweak_boundary_conditions = (RobinBC(1.0, \"Epicardium\"),NormalSpringBC(100.0, \"Base\"))\nsolid_model = QuasiStaticModel(:displacement, active_stress_model, weak_boundary_conditions);\nnothing #hide\n\nThe solid model is now couple with the circuit model by adding a Lagrange multipliers constraining the 3D chamber volume to match the chamber volume in the 0D model.\n\nfluid_model = RSAFDQ2022LumpedCicuitModel(; lv_pressure_given = false)\ncoupler = LumpedFluidSolidCoupler(\n    [\n        ChamberVolumeCoupling(\n            \"Endocardium\",\n            RSAFDQ2022SurrogateVolume(),\n            :Vâ‚—áµ¥,\n            :pâ‚—áµ¥,\n        )\n    ],\n    :displacement,\n)\ncoupled_model = RSAFDQ2022Model(solid_model, fluid_model, coupler);\nnothing #hide\n\ntodo: Todo\nOnce we figure out a nicer way to do this we should add more detailed docs here.\n\nNow we semidiscretize the model spatially as usual with finite elements and annotate the model with a stable split.\n\nspatial_discretization_method = FiniteElementDiscretization(\n    Dict(:displacement => LagrangeCollection{1}()^3),\n    [\n        Dirichlet(:displacement, getfacetset(mesh, \"Base\"), (x,t) -> [0.0], [3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor1\"), (x,t) -> (0.0, 0.0, 0.0), [1,2,3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor2\"), (x,t) -> (0.0, 0.0), [2,3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor3\"), (x,t) -> (0.0,), [3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor4\"), (x,t) -> (0.0,), [3])\n    ],\n)\nsplitform = semidiscretize(\n    RSAFDQ2022Split(coupled_model),\n    spatial_discretization_method,\n    mesh,\n)\n\ndtâ‚€ = 1.0\ndtvis = 10.0\ntspan = (0.0, 3*800.0)\n\nThis speeds up the CI # hide\n\ntspan = (0.0, 10.0)    # hide\n\nThe remaining code is very similar to how we use SciML solvers.\n\nchamber_solver = HomotopyPathSolver(\n    NewtonRaphsonSolver(;\n        max_iter=10,\n        tol=1e-2,\n        inner_solver=SchurComplementLinearSolver(\n            LinearSolve.UMFPACKFactorization()\n        )\n    )\n)\nblood_circuit_solver = Tsit5()\ntimestepper = LieTrotterGodunov((chamber_solver, blood_circuit_solver))\n\nuâ‚€ = zeros(solution_size(splitform))\nuâ‚€solid_view = @view  uâ‚€[OS.get_solution_indices(splitform, 1)]\nuâ‚€fluid_view = @view  uâ‚€[OS.get_solution_indices(splitform, 2)]\nuâ‚€fluid_view .= uâ‚€fluid\n\nproblem = OperatorSplittingProblem(splitform, uâ‚€, tspan)\nintegrator = init(problem, timestepper, dt=dtâ‚€, verbose=true; dtmax=10.0);\n\n# f2 = Figure()\n# axs = [\n#     Axis(f2[1, 1], title=\"LV\"),\n#     Axis(f2[1, 2], title=\"RV\"),\n#     Axis(f2[2, 1], title=\"LA\"),\n#     Axis(f2[2, 2], title=\"RA\")\n# ]\n\n# vlv = Observable(Float64[])\n# plv = Observable(Float64[])\n\n# vrv = Observable(Float64[])\n# prv = Observable(Float64[])\n\n# vla = Observable(Float64[])\n# pla = Observable(Float64[])\n\n# vra = Observable(Float64[])\n# pra = Observable(Float64[])\n\n# lines!(axs[1], vlv, plv)\n# lines!(axs[2], vrv, prv)\n# lines!(axs[3], vla, pla)\n# lines!(axs[4], vra, pra)\n# for i in 1:4\n#     xlims!(axs[1], 0.0, 180.0)\n#     ylims!(axs[1], 0.0, 180.0)\n# end\n# display(f2)\n\ntodo: Todo\nrecover online visualization of the pressure volume loop\n\ntodo: Todo\nThe post-processing API is not yet finished. Please revisit the tutorial later to see how to post-process the simulation online. Right now the solution is just exported into VTK, such that users can visualize the solution in e.g. ParaView.\n\nNow we can finally solve the coupled problem in time.\n\nio = ParaViewWriter(\"CM03_3d0d-coupling\");\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    chamber_function = OS.get_operator(splitform, 1)\n    (; dh) = chamber_function.structural_function\n    store_timestep!(io, t, dh.grid)\n    usolid_view = @view u[OS.get_solution_indices(splitform, 1)]\n    Thunderbolt.store_timestep_field!(io, t, dh, usolid_view, :displacement)\n    Thunderbolt.finalize_timestep!(io, t)\n\n    # if t > 0.0\n    #     lv = chamber_function.tying_info.chambers[1]\n    #     append!(vlv.val, lv.Vâ°á´°val)\n    #     append!(plv.val, u[lv.pressure_dof_index_global])\n    #     notify(vlv)\n    #     notify(plv)\n    # end\n    # TODO plot other chambers\nend\n\ntip: Tip\nIf you want to see more details of the solution process launch Julia with Thunderbolt as debug module:JULIA_DEBUG=Thunderbolt julia --project --threads=auto my_simulation_runner.jl","category":"section"},{"location":"tutorials/cm03_3d0d-coupling/#References","page":"CM03: 0D Blood Circuit","title":"References","text":"F.Â Regazzoni, M.Â Salvador, P.Â C.Â Africa, M.Â Fedele, L.Â DedÃ¨ and A.Â Quarteroni. A cardiac electromechanical model coupled with a lumped-parameter model for closed-loop blood circulation. JournalÂ ofÂ ComputationalÂ Physics 457, 111083 (2022).\n\n\n\n","category":"section"},{"location":"tutorials/cm03_3d0d-coupling/#mechanics-tutorial_3d0dcoupling-plain-program","page":"CM03: 0D Blood Circuit","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: cm03_3d0d-coupling.jl.\n\nusing Thunderbolt, LinearSolve\n\nusing OrdinaryDiffEqTsit5, OrdinaryDiffEqOperatorSplitting\n\nfluid_model_init = RSAFDQ2022LumpedCicuitModel()\nu0 = zeros(Thunderbolt.num_states(fluid_model_init))\nThunderbolt.default_initial_condition!(u0, fluid_model_init)\nprob = ODEProblem((du, u, p, t) -> Thunderbolt.lumped_driver!(du, u, t, [], p), u0, (0.0, 100*fluid_model_init.THB), fluid_model_init)\nsol = solve(prob, Tsit5())\n\n# Precomputed initial guess\nuâ‚€fluid = sol.u[end]\n@info \"Total blood volume: $(sum(uâ‚€fluid[1:4])) + $(fluid_model_init.Csysâ‚áµ£*uâ‚€fluid[5]) + $(fluid_model_init.Csysáµ¥â‚‘â‚™*uâ‚€fluid[6]) + $(fluid_model_init.Cpulâ‚áµ£*uâ‚€fluid[7]) + $(fluid_model_init.Cpuláµ¥â‚‘â‚™*uâ‚€fluid[8])\"\n\nscaling_factor = 3.7;\n\nmesh = generate_ideal_lv_mesh(8,2,5;\n    inner_radius = scaling_factor*0.7,\n    outer_radius = scaling_factor*1.0,\n    longitudinal_upper = 0.4,\n    apex_inner = scaling_factor* 1.3,\n    apex_outer = scaling_factor*1.5\n)\nmesh = Thunderbolt.hexahedralize(mesh)\n\ncoordinate_system = compute_lv_coordinate_system(mesh)\nmicrostructure    = create_microstructure_model(\n    coordinate_system,\n    LagrangeCollection{1}()^3,\n    ODB25LTMicrostructureParameters(),\n);\npassive_material_model = Guccione1991PassiveModel()\nactive_material_model  = Guccione1993ActiveModel()\nfunction calcium_profile_function(x::LVCoordinate,t_global)\n    linear_interpolation(t,y1,y2,t1,t2) = y1 + (t-t1) * (y2-y1)/(t2-t1)\n    ca_peak(x)                          = 1.0\n    t = t_global % 800.0\n    if 0 â‰¤ t â‰¤ 120.0\n        return linear_interpolation(t,        0.0, ca_peak(x),   0.0, 120.0)\n    elseif t â‰¤ 272.0\n        return linear_interpolation(t, ca_peak(x),        0.0, 120.0, 272.0)\n    else\n        return 0.0\n    end\nend\ncalcium_field = AnalyticalCoefficient(\n    calcium_profile_function,\n    coordinate_system,\n)\nsarcomere_model = CaDrivenInternalSarcomereModel(ConstantStretchModel(), calcium_field)\nactive_stress_model = ActiveStressModel(\n    passive_material_model,\n    active_material_model,\n    sarcomere_model,\n    microstructure,\n)\nweak_boundary_conditions = (RobinBC(1.0, \"Epicardium\"),NormalSpringBC(100.0, \"Base\"))\nsolid_model = QuasiStaticModel(:displacement, active_stress_model, weak_boundary_conditions);\n\nfluid_model = RSAFDQ2022LumpedCicuitModel(; lv_pressure_given = false)\ncoupler = LumpedFluidSolidCoupler(\n    [\n        ChamberVolumeCoupling(\n            \"Endocardium\",\n            RSAFDQ2022SurrogateVolume(),\n            :Vâ‚—áµ¥,\n            :pâ‚—áµ¥,\n        )\n    ],\n    :displacement,\n)\ncoupled_model = RSAFDQ2022Model(solid_model, fluid_model, coupler);\n\nspatial_discretization_method = FiniteElementDiscretization(\n    Dict(:displacement => LagrangeCollection{1}()^3),\n    [\n        Dirichlet(:displacement, getfacetset(mesh, \"Base\"), (x,t) -> [0.0], [3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor1\"), (x,t) -> (0.0, 0.0, 0.0), [1,2,3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor2\"), (x,t) -> (0.0, 0.0), [2,3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor3\"), (x,t) -> (0.0,), [3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor4\"), (x,t) -> (0.0,), [3])\n    ],\n)\nsplitform = semidiscretize(\n    RSAFDQ2022Split(coupled_model),\n    spatial_discretization_method,\n    mesh,\n)\n\ndtâ‚€ = 1.0\ndtvis = 10.0\ntspan = (0.0, 3*800.0)\n\ntspan = (0.0, 10.0)    # hide\n\nchamber_solver = HomotopyPathSolver(\n    NewtonRaphsonSolver(;\n        max_iter=10,\n        tol=1e-2,\n        inner_solver=SchurComplementLinearSolver(\n            LinearSolve.UMFPACKFactorization()\n        )\n    )\n)\nblood_circuit_solver = Tsit5()\ntimestepper = LieTrotterGodunov((chamber_solver, blood_circuit_solver))\n\nuâ‚€ = zeros(solution_size(splitform))\nuâ‚€solid_view = @view  uâ‚€[OS.get_solution_indices(splitform, 1)]\nuâ‚€fluid_view = @view  uâ‚€[OS.get_solution_indices(splitform, 2)]\nuâ‚€fluid_view .= uâ‚€fluid\n\nproblem = OperatorSplittingProblem(splitform, uâ‚€, tspan)\nintegrator = init(problem, timestepper, dt=dtâ‚€, verbose=true; dtmax=10.0);\n\n# f2 = Figure()\n# axs = [\n#     Axis(f2[1, 1], title=\"LV\"),\n#     Axis(f2[1, 2], title=\"RV\"),\n#     Axis(f2[2, 1], title=\"LA\"),\n#     Axis(f2[2, 2], title=\"RA\")\n# ]\n\n# vlv = Observable(Float64[])\n# plv = Observable(Float64[])\n\n# vrv = Observable(Float64[])\n# prv = Observable(Float64[])\n\n# vla = Observable(Float64[])\n# pla = Observable(Float64[])\n\n# vra = Observable(Float64[])\n# pra = Observable(Float64[])\n\n# lines!(axs[1], vlv, plv)\n# lines!(axs[2], vrv, prv)\n# lines!(axs[3], vla, pla)\n# lines!(axs[4], vra, pra)\n# for i in 1:4\n#     xlims!(axs[1], 0.0, 180.0)\n#     ylims!(axs[1], 0.0, 180.0)\n# end\n# display(f2)\n\nio = ParaViewWriter(\"CM03_3d0d-coupling\");\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    chamber_function = OS.get_operator(splitform, 1)\n    (; dh) = chamber_function.structural_function\n    store_timestep!(io, t, dh.grid)\n    usolid_view = @view u[OS.get_solution_indices(splitform, 1)]\n    Thunderbolt.store_timestep_field!(io, t, dh, usolid_view, :displacement)\n    Thunderbolt.finalize_timestep!(io, t)\n\n    # if t > 0.0\n    #     lv = chamber_function.tying_info.chambers[1]\n    #     append!(vlv.val, lv.Vâ°á´°val)\n    #     append!(plv.val, u[lv.pressure_dof_index_global])\n    #     notify(vlv)\n    #     notify(plv)\n    # end\n    # TODO plot other chambers\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorials/#Tutorials","page":"Overview","title":"Tutorials","text":"On this page you find an overview of Thunderbolt tutorials. The tutorials explain and show the indended usage of Thunderbolt to simulate cardiac problems. Tutorials are sorted by their physical domain and written in a way that users can start with reading the tutorials (in order) of the physics they are interested in, without necessarily going through the tutorials for the other phyiscal domains.\n\nThe tutorials all follow roughly the same structure:\n\nIntroduction introduces the problem to be solved and discusses the learning outcomes of the tutorial.\nCommented program is the code for solving the problem with explanations and comments.\nPlain program is the raw source code of the program.\n\nWhen studying the tutorials it is a good idea to obtain a local copy of the code and run it on your own machine as you read along. Some of the tutorials also include suggestions for tweaks to the program that you can try out on your own.\n\ndanger: Danger\nThe tutorials are work in progress and not all necessary features are implemented yet.\n\ntip: Tip\nParallel assembly and solvers are automatically enabled when you start julia with multiple threads, e.g. viajulia --project --threads=auto","category":"section"},{"location":"tutorials/#Cardiac-Mechanics","page":"Overview","title":"Cardiac Mechanics","text":"This section explains how cardiac solid mechanics simulations can be carried out, how these simulations can be coupled with blood circuit models and how to add mechanical custom models.\n\n","category":"section"},{"location":"tutorials/#[Mechanics-Tutorial-01:-Simple-Active-Stress](@ref-mechanics-tutorial_simple-active-stress)","page":"Overview","title":"Mechanics Tutorial 01: Simple Active Stress","text":"In this tutorial you will learn how to:\n\nsetup a basic contraction simulation\nuse the homotpy path solver (,,Load Stepping'') and choose a custom inner solver\nextract quantities to post-process solutions online and offline\n\n","category":"section"},{"location":"tutorials/#[Mechanics-Tutorial-02:-Prestress](@ref-mechanics-tutorial_prestress)-(TODO)","page":"Overview","title":"Mechanics Tutorial 02: Prestress (TODO)","text":"In this tutorial you will learn how to:\n\nadd residual strains to a model\nadd preload to a model\nfind the new reference configuration\n\n","category":"section"},{"location":"tutorials/#[Mechanics-Tutorial-03:-Coupling-A-Ciculatory-System-Model](@ref-mechanics-tutorial_3d0dcoupling)","page":"Overview","title":"Mechanics Tutorial 03: Coupling A Ciculatory System Model","text":"In this tutorial you will learn how to:\n\ndefine a blood circuit model\ncouple the blood circuit model with a single heart chamber\nvisualize pressure-volume loops and the blood circuit solution along the\n\n","category":"section"},{"location":"tutorials/#[Mechanics-Tutorial-04:-Pericardial-Boundary-Condtions](@ref-mechanics-tutorial_pericardium)-(TODO)","page":"Overview","title":"Mechanics Tutorial 04: Pericardial Boundary Condtions (TODO)","text":"In this tutorial you will learn how to:\n\ngenerate a pericardium\nadd pericardial boundary condtions to a model\n\n","category":"section"},{"location":"tutorials/#[Mechanics-Tutorial-05:-Four-Chamber-Models](@ref-mechanics-tutorial_fourchamber)-(TODO)","page":"Overview","title":"Mechanics Tutorial 05: Four Chamber Models (TODO)","text":"In this tutorial you will learn how to:\n\nhandle and couple multiple subdomains\ncouple the blood circuit model with a multiple heart chambers\n\n","category":"section"},{"location":"tutorials/#[Mechanics-Tutorial-06:-Heart-Valves](@ref-mechanics-tutorial_heartvalves)-(TODO)","page":"Overview","title":"Mechanics Tutorial 06: Heart Valves (TODO)","text":"In this tutorial you will learn how to:\n\nhandle 1D and 2D elements in 3D\nadd a 3D fluid model to the heart\ncouple a 3D fluid model an external blood circuit model\n\n","category":"section"},{"location":"tutorials/#Cardiac-Electrophysiology","page":"Overview","title":"Cardiac Electrophysiology","text":"This section explains how cardiac electrophysiology simulations can be carried out, how these simulations can be coupled with Purkinje network models, how to extract the ECG and how to add mechanical electrophysiology models.\n\n","category":"section"},{"location":"tutorials/#[EP-Tutorial-01:-Spiral-Waves-with-a-Monodomain-Model](@ref-ep-tutorial_spiral-wave)","page":"Overview","title":"EP Tutorial 01: Spiral Waves with a Monodomain Model","text":"In this tutorial you will learn how to:\n\nsetup a basic electrophysiology simulations\nset initial conditions\ndefine a custom stimulation protocols\nrun an electrophysiology simulation on a GPU\n\n","category":"section"},{"location":"tutorials/#[EP-Tutorial-02:-Activating-a-Left-Ventricle-via-Purkinje-Network](@ref-ep-tutorial_purkinje)-(TODO)","page":"Overview","title":"EP Tutorial 02: Activating a Left Ventricle via Purkinje Network (TODO)","text":"In this tutorial you will learn how to:\n\ngenerate a Purkinje Network\ncouple the chamber tissue with the network\n\n","category":"section"},{"location":"tutorials/#[EP-Tutorial-03:-ECG-with-a-Bidomain-Model](@ref-ep-tutorial_purkinje)-(TODO)","page":"Overview","title":"EP Tutorial 03: ECG with a Bidomain Model (TODO)","text":"In this tutorial you will learn how to:\n\nhandle multiple subdomains with different physics\nhandle coefficients when facing multiple subdomains\nadd ground boundary conditons\ninduce Torsade de pointes\nadd defibrillation boundary conditions\n\n","category":"section"},{"location":"tutorials/#[EP-Tutorial-04:-ECG-with-a-Monodomain-Model](@ref-ep-tutorial_geselowitz-ecg)","page":"Overview","title":"EP Tutorial 04: ECG with a Monodomain Model","text":"In this tutorial you will learn how to:\n\ntransfer coefficients and solutions between overlapping domains\ncompute the ECG form a monodomain model as a postprocessing step\n\n","category":"section"},{"location":"tutorials/#[EP-Tutorial-05:-Reaction-Eikonal-ECG](@ref-ep-tutorial_eikonal)-(TODO)","page":"Overview","title":"EP Tutorial 05: Reaction-Eikonal ECG (TODO)","text":"In this tutorial you will learn how to:\n\nperform ECG simulations with a simplified activation dynamics model\n\n","category":"section"},{"location":"tutorials/#[EP-Tutorial-06:-Including-Pacemakers](@ref-ep-tutorial_pacemaker)-(TODO)","page":"Overview","title":"EP Tutorial 06: Including Pacemakers (TODO)","text":"In this tutorial you will learn how to:\n\nHandling Heterogeneous Tissues","category":"section"},{"location":"api-reference/mesh/#Mesh","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"api-reference/mesh/#coordinate-system-api","page":"Mesh","title":"Coordinate Systems","text":"","category":"section"},{"location":"api-reference/mesh/#mesh-generator-api","page":"Mesh","title":"Mesh Generators","text":"","category":"section"},{"location":"api-reference/mesh/#mesh-utility-api","page":"Mesh","title":"Utility","text":"","category":"section"},{"location":"api-reference/mesh/#Thunderbolt.SimpleMesh","page":"Mesh","title":"Thunderbolt.SimpleMesh","text":"SimpleMesh{sdim, C <: AbstractCell, T <: Real} <: AbstractGrid{sdim}\n\nA grid which also has information abouts its vertices, facets and edges.\n\nIt is also a glorified domain manager for mixed grids and actual subdomains. TODO investigate whetehr we can remove the subdomains without a significant performance hit.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#Thunderbolt.CartesianCoordinateSystem","page":"Mesh","title":"Thunderbolt.CartesianCoordinateSystem","text":"CartesianCoordinateSystem(mesh)\n\nStandard cartesian coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#Thunderbolt.LVCoordinateSystem","page":"Mesh","title":"Thunderbolt.LVCoordinateSystem","text":"LVCoordinateSystem(dh, u_transmural, u_apicobasal)\n\nSimplified universal ventricular coordinate on LV only, containing the transmural, apicobasal and rotational coordinates. See compute_lv_coordinate_system to construct it.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#Thunderbolt.LVCoordinate","page":"Mesh","title":"Thunderbolt.LVCoordinate","text":"LVCoordinate{T}\n\nLV only part of the universal ventricular coordinate, containing     * transmural     * apicobasal     * rotational\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#Thunderbolt.BiVCoordinateSystem","page":"Mesh","title":"Thunderbolt.BiVCoordinateSystem","text":"BiVCoordinateSystem(dh, u_transmural, u_apicobasal, u_rotational, u_transventricular)\n\nUniversal ventricular coordinate, containing the transmural, apicobasal, rotational  and transventricular coordinates.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#Thunderbolt.BiVCoordinate","page":"Mesh","title":"Thunderbolt.BiVCoordinate","text":"BiVCoordinate{T}\n\nBiventricular universal coordinate, containing     * transmural     * apicobasal     * rotational     * transventricular\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#Thunderbolt.generate_ring_mesh","page":"Mesh","title":"Thunderbolt.generate_ring_mesh","text":"generate_ring_mesh(num_elements_circumferential::Int, num_elements_radial::Int, num_elements_logintudinal::Int; inner_radius::T = Float64(0.75), outer_radius::T = Float64(1.0), longitudinal_lower::T = Float64(-0.2), longitudinal_upper::T = Float64(0.2), apicobasal_tilt::T=Float64(0.0)) where {T}\n\nGenerates an idealized full-hexahedral ring with linear ansatz. Geometrically it is the substraction of a small cylinder C_i of a large cylinder C_o. The number of elements for the cylindrical system can be controlled by the first three input parameters. The remaining parameters control the spatial dimensions and the ring shape.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/mesh/#Thunderbolt.generate_open_ring_mesh","page":"Mesh","title":"Thunderbolt.generate_open_ring_mesh","text":"generate_open_ring_mesh(num_elements_circumferential::Int, num_elements_radial::Int, num_elements_logintudinal::Int, opening_angle::Float64; inner_radius::T = Float64(0.75), outer_radius::T = Float64(1.0), longitudinal_lower::T = Float64(-0.2), longitudinal_upper::T = Float64(0.2), apicobasal_tilt::T=Float64(0.0)) where {T}\n\nGenerates an idealized full-hexahedral ring with given opening angle and linear ansatz. Geometrically it is the substraction of a small cylinder C_i of a large cylinder C_o. The number of elements for the cylindrical system can be controlled by the first three input parameters. The remaining parameters control the spatial dimensions and the ring shape. The ring is opened along the Cartesian x-z plane.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/mesh/#Thunderbolt.generate_quadratic_ring_mesh","page":"Mesh","title":"Thunderbolt.generate_quadratic_ring_mesh","text":"generate_quadratic_ring_mesh(num_elements_circumferential::Int, num_elements_radial::Int, num_elements_logintudinal::Int; inner_radius::T = Float64(0.75), outer_radius::T = Float64(1.0), longitudinal_lower::T = Float64(-0.2), longitudinal_upper::T = Float64(0.2), apicobasal_tilt::T=Float64(0.0)) where {T}\n\nGenerates an idealized full-hexahedral ring with quadratic ansatz. Geometrically it is the substraction of a small cylinder C_i of a large cylinder C_o. The number of elements for the cylindrical system can be controlled by the first three input parameters. The remaining parameters control the spatial dimensions and the ring shape.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/mesh/#Thunderbolt.generate_quadratic_open_ring_mesh","page":"Mesh","title":"Thunderbolt.generate_quadratic_open_ring_mesh","text":"generate_quadratic_open_ring_mesh(num_elements_circumferential::Int, num_elements_radial::Int, num_elements_logintudinal::Int, opening_angle::Float64; inner_radius::T = Float64(0.75), outer_radius::T = Float64(1.0), longitudinal_lower::T = Float64(-0.2), longitudinal_upper::T = Float64(0.2), apicobasal_tilt::T=Float64(0.0)) where {T}\n\nGenerates an idealized full-hexahedral ring with given opening angle and quadratic ansatz. Geometrically it is the substraction of a small cylinder C_i of a large cylinder C_o. The number of elements for the cylindrical system can be controlled by the first three input parameters. The remaining parameters control the spatial dimensions and the ring shape. The ring is opened along the Cartesian x-z plane.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/mesh/#Thunderbolt.generate_ideal_lv_mesh","page":"Mesh","title":"Thunderbolt.generate_ideal_lv_mesh","text":"generate_ideal_lv_mesh(num_elements_circumferential::Int, num_elements_radial::Int, num_elements_logintudinally::Int; inner_radius::T = Float64(0.7), outer_radius::T = Float64(1.0), longitudinal_upper::T = Float64(0.2), apex_inner::T = Float64(1.3), apex_outer::T = Float64(1.5))\n\nGenerate an idealized left ventricle as a truncated ellipsoid. The number of elements per axis are controlled by the first three parameters.\n\n\n\n\n\n","category":"function"},{"location":"topics/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"topics/operators/#TLDR","page":"Operators","title":"TLDR","text":"In Thunderbolt ,,operators'' connect (spatial) finite element discretizations and time integration algorithms.","category":"section"},{"location":"topics/operators/#More","page":"Operators","title":"More","text":"Operators act as the translation layer between discretized problems and solvers by abstracting \"functions of functions\".\n\nMany multiphysics problems can be efficiently described as blocked problems, which gives rise to the concept of blocked operators by partitioning the input of the function into multiple ones.\n\nMore detailed information coming soon...","category":"section"},{"location":"tutorials/ep01_spiral-wave/#ep-tutorial_spiral-wave","page":"EP01: Spiral Wave","title":"Electrophysiology Tutorial 1: Simple Spiral Wave","text":"(Image: Spiral Wave)\n\nThis tutorial shows how to perform a simulation of electrophysiological behavior of cardiac tissue.","category":"section"},{"location":"tutorials/ep01_spiral-wave/#Introduction","page":"EP01: Spiral Wave","title":"Introduction","text":"The most widespread model of cardiac electrophysiology is the monodomain model. It can be defined on a domain Omega as the system of partial differential equations\n\nbeginaligned\n  chi C_textrmm partial_t varphi = nabla cdot boldsymbolkappa nabla varphi - chi I(varphi boldsymbols t)  textrmin  Omega   \n  partial_t boldsymbols = mathbfg(varphi boldsymbols)  textrmin   Omega   \n  0 = boldsymbolkappa nabla varphi cdot mathbfn  mathrmon  partial Omega  \nendaligned\n\ntogether with admissible initial conditions and a cellular ionic model to determine I and mathbfg. boldsymbolkappa denotes the conductivity tensor, varphi is the transmembrane potential field, chi is the volume to membrane surface ratio, C_mathrmm is the membrane capacitance, and I(varphi boldsymbols t) = I_textrmion(varphi boldsymbols) + I_textrmstim(t) denotes the sum of the ionic current due to the cell model and the applied stimulus current, respectively.\n\nIn this tutorial we will apply a reaction-diffusion split to this model and solve it with an operator splitting solver. For some theory on operator splitting we refer to the theory manual on operator splitting.","category":"section"},{"location":"tutorials/ep01_spiral-wave/#Commented-Program","page":"EP01: Spiral Wave","title":"Commented Program","text":"We start by loading Thunderbolt, OrdinaryDiffEqOperatorSplitting and LinearSolve to use a custom direct solver of our choice.\n\nusing Thunderbolt, LinearSolve, OrdinaryDiffEqOperatorSplitting\n\nWe start by constructing a square domain for our simulation.\n\nmesh = generate_mesh(Quadrilateral, (2^6, 2^6), Vec{2}((0.0,0.0)), Vec{2}((2.5,2.5)));\nnothing #hide\n\nHere the first parameter is the element type and the second parameter is a tuple holding the number of subdivisions per dimension. The last two parameters are the corners defining the rectangular domain.\n\ntip: Tip\nWe can also load realistic geometries with external formats. For this simply use either FerriteGmsh.jl or one of the loader functions stated in the mesh API.\n\nWe now define the parameters appearing in the model. For simplciity we assume C_mathrmm = chi = 10 and a homogeneous, anisotropic symmetric conductivity tensor.\n\nCâ‚˜ = ConstantCoefficient(1.0)\nÏ‡  = ConstantCoefficient(1.0)\nÎº  = ConstantCoefficient(SymmetricTensor{2,2,Float64}((4.5e-5, 0, 2.0e-5)));\nnothing #hide\n\ntip: Tip\nIf the mesh is properly annotated, then we can generate (or even load) a cardiac coordinate system. Consult coordinate system API documentation for details. With this information we can construct idealized microstructures to define heterogeneous conductivity tensors e.g. asmicrostructure = create_simple_microstructure_model(\n  coordinate_system,\n  LagrangeCollection{1}()^3;\n  endo_helix_angle = deg2rad(60.0),\n  epi_helix_angle = deg2rad(-60.0),\n)\nÎº = SpectralTensorCoefficient(\n    microstructure,\n    ConstantCoefficient(SVector(Îºâ‚, Îºâ‚‚, Îºâ‚ƒ))\n)where Îºâ‚, Îºâ‚‚, Îºâ‚ƒ are the eigenvalues for the fiber, sheet and normal direction.\n\nThe spiral wave will unfold due to the specific construction of the initial conditions, hence we do not need to apply a stimulus.\n\nstimulation_protocol = NoStimulationProtocol();\nnothing #hide\n\nNow we choose a cell model. For simplicity we choose a neuronal electrophysiology model, which is a nice playground.\n\ncell_model = Thunderbolt.FHNModel();\nnothing #hide\n\ntip: Tip\nA full list of all models can be found in the API reference. To implement a custom cell model please consult the how-to section.\n\ntodo: Todo\nThe initializer API is not yet finished and hence we deconstruct stuff here manually. Please note that this method is quite fragile w.r.t. to many changes you can make in the code below.\n\nSpiral wave initializer for the FitzHugh-Nagumo\n\nfunction spiral_wave_initializer!(uâ‚€, f::GenericSplitFunction)\n    # TODO cleaner implementation. We need to extract this from the types or via dispatch.\n    heatfun = f.functions[1]\n    heat_dofrange = f.solution_indices[1]\n    odefun = f.functions[2]\n    ionic_model = odefun.ode\n\n    Ï†â‚€ = @view uâ‚€[heat_dofrange];\n    # TODO extraction these via utility functions\n    dh = heatfun.dh\n    sâ‚€flat = @view uâ‚€[(ndofs(dh)+1):end];\n    # Should not be reshape but some array of arrays fun, because in general (e.g. for heterogeneous tissues) we cannot reshape into a matrix\n    sâ‚€ = reshape(sâ‚€flat, (ndofs(dh), Thunderbolt.num_states(ionic_model)-1));\n\n    for cell in CellIterator(dh)\n        _celldofs = celldofs(cell)\n        Ï†â‚˜_celldofs = _celldofs[dof_range(dh, :Ï†â‚˜)]\n        # TODO query coordinate directly from the cell model\n        coordinates = getcoordinates(cell)\n        for (i, (xâ‚, xâ‚‚)) in zip(Ï†â‚˜_celldofs,coordinates)\n            if xâ‚ <= 1.25 && xâ‚‚ <= 1.25\n                Ï†â‚€[i] = 1.0\n            end\n            if xâ‚‚ >= 1.25\n                sâ‚€[i,1] = 0.1\n            end\n        end\n    end\nend;\nnothing #hide\n\nNow we put the components together by instantiating the monodomain model.\n\nep_model = MonodomainModel(\n    Câ‚˜,\n    Ï‡,\n    Îº,\n    stimulation_protocol,\n    cell_model,\n    :Ï†â‚˜, :s,\n);\nnothing #hide\n\nWe now annotate the model to be reaction-diffusion split. Special solvers need special forms for the model. However, the same solver can work with different forms. In the case of operator splitting users might choose to split the equations differently. Hence we leave it as a user option which split they prefer, or if they even want work on the full problem.\n\nsplit_ep_model = ReactionDiffusionSplit(ep_model);\nnothing #hide\n\ntodo: Todo\nShow how to use solvers different that LTG (and implement them).\n\nWe now need to transform the space-time problem into a time-dependent problem by discretizing it spatially. This can be accomplished by the function semidiscretize, which takes a model and the disretization technique. Here we use a finite element discretization in space with first order Lagrange polynomials to discretize the displacement field.\n\ndanger: Danger\nThe discretization API does now play well with multiple domains right now and will be updated with a possible breaking change in future releases.\n\nspatial_discretization_method = FiniteElementDiscretization(\n    Dict(:Ï†â‚˜ => LagrangeCollection{1}()),\n)\nodeform = semidiscretize(split_ep_model, spatial_discretization_method, mesh);\nnothing #hide\n\nWe now allocate a solution vector and set the initial condition.\n\nuâ‚€ = zeros(Float32, solution_size(odeform))\nspiral_wave_initializer!(uâ‚€, odeform);\nnothing #hide\n\nWe proceed by defining the time integration algorithms for each subproblem. First, there is the heat problem, which we will solve with a low-storage backward Euler method\n\nheat_timestepper = BackwardEulerSolver(\n    inner_solver=KrylovJL_CG(atol=1e-6, rtol=1e-5),\n);\nnothing #hide\n\ntip: Tip\nOn non-trivial geometries it is highly recommended to use a preconditioner. Please consult the LinearSolve.jl docs for details.\n\nAnd then there is the reaction subproblem, which decouples locally into \"number of dofs in the discrete heat problem\" separate ODE. We will solve these locally adaptive with forward Euler steps.\n\ncell_timestepper = AdaptiveForwardEulerSubstepper(;\n    reaction_threshold=0.1,\n);\nnothing #hide\n\nNow we can just instantiate the operator splitting algorithm of our choice. Since our time integrators are both first order in time we opt for the standard first order accurrate operator splitting technique by Lie-Trotter (or Godunov).\n\ntimestepper = LieTrotterGodunov((heat_timestepper, cell_timestepper));\nnothing #hide\n\nThe remaining code is very similar to how we use SciML solvers. We first define our time domain, initial time step length and some dt for visualization.\n\ndtâ‚€   = 1.0\ndtvis = 25.0\ntspan = (0.0, 1000.0);\nnothing #hide\n\nThis speeds up the CI # hide\n\ntspan = (0.0, dtvis);   # hide\nnothing #hide\n\nThen we setup the problem. We have a split function, so the correct problem is an OperatorSplittingProblem.\n\nproblem = OperatorSplittingProblem(odeform, uâ‚€, tspan);\nnothing #hide\n\ntip: Tip\nIf we want to solve the problem on the GPU, or if we want to use special matrix and vector formats, we just need to adjust the vector and matrix types. For example, if we want to problem to be solved on a CUDA GPU with 32 bit precision, then we need to adjust the types as follows.uâ‚€gpu = CuVector(uâ‚€)\nheat_timestepper = BackwardEulerSolver(\n  solution_vector_type=CuVector{Float32},\n  system_matrix_type=CUDA.CUSPARSE.CuSparseMatrixCSR{Float32, Int32},\n  inner_solver=KrylovJL_CG(atol=1.0f-6, rtol=1.0f-5),\n)\ncell_timestepper = AdaptiveForwardEulerSubstepper(\n    solution_vector_type=CuVector{Float32},\n    reaction_threshold=0.1f0,\n)\n...\nproblem = OperatorSplittingProblem(odeform, uâ‚€gpu, tspan)\n\nNow we initialize our time integrator as usual.\n\nintegrator = init(problem, timestepper, dt=dtâ‚€);\nnothing #hide\n\ntodo: Todo\nThe post-processing API is not yet finished. Please revisit the tutorial later to see how to post-process the simulation online. Right now the solution is just exported into VTK, such that users can visualize the solution in e.g. ParaView.\n\nAnd finally we solve the problem in time.\n\nio = ParaViewWriter(\"EP01_spiral_wave\")\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    (; dh) = odeform.functions[1]\n    Ï† = u[odeform.solution_indices[1]]\n    store_timestep!(io, t, dh.grid) do file\n        Thunderbolt.store_timestep_field!(file, t, dh, Ï†, :Ï†â‚˜)\n    end\nend;\nnothing #hide\n\ntip: Tip\nIf you want to see more details of the solution process launch Julia with Thunderbolt as debug module:JULIA_DEBUG=Thunderbolt julia --project --threads=auto my_simulation_runner.jl","category":"section"},{"location":"tutorials/ep01_spiral-wave/#References","page":"EP01: Spiral Wave","title":"References","text":"","category":"section"},{"location":"tutorials/ep01_spiral-wave/#mechanics-tutorial_spiral-wave-plain-program","page":"EP01: Spiral Wave","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: ep01_spiral_wave.jl.\n\nusing Thunderbolt, LinearSolve, OrdinaryDiffEqOperatorSplitting\n\nmesh = generate_mesh(Quadrilateral, (2^6, 2^6), Vec{2}((0.0,0.0)), Vec{2}((2.5,2.5)));\n\nCâ‚˜ = ConstantCoefficient(1.0)\nÏ‡  = ConstantCoefficient(1.0)\nÎº  = ConstantCoefficient(SymmetricTensor{2,2,Float64}((4.5e-5, 0, 2.0e-5)));\n\nstimulation_protocol = NoStimulationProtocol();\n\ncell_model = Thunderbolt.FHNModel();\n\nfunction spiral_wave_initializer!(uâ‚€, f::GenericSplitFunction)\n    # TODO cleaner implementation. We need to extract this from the types or via dispatch.\n    heatfun = f.functions[1]\n    heat_dofrange = f.solution_indices[1]\n    odefun = f.functions[2]\n    ionic_model = odefun.ode\n\n    Ï†â‚€ = @view uâ‚€[heat_dofrange];\n    # TODO extraction these via utility functions\n    dh = heatfun.dh\n    sâ‚€flat = @view uâ‚€[(ndofs(dh)+1):end];\n    # Should not be reshape but some array of arrays fun, because in general (e.g. for heterogeneous tissues) we cannot reshape into a matrix\n    sâ‚€ = reshape(sâ‚€flat, (ndofs(dh), Thunderbolt.num_states(ionic_model)-1));\n\n    for cell in CellIterator(dh)\n        _celldofs = celldofs(cell)\n        Ï†â‚˜_celldofs = _celldofs[dof_range(dh, :Ï†â‚˜)]\n        # TODO query coordinate directly from the cell model\n        coordinates = getcoordinates(cell)\n        for (i, (xâ‚, xâ‚‚)) in zip(Ï†â‚˜_celldofs,coordinates)\n            if xâ‚ <= 1.25 && xâ‚‚ <= 1.25\n                Ï†â‚€[i] = 1.0\n            end\n            if xâ‚‚ >= 1.25\n                sâ‚€[i,1] = 0.1\n            end\n        end\n    end\nend;\n\nep_model = MonodomainModel(\n    Câ‚˜,\n    Ï‡,\n    Îº,\n    stimulation_protocol,\n    cell_model,\n    :Ï†â‚˜, :s,\n);\n\nsplit_ep_model = ReactionDiffusionSplit(ep_model);\n\nspatial_discretization_method = FiniteElementDiscretization(\n    Dict(:Ï†â‚˜ => LagrangeCollection{1}()),\n)\nodeform = semidiscretize(split_ep_model, spatial_discretization_method, mesh);\n\nuâ‚€ = zeros(Float32, solution_size(odeform))\nspiral_wave_initializer!(uâ‚€, odeform);\n\nheat_timestepper = BackwardEulerSolver(\n    inner_solver=KrylovJL_CG(atol=1e-6, rtol=1e-5),\n);\n\ncell_timestepper = AdaptiveForwardEulerSubstepper(;\n    reaction_threshold=0.1,\n);\n\ntimestepper = LieTrotterGodunov((heat_timestepper, cell_timestepper));\n\ndtâ‚€   = 1.0\ndtvis = 25.0\ntspan = (0.0, 1000.0);\n\ntspan = (0.0, dtvis);   # hide\n\nproblem = OperatorSplittingProblem(odeform, uâ‚€, tspan);\n\nintegrator = init(problem, timestepper, dt=dtâ‚€);\n\nio = ParaViewWriter(\"EP01_spiral_wave\")\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    (; dh) = odeform.functions[1]\n    Ï† = u[odeform.solution_indices[1]]\n    store_timestep!(io, t, dh.grid) do file\n        Thunderbolt.store_timestep_field!(file, t, dh, Ï†, :Ï†â‚˜)\n    end\nend;\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorials/cm05_fourchambers/#mechanics-tutorial_fourchamber","page":"CM05: Four Chamber (TODO)","title":"Mechanics Tutorial 5: Coupling Heart Valve Models","text":"todo: Todo\nshow open four chamber geometry\n\nThis tutorial shows how to do four chamber simulations.\n\ntodo: Todo\nProvide context.","category":"section"},{"location":"tutorials/cm05_fourchambers/#Commented-Program","page":"CM05: Four Chamber (TODO)","title":"Commented Program","text":"todo: Todo\nFinalize subdomain management and use this as first simple showcase. Use free four chamber model.","category":"section"},{"location":"tutorials/cm05_fourchambers/#References","page":"CM05: Four Chamber (TODO)","title":"References","text":"","category":"section"},{"location":"tutorials/cm05_fourchambers/#mechanics-tutorial_fourchamber-plain-program","page":"CM05: Four Chamber (TODO)","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: cm05_fourchamber.jl.\n\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"devdocs/DifferentialEquationsjl-issue/#Brain-flush-about-relevant-design-decisions","page":"Brain flush about relevant design decisions","title":"Brain flush about relevant design decisions","text":"https://github.com/SciML/DifferentialEquations.jl/issues/997\n\nMy personal roadmap is to publish Thunderbolt.jl soon, which is a multiphysics framework which tries to be close to the design of the libraries in the DifferentialEquations.jl ecosystem, and to upstream relevant parts (after cleaning up and settling the design). \n\nIn Thunderbolt.jl I approach the outlined problems as follows (in the spoiler because likely not relevant for most readers). I put it here to see what problems come if we follow one approach deeper into the PDE rabbit hole (multiphysics/coupled problems). I hope that we can learn something about the interface design from this description.\n\n1,2,3,5 I do not have a clear separation between the hypothetic PDEFunction and the PDEProblem, because I could not figure out how to untie them in a modular and generic fashion, yet. Instead I have a granular distinction between the different types of PDE problems which I encounter (CoupledProblem, SplitProblem, ParitionedProblem,PointwiseProblem,QuasiStaticNonlinearProblem,QuasiStaticDAEProblem...). I ended up here because I am not sure what the distinguishing property between the problems should be (in contrast to ODE/SDE/...-Problems, where it is immediately clear).\n\n4,7 When constructing the problem from some model the discrete mesh (with some coordinate system), a discretization technique and boundary condition information is passed. This way the problem can cache the boundary condition information for a specific discretization and it also directly has the solution vector sizes (+meta information about the degrees of freedom). This way I can only handle a limited number of methods from class B (partitioned, basically method of lines) above and technically it should be possible to provide support for A (not touched this one yet).\n\n6 Solvers are defined per problem, as in the SciML ecosystem. However, this does not feel like the best choice due to the fine granularity of the problems described above. Basically when constructing the solvers I am constructing a sequence of operators, such that I get discrete (Non)linearFunctions of the form f(ut) plus caches for evaluating f, as well as caches for the inner solvers (e.g. \"NewtonRaphsonCache\", which is very similar to NonlinearSolve.jl . The operator is probably closest to a PDEFunction. However, I can not find a way to hoist the operator construction directly into the *Problems yet, because different solvers might need different operators. I think we can do the hoisting and I just had not enough time to figure out how to do it properly in the data structures.\n\n8 Kinda of a blocker for releasing my package public. I am currently basically poking around in the solver caches with dispatches. Since I want to interface against the SciML ecosystem in the long term anyway I have not bothered investing time. But I have something analogue to the TimeChoiceIterator in mind. I should note here that it is usually impossible to store the the full space-time solution in RAM (in contrast to e.g. pure small ODE problems). It should be just made clear that evaluating u(xt) is possible, but quite costly and comes with inaccurracies if the mesh is nonlinear (because we basically have to find where to evaluate, which usually involves solving a nonlinear problem). It should also be considered that many problems involve more than one field (e.g. \"heat and mechanics\" fields), hence we also need some way to distinguish between fields in the iterator.\n\nI have not given much details on the caching infrastructure since I am currently reworking it (and I honestly do not think that in depth detail here really will help with the problems). But the idea is similar to what is done in any package in the DifferentialEquations.jl ecosystem. Solvers construct caches and use them to control dispatches. \n\nThe obvious problem with my approach is that we do not clearly separate between modeling and solver. Yes, it allows that the model structure can be easier utilized, but I think we should be able to get an interface with a clearer separation and better reusability of individual components.","category":"section"},{"location":"howto/#How-to-Guides-Overview","page":"Overview","title":"How-to Guides Overview","text":"This page gives an overview of the how-to guides. How-to guides address various common tasks one might want to do in a cardiac multiphysics simuation. Many of the guides are extensions, or build on top of, the tutorials and, therefore,  some familiarity with Thunderbolt is assumed.\n\n","category":"section"},{"location":"howto/#[Benchmarking](benchmarking.md)","page":"Overview","title":"Benchmarking","text":"This guide shows how we can understand which parts of the simulation how to get information about where time and memory is spent.\n\n\n\nMore coming soon...","category":"section"},{"location":"api-reference/solver/#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"api-reference/solver/#Linear","page":"Solver","title":"Linear","text":"","category":"section"},{"location":"api-reference/solver/#Preconditioners","page":"Solver","title":"Preconditioners","text":"","category":"section"},{"location":"api-reference/solver/#Nonlinear","page":"Solver","title":"Nonlinear","text":"","category":"section"},{"location":"api-reference/solver/#Time","page":"Solver","title":"Time","text":"","category":"section"},{"location":"api-reference/solver/#Operator-Splitting-Adaptivity","page":"Solver","title":"Operator Splitting Adaptivity","text":"","category":"section"},{"location":"api-reference/solver/#Thunderbolt.SchurComplementLinearSolver","page":"Solver","title":"Thunderbolt.SchurComplementLinearSolver","text":"SchurComplementLinearSolver(inner_alg::SciMLBase.AbstractLinearAlgorithm)\n\nA solver for block systems of the form\n\nbeginbmatrix\n    A_11  A_12 \n    A_21  0\nendbmatrix\nbeginbmatrix\n    u_1 \n    u_2\nendbmatrix\n=\nbeginbmatrix\n    b_1 \n    b_2\nendbmatrix\n\nwith small zero block of size N_2 times N_2 and invertible A_11 with size N_1 times N_1. The inner linear solver is responsible to solve for N_2 systems of the form A_11 z_i = c_i.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.Preconditioners.BlockPartitioning","page":"Solver","title":"Thunderbolt.Preconditioners.BlockPartitioning","text":"BlockPartitioning{Ti<:Integer, Backend}\n\nStruct that encapsulates the diagonal partitioning configuration which is then used to distribute the work across multiple cores.\n\nFields\n\npartsize::Ti: Size of each partition (diagonal block).\nnparts::Ti: Number of partitions (i.e. size(A,1)/partsize).\nnchunks::Ti: Number of workgroups (e.g. CPU cores or GPU blocks).\nchunksize::Ti: Number of partitions assigned to each workgroup.\nbackend::Backend: Execution backend that determines where and how the preconditioner is applied, such as CPU() or CUDABackend().\n\nnote: Note\nchuncksize * nchunks doesn't have to be equal to nparts (can be less than or greater than). The diagonal partition iterator will take care of that throught strided iteration. The reason for this is obvious in GPUBackend, in which nblocks (i.e. nchunks) and nthreads (i.e. chunksize) are chosen to maximize occupancy, which may not be equal to nparts.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.Preconditioners.L1GSPrecBuilder","page":"Solver","title":"Thunderbolt.Preconditioners.L1GSPrecBuilder","text":"L1GSPrecBuilder(device::AbstractDevice)\n\nA builder for the L1 Gauss-Seidel preconditioner. This struct encapsulates the backend and provides a method to build the preconditioner.\n\nFields\n\ndevice::AbstractDevice: The backend used for the preconditioner. More info AbstractDevice.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.Preconditioners.L1GSPreconditioner","page":"Solver","title":"Thunderbolt.Preconditioners.L1GSPreconditioner","text":"L1GSPreconditioner{Partitioning, VectorType}\n\nThe â„“â‚ Gaussâ€“Seidel preconditioner is a robust and parallel-friendly preconditioner for sparse matrices.\n\nAlgorithm\n\nThe L1-GS preconditioner is constructed by dividing the matrix into diagonal blocks nparts:\n\nLet Î©â‚– denote the block with index k.\nFor each Î©â‚–, we define the following sets:\n$ Î©â± := {j âˆˆ Î©â‚– : i âˆˆ Î©â‚–} $ â†’ the set of columns in the diagonal block for row i\n$ Î©â±â‚’ := {j âˆ‰ Î©â‚– : i âˆˆ Î©â‚–} $ â†’  the remaining â€œoff-diagonalâ€ columns in row i\n\nThe preconditioner matrix M_â„“_1  is defined as:\n\nM_â„“_1GS = M_HGS + D^â„“_1 \n\nWhere D^â„“_1 is a diagonal matrix with entries: d_ii^â„“_1 = sum_j  Î©â±â‚’ a_ij, and M_HGS is obtained when the diagonal partitions are chosen to be the Gaussâ€“Seidel sweeps on $ A{kk} $ However, we use another convergant variant, which takes adavantage of the local estimation of Î¸ ( a{ii} >= Î¸ * d_{ii}$):\n\nM_â„“_1GS* = M_HGS + D^â„“_1* quad textwhere quad d_ii^â„“_1* = begincases 0  textif  a_ii geq eta d_ii^â„“_1  d_ii^â„“_12  textotherwise endcases\n\nFields\n\npartitioning: Encapsulates partitioning data (e.g. nparts, partsize, backend).\nD_Dl1: D+D^â„“_1.\nSLbuffer: Strictly lower triangular part of all diagonal blocks stacked in a vector.\n\nReference\n\nBaker, A. H., Falgout, R. D., Kolev, T. V., & Yang, U. M. (2011).   Multigrid Smoothers for Ultraparallel Computing,   SIAM J. Sci. Comput., 33(5), 2864â€“2887.\n\nnote: Note\nFor now M_HGS applies only a forward sweep of the Gaussâ€“Seidel method, which is a lower triangular matrix.  The interface will be extended in future versions to allow for backward and symmetric sweeps.\n\nExample\n\nbuilder = L1GSPrecBuilder(PolyesterDevice(4))\nN = 128*16\nA = spdiagm(0 => 2 * ones(N), -1 => -ones(N-1), 1 => -ones(N-1))\npartsize = 16\nprec = builder(A, partsize)\n# NOTES:\n# 1. for symmetric A, that's not of type `Symmetric`, or `SparseMatrixCSR` (i.e. in CSR format), then it's recommended to set `isSymA=true` for better performance `prec = builder(A, partsize; isSymA=true)`.\n# 2. for any user-defined `Î·` value, use `prec = builder(A, partsize; Î·=1.2)`.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.NewtonRaphsonSolver","page":"Solver","title":"Thunderbolt.NewtonRaphsonSolver","text":"NewtonRaphsonSolver{T}\n\nClassical Newton-Raphson solver to solve nonlinear problems of the form F(u) = 0. To use the Newton-Raphson solver you have to dispatch on\n\nupdate_linearization!\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.MultiLevelNewtonRaphsonSolver","page":"Solver","title":"Thunderbolt.MultiLevelNewtonRaphsonSolver","text":"MultilevelNewtonRaphsonSolver{T}\n\nMultilevel Newton-Raphson solver RabSanHsu:1979:mna for nonlinear problems of the form F(u,v) = 0; G(u,v) = 0. To use the Multilevel solver you have to dispatch on\n\nupdate_linearization!\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.ForwardEulerCellSolver","page":"Solver","title":"Thunderbolt.ForwardEulerCellSolver","text":"Simple forward euler to solve the cell model.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.HomotopyPathSolver","page":"Solver","title":"Thunderbolt.HomotopyPathSolver","text":"HomotopyPathSolver{IS, T, PFUN}\n\nSolve the nonlinear problem F(u,t)=0 with given time increments Î”ton some interval [t_begin, t_end] where t is some pseudo-time parameter.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.ReactionTangentController","page":"Solver","title":"Thunderbolt.ReactionTangentController","text":"ReactionTangentController{LTG <: OS.LieTrotterGodunov, T <: Real} <: OS.AbstractOperatorSplittingAlgorithm\n\nA timestep length controller for LieTrotterGodunov [5â€“7] operator splitting using the reaction tangent as proposed in [25] The next timestep length is calculated as\n\nsigmaleft(R_max right)=left(10-frac11+exp left(left(sigma_mathrmc-R_max right) cdot sigma_mathrmsright)right) cdotleft(Delta t_max -Delta t_min right)+Delta t_min \n\nFields\n\nltg::LTG: LieTrotterGodunov algorithm\nÏƒ_s::T: steepness\nÏƒ_c::T: offset in R axis\nÎ”t_bounds::NTuple{2,T}: lower and upper timestep length bounds\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Element-Interface","page":"Element Interface","title":"Element Interface","text":"","category":"section"},{"location":"devdocs/element_interface/#Entry-Points","page":"Element Interface","title":"Entry Points","text":"","category":"section"},{"location":"devdocs/element_interface/#Common","page":"Element Interface","title":"Common","text":"","category":"section"},{"location":"devdocs/element_interface/#Composite","page":"Element Interface","title":"Composite","text":"","category":"section"},{"location":"devdocs/element_interface/#Bilinear","page":"Element Interface","title":"Bilinear","text":"","category":"section"},{"location":"devdocs/element_interface/#Solid-Mechanics","page":"Element Interface","title":"Solid Mechanics","text":"","category":"section"},{"location":"devdocs/element_interface/#Elements","page":"Element Interface","title":"Elements","text":"","category":"section"},{"location":"devdocs/element_interface/#Thunderbolt.AbstractVolumetricElementCache","page":"Element Interface","title":"Thunderbolt.AbstractVolumetricElementCache","text":"Supertype for all caches to integrate over volumes.\n\nInterface:\n\nsetup_element_cache(model, qr, sdh)\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.AbstractSurfaceElementCache","page":"Element Interface","title":"Thunderbolt.AbstractSurfaceElementCache","text":"Supertype for all caches to integrate over surfaces.\n\nInterface:\n\nsetup_boundary_cache(model, qr, sdh)\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.AbstractInterfaceElementCache","page":"Element Interface","title":"Thunderbolt.AbstractInterfaceElementCache","text":"Supertype for all caches to integrate over interfaces.\n\nInterface:\n\nsetup_interface_cache(model, qr, ip, sdh)\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.assemble_element!","page":"Element Interface","title":"Thunderbolt.assemble_element!","text":"assemble_element!(Kâ‚‘::AbstractMatrix, cell::CellCache, element_cache::AbstractVolumetricElementCache, time)\n\nMain entry point for bilinear operators\n\nassemble_element!(Kâ‚‘::AbstractMatrix, uâ‚‘::AbstractVector, cell::CellCache, element_cache::AbstractVolumetricElementCache, time)\n\nUpdate element matrix in nonlinear operators\n\nassemble_element!(Kâ‚‘::AbstractMatrix, residualâ‚‘::AbstractVector, uâ‚‘::AbstractVector, cell::CellCache, element_cache::AbstractVolumetricElementCache, time)\n\nUpdate element matrix and residual in nonlinear operators\n\nassemble_element!(residualâ‚‘::AbstractVector, uâ‚‘::AbstractVector, cell::CellCache, element_cache::AbstractVolumetricElementCache, time)\n\nUpdate residual in nonlinear operators\n\nThe notation is as follows.\n\nK_e\nthe element stiffness matrix\nu_e\nthe element unknowns\nresidual_e\nthe element residual\n\n\n\n\n\n","category":"function"},{"location":"devdocs/element_interface/#Thunderbolt.assemble_facet!","page":"Element Interface","title":"Thunderbolt.assemble_facet!","text":"assemble_facet!(Kâ‚‘::AbstractMatrix, cell::CellCache, facet_cache::AbstractSurfaceElementCache, time)\n\nMain entry point for bilinear operators\n\nassemble_facet!(Kâ‚‘::AbstractMatrix, uâ‚‘::AbstractVector, cell::CellCache, facet_cache::AbstractSurfaceElementCache, time)\n\nUpdate facet matrix in nonlinear operators\n\nassemble_facet!(Kâ‚‘::AbstractMatrix, residualâ‚‘::AbstractVector, uâ‚‘::AbstractVector, cell::CellCache, facet_cache::AbstractSurfaceElementCache, time)\n\nUpdate facet matrix and residual in nonlinear operators\n\nassemble_facet!(residualâ‚‘::AbstractVector, uâ‚‘::AbstractVector, cell::CellCache, facet_cache::AbstractSurfaceElementCache, time)\n\nUpdate residual in nonlinear operators\n\nThe notation is as follows.\n\nK_e\nthe element stiffness matrix\nu_e\nthe element unknowns\nresidual_e\nthe element residual\n\n\n\n\n\n","category":"function"},{"location":"devdocs/element_interface/#Thunderbolt.assemble_interface!","page":"Element Interface","title":"Thunderbolt.assemble_interface!","text":"assemble_interface!(Kâ‚‘::AbstractMatrix, cell::CellCache, facet_cache::AbstractSurfaceElementCache, time)\n\nMain entry point for bilinear operators\n\nassemble_interface!(Kâ‚‘::AbstractMatrix, uâ‚‘::AbstractVector, cell::CellCache, facet_cache::AbstractSurfaceElementCache, time)\n\nUpdate facet matrix in nonlinear operators\n\nassemble_interface!(Kâ‚‘::AbstractMatrix, residualâ‚‘::AbstractVector, uâ‚‘::AbstractVector, cell::CellCache, facet_cache::AbstractSurfaceElementCache, time)\n\nUpdate facet matrix and residual in nonlinear operators\n\nassemble_interface!(residualâ‚‘::AbstractVector, uâ‚‘::AbstractVector, cell::CellCache, facet_cache::AbstractSurfaceElementCache, time)\n\nUpdate residual in nonlinear operators\n\nThe notation is as follows.\n\nK_e\nthe element pair stiffness matrix\nu_e\nthe element pair unknowns\nresidual_e\nthe element pair residual\n\n\n\n\n\n","category":"function"},{"location":"devdocs/element_interface/#Thunderbolt.AnalyticalCoefficientElementCache","page":"Element Interface","title":"Thunderbolt.AnalyticalCoefficientElementCache","text":"AnalyticalCoefficientElementCache(f(x,t)->..., nonzero_in_time_intervals, cellvalues)\n\nAnalytical coefficient described by a function in space and time. Can be sparse in time.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.SimpleFacetCache","page":"Element Interface","title":"Thunderbolt.SimpleFacetCache","text":"Standard cache for surface integrals.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.CompositeVolumetricElementCache","page":"Element Interface","title":"Thunderbolt.CompositeVolumetricElementCache","text":"This cache allows to combine multiple elements over the same volume. If surface caches are passed they are handled properly. This requred dispatching     isfacetincache(facet::FacetIndex, geometrycache, my_cache::MyCacheType)\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.CompositeSurfaceElementCache","page":"Element Interface","title":"Thunderbolt.CompositeSurfaceElementCache","text":"This cache allows to combine multiple elements over the same surface.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.CompositeInterfaceElementCache","page":"Element Interface","title":"Thunderbolt.CompositeInterfaceElementCache","text":"This cache allows to combine multiple elements over the same interface.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.BilinearMassIntegrator","page":"Element Interface","title":"Thunderbolt.BilinearMassIntegrator","text":"BilinearMassIntegrator{MT, CV}\n\nRepresents the integrand of the bilinearform a(uv) = int rho(x) v(x) u(x) dx for uv from the same function space with some given density field rho(x).\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.BilinearMassElementCache","page":"Element Interface","title":"Thunderbolt.BilinearMassElementCache","text":"The cache associated with BilinearMassIntegrator to assemble element mass matrices.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.BilinearDiffusionIntegrator","page":"Element Interface","title":"Thunderbolt.BilinearDiffusionIntegrator","text":"BilinearDiffusionIntegrator{CoefficientType}\n\nRepresents the integrand of the bilinear form a(uv) = -int nabla v(x) cdot D(x) nabla u(x) dx for a given diffusion tensor D(x) and uv from the same function space.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.BilinearDiffusionElementCache","page":"Element Interface","title":"Thunderbolt.BilinearDiffusionElementCache","text":"The cache associated with BilinearDiffusionIntegrator to assemble element diffusion matrices.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.QuasiStaticElementCache","page":"Element Interface","title":"Thunderbolt.QuasiStaticElementCache","text":"QuasiStaticElementCache\n\nA generic cache to assemble elements coming from a StructuralModel.\n\nRight now the model has to be formulated in the first Piola Kirchhoff stress tensor and F.\n\n\n\n\n\n","category":"type"},{"location":"howto/custom-elements/#how-to-custom-element","page":"Adding New Elements","title":"Adding New Elements","text":"todo: Todo\nFinalize the element interface and document some examples here.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"howto/custom-stimulation-protocols/#how-to-custom-stim-protocol","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"","category":"section"},{"location":"howto/custom-stimulation-protocols/#Analytical-protocols","page":"Custom Stimulation Protocols","title":"Analytical protocols","text":"The easiest way to implement a custom stimulation protocol is to use the AnalyticalTransmembraneStimulationProtocol\n\nWe start by define a struct holding all the parameters and make it callable. The return value is the stimulus strength. If you want to have parameters with spatial variation, which can be exchanged easily, then simply add a field with custom type and a function which accepts a coordinate x and a time t as input.\n\nHere we want to have a very simple S1S2 protocol with two spherical stimulus applied in a modular fashion. Hence, we define a struct holding two callable functions and the windows for the Stimuli.\n\nusing Thunderbolt, StaticArrays\n\nstruct SimpleS1S2Protocol{S1Type, S2Type, WT} <: Function\n    S1::S1Type\n    S1_window::WT\n    S2::S2Type\n    S2_window::WT\nend\n\nThe function call then simply selects the correct stimulus with time offset, and return 0 outside of the intervals.\n\nfunction (protocol::SimpleS1S2Protocol)(x,t)\n    if protocol.S1_window[1] < t < protocol.S1_window[2]\n        return protocol.S1(x,t-protocol.S1_window[1])\n    elseif protocol.S2_window[1] < t < protocol.S2_window[2]\n        return protocol.S2(x,t-protocol.S2_window[1])\n    end\n    return 0.0\nend\n\nIt is now possible to use the protocol as follows\n\ncoordinate_system_coefficient = CartesianCoordinateSystem{3}() # Or some cardiac coordinate system\nstimulus_around_zero(x,t) = max(1.0-norm(x),0.0)\nstimulus_around_one(x,t)  = max(1.0-norm(x+one(x)),0.0)\ns1s2fun = SimpleS1S2Protocol(\n    stimulus_around_zero, SVector((  0.0,   1.0)),\n    stimulus_around_one , SVector((200.0, 201.0)),\n)\nprotocol_nonzero_intervals = [s1s2fun.S1_window, s1s2fun.S2_window]\nprotocol = Thunderbolt.AnalyticalTransmembraneStimulationProtocol(\n    AnalyticalCoefficient(\n        s1s2fun,\n        coordinate_system_coefficient,\n    ),\n    protocol_nonzero_intervals,\n)\n\nwhere the coordinatesystemcoefficient determines the type of coordiante passed into the protocol.\n\ntodo: Todo\nWe should develop a way to define custom stimulation protocols symbolically, e.g. via MTK.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"topics/time-integration/#Time-Integration","page":"Time Integration","title":"Time Integration","text":"","category":"section"},{"location":"topics/time-integration/#theory_homotopy-path-methods","page":"Time Integration","title":"Homotopy path methods","text":"Homotopy path methods solve nonlinear problems with pseudo-time t on some time interval t_0 t_1. An initial guess is provided for the first nonlinear solve. Formally we can write down the problem as follows. Find u(t) such that\n\n0 = F(u(t) p t) qquad texton  t_0 t_1\n\nwhere u usually descibes the displacement of some mechanical system and the operator F contains some mechanical load, hence a subclass of these methods are so-called load stepping techniques. For mechanical problems we obtain systems with this form if we assume that inertial terms are neglibile (rho d^2_tu approx 0).","category":"section"},{"location":"topics/time-integration/#theory_operator-splitting","page":"Time Integration","title":"Operator Splitting","text":"For operator splitting procedures we assume that we have some time-dependent problem with initial condition u_0 = u(t_0) and an operator F describing the right hand side. We assume that F can be additively split into N suboperators F_i. This can be formally written as\n\nd_t u(t) = F(u(t) p t) = F_1(u(t) p t) +  + F_N(u(t) p t)  \n\nWe call t time the u(t) the state of the system. This way we can define subproblems\n\nbeginaligned\n    d_t u(t) = F_1(u(t) p t) \n              vdots \n    d_t u(t) = F_N(u(t) p t)\nendaligned\n\nNow, the key idea of operator splitting methods is that solving the subproblems can be easier, and hopefully more efficient, than solving the full problem. Arguably the easiest algorithm to advance the solution from t_0 to some time point t_1  t_0 is the Lie-Trotter-Godunov operator splitting [5â€“7]. Here the subproblems are solved consecutively, where the solution of one subproblem is taken as the initial guess for the next subproblem, until we have  solved all subproblems. In this case we have constructed an approximation  for u(t_1).\n\nMore formally we can write the Lie-Trotter-Godunov scheme [5â€“7] as follows:\n\nbeginaligned\n    textSolve quad d_t u^1(t) = F_1(u^1(t) p t)   quad texton  t_0 t_1  textwith  u^1(t_0) = u_0 \n    textSolve quad d_t u^2(t) = F_2(u^2(t) p t)   quad texton  t_0 t_1  textwith  u^2(t_0) = u^1(t_1) \n              vdots   \n    textSolve quad d_t u^N(t) = F_N(u^N(t) p t)   quad texton  t_0 t_1  textwith  u^N(t_0) = u^N-1(t_1)\nendaligned\n\nSuch that we obtain the approximation u(t_1) approx u^N-1(t_1). The approximation is first order in time, as we will show in the next section.\n\nProbably the most widely spread application for operator splitting schemes is the solution forreaction diffusion systems. These have the form\n\nd_t u(t) = Lu + R(u)\n\nwhere L is some linear operator, usually coming from the linaerization of diffusion opeartors and a nonlinear reaction part R which has some interesting locality properties. This locallity property usually tells us that the time evolution of R natually decouples into many small blocks. This way we only have to solve for the time evolution of a linear problem d_t u(t) = Lu and a set of many very small nonlinear problems d_t u(t) = R(u).","category":"section"},{"location":"topics/time-integration/#Analysis-of-Lie-Trotter-Godunov","page":"Time Integration","title":"Analysis of Lie-Trotter-Godunov","text":"It should be noted that even if we solve all subproblems analytically, then operator splitting schemes themselves almost always come with their own approximation error, which is simply called the splitting error. For linear problems this error can vanish if all suboperators F_i commute, i.e. if F_j cdot F_i = F_i cdot F_j for all 1 leq ij leq N, which can be shown with the Baker-Campbell-Hausdorff formula. Let us investigate the convergence order for two bounded linear operators L_1 and L_2, i.e. on the following system of ODEs\n\nd_t u = L_1 u + L_2 u  \n\nHere the exact solution u at time point t for some initial condition at t_0 = 0 is\n\nu(t) = e^(L_1 + L_2)t u_0  \n\nwhile the solution for the Lie-Trotter-Godunov scheme is\n\ntildeu(t) = e^L_1te^L_2t u_0  \n\nThe local truncation error can be written as\n\nepsilon(t) = e^L_1te^L_2t - e^(L_1 + L_2)t  u_0\n\nif we now replace the exponentials with their definitions we obtain for the first norm\n\nbeginaligned\n(I + tL_1 + frach^22L_1^2 + )(I + tL_2 + frach^22L_2^2 + ) - (I + t(L_1 + L_2) + frach^22(L_1+L_2)^2 + )\n= frach^22 (L_1 L_2 - L_2 L_1) +   leq frach^22  (L_1 L_2 - L_2 L_1)  + O(h^3)\nendaligned\n\nThis shows that the local truncation error is O(h^2) and hence the scheme is first order accurate.\n\nShowing stability is also straight forward. We assumed that L_1 and L_2 are bounded, so we obtain for all time points t  t and all repeated subdivisions n in mathbbN the following bound\n\n(e^L_1fractne^L_2fractn)^n\nleq e^L_1fractne^L_2fractn^n\nleq e^L_1fractn^n e^L_2fractn^n\nleq e^L_1t e^L_2t\nleq e^L_1t e^L_2t\nleq C  infty\n\nwhich implies stability of the scheme.","category":"section"},{"location":"topics/time-integration/#References","page":"Time Integration","title":"References","text":"S.Â Lie. Theorie der Transformationsgruppen I. MathematischeÂ Annalen 16, 441â€“528 (1880).\n\n\n\nH.Â F.Â Trotter. On the Product of Semi-Groups of Operators. ProceedingsÂ ofÂ theÂ AmericanÂ MathematicalÂ Society 10, 545â€“551 (1959).\n\n\n\nS.Â K.Â Godunov. A difference method for numerical calculation of discontinuous solutions of the equations of hydrodynamics. MatematicheskiiÂ Sbornik 89, 271â€“306 (1959).\n\n\n\n","category":"section"},{"location":"api-reference/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"api-reference/operators/#Thunderbolt.AbstractNonlinearOperator","page":"Operators","title":"Thunderbolt.AbstractNonlinearOperator","text":"AbstractNonlinearOperator\n\nModels of a nonlinear function F(u)v, where v is a test function.\n\nInterface:     (op::AbstractNonlinearOperator)(residual::AbstractVector, in::AbstractNonlinearOperator)     eltype()     size()\n\n# linearization\nmul!(out::AbstractVector, op::AbstractNonlinearOperator, in::AbstractVector)\nmul!(out::AbstractVector, op::AbstractNonlinearOperator, in::AbstractVector, Î±, Î²)\nupdate_linearization!(op::AbstractNonlinearOperator, u::AbstractVector, time)\nupdate_linearization!(op::AbstractNonlinearOperator, residual::AbstractVector, u::AbstractVector, time)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/operators/#Thunderbolt.AbstractLinearOperator","page":"Operators","title":"Thunderbolt.AbstractLinearOperator","text":"AbstractLinearOperator\n\nSupertype for operators which only depend on the test space.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/domain_management/#Domain-management","page":"Domain management","title":"Domain management","text":"Having multiple coupled subdomains is very common in multiphyics problems. Furthermore it is also not uncommon to have mixed(-dimensional) grids, think e.g. about the Purkinje network and the myocardium in chamber electrophysiology simulations. To manage these cases Thunderbolt.jl comes with some utilities. The first one is the SimpleMesh, which is takes a [Ferrite.Grid] and extracts information about the subdomains. The subdomains are split up by element type to handle mixed grids properly.\n\nThis subdomain information can then be used to construct [Ferrite.SubDofHandler] to manage the field variables on subdomains:\n\nFurthermore to manage data on subdomains we provide a non-uniform matrix-like data type.\n\nTwo examples where this is used: The storate of element assembly and quadrature data on mixed grids.","category":"section"},{"location":"devdocs/domain_management/#Multidomain-Assembly","page":"Domain management","title":"Multidomain Assembly","text":"The operators in Thunderbolt work very similar w.r.t. the management of multiple domains. The all follow the following pattern:\n\nfunction update_operator(op, time)\n    # Sanity check to see if the operator is internally consistent\n    # e.g. are all fields are present in the associated dof handlers, ...\n    check_internal_correctness(op)\n    # Depending on the operator and matrix type we get the correct assembler\n    assembler = instantiate_specific_assembler(op)\n    for sdh in op.dh.subdofhandlers\n        # We create a new or get a from the operator some scratch to make the assembly loop allocation free\n        # and possibly to precompute some generic stuff\n        weak_form_cache = setup_or_query_cache_for_subdomain(op, sdh)\n        # This step also acts a function barrier and contains the hot loop over the elements on the subdomain\n        # which actually fills the matrix\n        assemble_on_subdomain!(assembler, sdh, weak_form_cache)\n    end\n    # Some assemblers need a finalization step, e.g. distributed assembly, COO assembly, EA collapse, ...\n    finalize_assembly(assembler)","category":"section"},{"location":"devdocs/domain_management/#Thunderbolt.ApproximationDescriptor","page":"Domain management","title":"Thunderbolt.ApproximationDescriptor","text":"ApproximationDescriptor(symbol, interpolation_collection)\n\n\n\n\n\n","category":"type"},{"location":"devdocs/domain_management/#Thunderbolt.DenseDataRange","page":"Domain management","title":"Thunderbolt.DenseDataRange","text":"Examples:\n\nDenseDataRange{Vector{Int}, Vector{Int}} to map dofs (outer index) to elements (inner index)\nDenseDataRange{Vector{Vec{3,Float64}}, Vector{Int}} to store fluxes per quadrature point (inner index) per element (outer index)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/#API-Reference-Overview","page":"Overview","title":"API Reference Overview","text":"Pages = [\n    \"models.md\",\n    \"mesh.md\",\n    \"functions.md\",\n    \"problems.md\",\n    \"discretization.md\",\n    \"operators.md\",\n    \"solver.md\",\n    \"utility.md\",\n]","category":"section"},{"location":"topics/#Topic-Guide-Overview","page":"Overview","title":"Topic Guide Overview","text":"Coming soon...","category":"section"},{"location":"tutorials/ep02_purkinje/#ep-tutorial_purkinje","page":"EP02: Purkinje Network (TODO)","title":"Electrophysiology Tutorial 2: User Models","text":"todo: Todo\nUpload and reference my coupled simulation\n\nThis tutorial shows how to generate a Purkinje network and how to couple it with the chamber.\n\ntodo: Todo\nProvide context.","category":"section"},{"location":"tutorials/ep02_purkinje/#Commented-Program","page":"EP02: Purkinje Network (TODO)","title":"Commented Program","text":"todo: Todo\nFinalize subdomain management first and we need the volumetric intersection.","category":"section"},{"location":"tutorials/ep02_purkinje/#References","page":"EP02: Purkinje Network (TODO)","title":"References","text":"","category":"section"},{"location":"tutorials/ep02_purkinje/#ep-tutorial_purkinje-plain-program","page":"EP02: Purkinje Network (TODO)","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: ep02_purkinje.jl.\n\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api-reference/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"api-reference/functions/#Thunderbolt.AbstractSemidiscreteFunction","page":"Functions","title":"Thunderbolt.AbstractSemidiscreteFunction","text":"AbstractSemidiscreteFunction <: DiffEqBase.AbstractDiffEqFunction{iip=true}\n\nSupertype for all functions coming from PDE discretizations.\n\nInterface\n\nsolution_size(::AbstractSemidiscreteFunction)\nget_strategy(::AbstractSemidiscreteFunction)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/functions/#Thunderbolt.AbstractSemidiscreteBlockedFunction","page":"Functions","title":"Thunderbolt.AbstractSemidiscreteBlockedFunction","text":"AbstractSemidiscreteBlockedFunction <: AbstractSemidiscreteFunction\n\nSupertype for all functions coming from PDE discretizations with blocked structure.\n\nInterface\n\nBlockArrays.blocksizes(::AbstractSemidiscreteFunction)\nBlockArrays.blocks(::AbstractSemidiscreteFunction) -> Iterable\n\n\n\n\n\n","category":"type"},{"location":"api-reference/functions/#OrdinaryDiffEqOperatorSplitting.GenericSplitFunction","page":"Functions","title":"OrdinaryDiffEqOperatorSplitting.GenericSplitFunction","text":"GenericSplitFunction(functions::Tuple, solution_indices::Tuple)\nGenericSplitFunction(functions::Tuple, solution_indices::Tuple, syncronizers::Tuple)\n\nThis type of function describes a set of connected inner functions in mass-matrix form, as usually found in operator splitting procedures.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/cm01_simple-active-stress/#mechanics-tutorial_simple-active-stress","page":"CM01: Simple Active Stress","title":"Mechanics Tutorial 1: Simple Contracting Ventricle","text":"(Image: Contracting Left Ventricle)\n\nThis tutorial shows how to perform a simulation for simple active mechanical behavior of heart chambers.","category":"section"},{"location":"tutorials/cm01_simple-active-stress/#Introduction","page":"CM01: Simple Active Stress","title":"Introduction","text":"A general model to simulate the contractile behavior of cardiact issues it the active stress model. Let us denote with Omega_mathrmH our heart domain and with u  Omega_mathrmH to mathbbR^3 the unknown displacement field in three dimensional space. This induces a deformation gradient bmF = bmI + nabla bmu. With this formulation we can define a large class of active stress models in the first Piola-Kirchhoff stress with the following form:\n\nbmP = partial_bmF psi_mathrmp + mathcalN(bmalpha)  partial_bmF psi_mathrma\n\nAccording to Chadwick [1] the additive split of the stress in active and passive parts dates back to unpublished Peskin and has been popularized by Guccione et al. [2].","category":"section"},{"location":"tutorials/cm01_simple-active-stress/#Commented-Program","page":"CM01: Simple Active Stress","title":"Commented Program","text":"We start by loading Thunderbolt and LinearSolve to use a custom direct solver of our choice.\n\nusing Thunderbolt, LinearSolve\n\nOur goal is to simulate the contraction of a left ventricle with a very simple active stress formulation. Hence in a first step we need to load a suitable mesh. Thunderbolt can generate idealized geometries as follows.\n\nmesh = generate_ideal_lv_mesh(11,2,5;\n    inner_radius = 0.7,\n    outer_radius = 1.0,\n    longitudinal_upper = 0.2,\n    apex_inner = 1.3,\n    apex_outer = 1.5\n);\nnothing #hide\n\nHere the first 3 parameters control the number of elements in circumferential, radial and longitudinal directions. The number of elements is very low, so users have an easy time to play around with it. For scientific studies the mesh needs to be finer, such that the simulation converges properly. The remaining parameters control the chamber geometry shape itself.\n\ntip: Tip\nWe can also load realistic geometries with external formats. For this simply use either FerriteGmsh.jl or one of the loader functions stated in the mesh API.\n\nNext we will define a coordinate system, which helps us to work with cardiac geometries. This way we can reuse different methods, like for example fiber generators, across geometries.\n\ncoordinate_system = compute_lv_coordinate_system(mesh);\nnothing #hide\n\nIn this coordinate system we will now create a microstructure with linearly varying helix angle in transmural direction. The compute microstructure field will be generated on the function space of piecewise continuous first order Lagrange polynomials.\n\nmicrostructure = create_microstructure_model(\n    coordinate_system,\n    LagrangeCollection{1}()^3,\n    ODB25LTMicrostructureParameters(),\n);\nnothing #hide\n\nNow we describe the model which we want to use. The models provided by Thunderbolt are designed to be highly modular, so you can quickly swap out individual component or compose models with each other. For the active stress formulation we need first the active and passive material models. For this tutorial we use the models described by Guccione.\n\npassive_material_model = Guccione1991PassiveModel()\nactive_material_model  = Guccione1993ActiveModel();\nnothing #hide\n\nFurthermore we need to describe the calcium field and associate it with the sarcomere model. To simplify this tutorial we will use an analytical calcium profile. Note that we can also use experimental data or a precomputed calcium profile here, too, by simply changing the function implementation below.\n\nfunction calcium_profile_function(x::LVCoordinate,t)\n    linear_interpolation(t,y1,y2,t1,t2) = y1 + (t-t1) * (y2-y1)/(t2-t1)\n    ca_peak(x)                          = 1.0\n    if 0 â‰¤ t â‰¤ 300.0\n        return linear_interpolation(t,        0.0, ca_peak(x),   0.0, 300.0)\n    elseif t â‰¤ 500.0\n        return linear_interpolation(t, ca_peak(x),        0.0, 300.0, 500.0)\n    else\n        return 0.0\n    end\nend\ncalcium_field = AnalyticalCoefficient(\n    calcium_profile_function,\n    coordinate_system,\n);\nnothing #hide\n\nWe will use for a very simple sarcomere model which is constant in the calcium concentration. Note that a using a sarcomere model which has evoluation equations or rate-dependent terms will require different solvers.\n\nsarcomere_model = CaDrivenInternalSarcomereModel(ConstantStretchModel(), calcium_field);\nnothing #hide\n\nNow we have everything set to describe our active stress model by passing all the model components into it.\n\nactive_stress_model = ActiveStressModel(\n    passive_material_model,\n    active_material_model,\n    sarcomere_model,\n    microstructure,\n);\nnothing #hide\n\nNext we define some boundary conditions. In order to have a very rough approximation of the effect of the pericardium, we use a Robin boundary condition in normal direction.\n\nweak_boundary_conditions = (NormalSpringBC(1.0, \"Epicardium\"),)\n\nWe finalize the mechanical model by assigning a symbol to identify the unknown solution field and connect the active stress model with the weak boundary conditions.\n\nmechanical_model = QuasiStaticModel(:displacement, active_stress_model, weak_boundary_conditions)\n\ntip: Tip\nA full list of all models can be found in the API reference.\n\nWe now need to transform the space-time problem into a time-dependent problem by discretizing it spatially. This can be accomplished by the function semidiscretize, which takes a model and the disretization technique. Here we use a finite element discretization in space with first order Lagrange polynomials to discretize the displacement field.\n\ndanger: Danger\nThe discretization API does now play well with multiple domains right now and will be updated with a possible breaking change in future releases.\n\nspatial_discretization_method = FiniteElementDiscretization(\n    Dict(:displacement => LagrangeCollection{1}()^3),\n)\nquasistaticform = semidiscretize(mechanical_model, spatial_discretization_method, mesh);\nnothing #hide\n\nThe remaining code is very similar to how we use SciML solvers. We first define our time domain, initial time step length and some dt for visualization.\n\ndtâ‚€ = 10.0\ntspan = (0.0, 500.0)\ndtvis = 25.0;\nnothing #hide\n\nThis speeds up the CI # hide\n\ntspan = (0.0, dtvis);   # hide\nnothing #hide\n\nThen we setup the problem. Since we have no time dependence in our active stress model the correct problem here is a quasistatic problem.\n\nproblem = QuasiStaticProblem(quasistaticform, tspan);\nnothing #hide\n\nNext we define the time stepper. Since there are no time derivatives appearing in our formulation we have to opt for a homotopy path method, which solve the time depentent problems adaptively. As our non-linear solver we choose the standard Newton-Raphson method and a direct solver for the inner linear system. For the theory behind homotopy path methods we refer to the corresponding theory manual on homotopy path methods\n\ntimestepper = HomotopyPathSolver(\n    NewtonRaphsonSolver(\n        max_iter=10,\n        inner_solver=LinearSolve.UMFPACKFactorization(),\n    )\n);\nnothing #hide\n\nNow we initialize our time integrator as usual.\n\nintegrator = init(problem, timestepper, dt=dtâ‚€, verbose=true, adaptive=true, dtmax=25.0);\nnothing #hide\n\ntodo: Todo\nThe post-processing API is not yet finished. Please revisit the tutorial later to see how to post-process the simulation online. Right now the solution is just exported into VTK, such that users can visualize the solution in e.g. ParaView.\n\nFinally we solve the problem in time.\n\nio = ParaViewWriter(\"CM01_simple_lv\");\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    @info t\n    (; dh) = problem.f\n    Thunderbolt.store_timestep!(io, t, dh.grid) do file\n    Thunderbolt.store_timestep_field!(io, t, dh, u, :displacement)\n    end\nend;\nnothing #hide\n\ntip: Tip\nIf you want to see more details of the solution process launch Julia with Thunderbolt as debug module:JULIA_DEBUG=Thunderbolt julia --project --threads=auto my_simulation_runner.jl","category":"section"},{"location":"tutorials/cm01_simple-active-stress/#References","page":"CM01: Simple Active Stress","title":"References","text":"R.Â Chadwick. Mechanics of the left ventricle. BiophysicalÂ journal 39, 279â€“288 (1982).\n\n\n\nJ.Â M.Â Guccione, L.Â K.Â Waldman and A.Â D.Â McCulloch. Mechanics of Active Contraction in Cardiac Muscle: Part IIâ€”Cylindrical Models of the Systolic Left Ventricle. JournalÂ ofÂ BiomechanicalÂ Engineering 115, 82â€“90 (1993).\n\n\n\n","category":"section"},{"location":"tutorials/cm01_simple-active-stress/#mechanics-tutorial_simple-active-stress-plain-program","page":"CM01: Simple Active Stress","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: cm01_simple-active-stress.jl.\n\nusing Thunderbolt, LinearSolve\n\nmesh = generate_ideal_lv_mesh(11,2,5;\n    inner_radius = 0.7,\n    outer_radius = 1.0,\n    longitudinal_upper = 0.2,\n    apex_inner = 1.3,\n    apex_outer = 1.5\n);\n\ncoordinate_system = compute_lv_coordinate_system(mesh);\n\nmicrostructure = create_microstructure_model(\n    coordinate_system,\n    LagrangeCollection{1}()^3,\n    ODB25LTMicrostructureParameters(),\n);\n\npassive_material_model = Guccione1991PassiveModel()\nactive_material_model  = Guccione1993ActiveModel();\n\nfunction calcium_profile_function(x::LVCoordinate,t)\n    linear_interpolation(t,y1,y2,t1,t2) = y1 + (t-t1) * (y2-y1)/(t2-t1)\n    ca_peak(x)                          = 1.0\n    if 0 â‰¤ t â‰¤ 300.0\n        return linear_interpolation(t,        0.0, ca_peak(x),   0.0, 300.0)\n    elseif t â‰¤ 500.0\n        return linear_interpolation(t, ca_peak(x),        0.0, 300.0, 500.0)\n    else\n        return 0.0\n    end\nend\ncalcium_field = AnalyticalCoefficient(\n    calcium_profile_function,\n    coordinate_system,\n);\n\nsarcomere_model = CaDrivenInternalSarcomereModel(ConstantStretchModel(), calcium_field);\n\nactive_stress_model = ActiveStressModel(\n    passive_material_model,\n    active_material_model,\n    sarcomere_model,\n    microstructure,\n);\n\nweak_boundary_conditions = (NormalSpringBC(1.0, \"Epicardium\"),)\n\nmechanical_model = QuasiStaticModel(:displacement, active_stress_model, weak_boundary_conditions)\n\nspatial_discretization_method = FiniteElementDiscretization(\n    Dict(:displacement => LagrangeCollection{1}()^3),\n)\nquasistaticform = semidiscretize(mechanical_model, spatial_discretization_method, mesh);\n\ndtâ‚€ = 10.0\ntspan = (0.0, 500.0)\ndtvis = 25.0;\n\ntspan = (0.0, dtvis);   # hide\n\nproblem = QuasiStaticProblem(quasistaticform, tspan);\n\ntimestepper = HomotopyPathSolver(\n    NewtonRaphsonSolver(\n        max_iter=10,\n        inner_solver=LinearSolve.UMFPACKFactorization(),\n    )\n);\n\nintegrator = init(problem, timestepper, dt=dtâ‚€, verbose=true, adaptive=true, dtmax=25.0);\n\nio = ParaViewWriter(\"CM01_simple_lv\");\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    @info t\n    (; dh) = problem.f\n    Thunderbolt.store_timestep!(io, t, dh.grid) do file\n    Thunderbolt.store_timestep_field!(io, t, dh, u, :displacement)\n    end\nend;\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"howto/custom-energies/#how-to-custom-energy","page":"Adding Energies","title":"Adding Energies","text":"todo: Todo\nFinalize the element interface and document some examples here.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorials/ep06_pacemaker/#ep-tutorial_pacemaker","page":"EP06: Pacemakers (TODO)","title":"Electrophysiology Tutorial 6: Pacemakers","text":"todo: Todo\nShow activation timings.\n\nThis tutorial shows how to solve Eikonal models and how to recover transemembrane potential fields.\n\ntodo: Todo\nProvide context.","category":"section"},{"location":"tutorials/ep06_pacemaker/#Commented-Program","page":"EP06: Pacemakers (TODO)","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/ep06_pacemaker/#References","page":"EP06: Pacemakers (TODO)","title":"References","text":"","category":"section"},{"location":"tutorials/ep06_pacemaker/#ep-tutorial_pacemaker-plain-program","page":"EP06: Pacemakers (TODO)","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: ep06_pacemaker.jl.\n\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"tutorials/ep05_eikonal/#ep-tutorial_eikonal","page":"EP05: Eikonal Models (WIP)","title":"Electrophysiology Tutorial 5: Eikonal Models","text":"todo: Todo\nShow activation timings.\n\nThis tutorial shows how to solve Eikonal models and how to recover transemembrane potential fields.\n\ntodo: Todo\nProvide context.","category":"section"},{"location":"tutorials/ep05_eikonal/#Commented-Program","page":"EP05: Eikonal Models (WIP)","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/ep05_eikonal/#References","page":"EP05: Eikonal Models (WIP)","title":"References","text":"","category":"section"},{"location":"tutorials/ep05_eikonal/#ep-tutorial_eikonal-plain-program","page":"EP05: Eikonal Models (WIP)","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: ep05_eikonal.jl.\n\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api-reference/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"api-reference/utility/#Collections","page":"Utility","title":"Collections","text":"","category":"section"},{"location":"api-reference/utility/#Iteration","page":"Utility","title":"Iteration","text":"","category":"section"},{"location":"api-reference/utility/#IO","page":"Utility","title":"IO","text":"","category":"section"},{"location":"api-reference/utility/#Transfer-Operators","page":"Utility","title":"Transfer Operators","text":"","category":"section"},{"location":"api-reference/utility/#Postprocessing","page":"Utility","title":"Postprocessing","text":"","category":"section"},{"location":"api-reference/utility/#ECG","page":"Utility","title":"ECG","text":"","category":"section"},{"location":"api-reference/utility/#Thunderbolt.InterpolationCollection","page":"Utility","title":"Thunderbolt.InterpolationCollection","text":"InterpolationCollection\n\nA collection of compatible interpolations over some (possilby different) cells.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.ScalarInterpolationCollection","page":"Utility","title":"Thunderbolt.ScalarInterpolationCollection","text":"ScalarInterpolationCollection\n\nA collection of compatible scalar-valued interpolations over some (possilby different) cells.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.VectorInterpolationCollection","page":"Utility","title":"Thunderbolt.VectorInterpolationCollection","text":"VectorInterpolationCollection\n\nA collection of compatible vector-valued interpolations over some (possilby different) cells.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.VectorizedInterpolationCollection","page":"Utility","title":"Thunderbolt.VectorizedInterpolationCollection","text":"VectorizedInterpolationCollection{order} <: InterpolationCollection\n\nA collection of fixed-order vectorized Lagrange interpolations across different cell types.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.LagrangeCollection","page":"Utility","title":"Thunderbolt.LagrangeCollection","text":"LagrangeCollection{order} <: InterpolationCollection\n\nA collection of fixed-order Lagrange interpolations across different cell types.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.QuadratureRuleCollection","page":"Utility","title":"Thunderbolt.QuadratureRuleCollection","text":"QuadratureRuleCollection(order::Int)\n\nA collection of quadrature rules across different cell types.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.CellValueCollection","page":"Utility","title":"Thunderbolt.CellValueCollection","text":"CellValueCollection(::QuadratureRuleCollection, ::InterpolationCollection)\n\nHelper to construct and query the correct cell values on mixed grids.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.FacetValueCollection","page":"Utility","title":"Thunderbolt.FacetValueCollection","text":"FacetValueCollection(::QuadratureRuleCollection, ::InterpolationCollection)\n\nHelper to construct and query the correct facet values on mixed grids.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.QuadraturePoint","page":"Utility","title":"Thunderbolt.QuadraturePoint","text":"QuadraturePoint{dim, T}\n\nA simple helper to carry quadrature point information.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.QuadratureIterator","page":"Utility","title":"Thunderbolt.QuadratureIterator","text":"QuadratureIterator(::QuadratureRule)\nQuadratureIterator(::FacetQuadratureRule, local_facet_idx::Int)\nQuadratureIterator(::CellValues)\nQuadratureIterator(::FacetValues)\n\nA helper to loop over the quadrature points in some rule or cache with type QuadraturePoint.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.ParaViewWriter","page":"Utility","title":"Thunderbolt.ParaViewWriter","text":"\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.JLD2Writer","page":"Utility","title":"Thunderbolt.JLD2Writer","text":"\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.NodalIntergridInterpolation","page":"Utility","title":"Thunderbolt.NodalIntergridInterpolation","text":"NodalIntergridInterpolation(dh_from::DofHandler{sdim}, dh_to::DofHandler{sdim}, field_name_from::Symbol, field_name_to::Symbol; subdomain_from = 1:length(dh_from.subdofhandlers), subdomains_to = 1:length(dh_to.subdofhandlers))\nNodalIntergridInterpolation(dh_from::DofHandler{sdim}, dh_to::DofHandler{sdim}, field_name::Symbol; subdomain_from = 1:length(dh_from.subdofhandlers), subdomains_to = 1:length(dh_to.subdofhandlers))\nNodalIntergridInterpolation(dh_from::DofHandler{sdim}, dh_to::DofHandler{sdim}; subdomain_from = 1:length(dh_from.subdofhandlers), subdomains_to = 1:length(dh_to.subdofhandlers))\n\nConstruct a transfer operator to move a field field_name from dof handler dh_from to another dof handler dh_to, assuming that all spatial coordinates of the dofs for dh_to are in the interior or boundary of the mesh contained within dh_from. This is necessary to have valid interpolation values, as this operator does not have extrapolation functionality.\n\nnote: Note\nWe assume a continuous coordinate field, if the interpolation of the named field is continuous.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.transfer!","page":"Utility","title":"Thunderbolt.transfer!","text":"This is basically a fancy matrix-vector product to transfer the solution from one problem to another one.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/utility/#Thunderbolt.PoissonECGReconstructionCache","page":"Utility","title":"Thunderbolt.PoissonECGReconstructionCache","text":"PoissonECGReconstructionCache(fâ‚‘â‚š::GenericSplitFunction, Î©â‚œ::AbstractMesh, Îºáµ¢, Îº, electrodes::AbstractVector{<:Vec}; ground, linear_solver, solution_vector_type, system_matrix_type)\n\nSets up a cache for calculating varphi_mathrme by solving the Poisson problem\n\nnabla cdot (boldsymbolkappa_mathrmi + boldsymbolkappa_mathrme) nabla varphi_mathrme=-nabla cdotleft(boldsymbolkappa_mathrmi nabla varphi_mathrmmright)\n\nas for example proposed in [26] and investigated in [27] (as well as other studies). Here Îºâ‚‘ is the extracellular conductivity tensor and Îºáµ¢ is the intracellular conductivity tensor. The cache includes the assembled stiffness matrix with applied homogeneous Dirichlet boundary condition at the first vertex of the mesh. As the problem is solved for each timestep with only the right hand side changing.\n\nKeyword Arguments\n\nground               = Set([VertexIndex(1, 1)])\nlinear_solver        = LinearSolve.KrylovJL_CG()\nsolution_vector_type = Vector{Float64}\nsystem_matrix_type   = ThreadedSparseMatrixCSR{Float64,Int64}\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.Plonsey1964ECGGaussCache","page":"Utility","title":"Thunderbolt.Plonsey1964ECGGaussCache","text":"Plonsey1964ECGGaussCache(op::AbstractBilinearOperator, Ï†â‚˜::AbstractVector)\n\nHere Ï†â‚˜ is the solution vector containing the transmembranepotential, op is the associated diffusion opeartor and Îºâ‚œ is the torso's conductivity.\n\nReturns a cache to compute the lead field with the form proposed in [28] with the Gauss theorem applied to it, as for example described in [27]. Calling evaluate_ecg with this method simply evaluates the following integral efficiently:\n\nvarphi_e(x)=frac14 pi kappa_t int_Omega frac kappa_ Ï†â‚˜ cdot (tildex-x)(tildex-x)^3mathrmdtildex\n\nThe important simplifications taken are:\n\nSurrounding volume is an infinite, homogeneous sphere with isotropic conductivity\nThe extracellular space and surrounding volume share the same isotropic, homogeneous conductivity tensor\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.Geselowitz1989ECGLeadCache","page":"Utility","title":"Thunderbolt.Geselowitz1989ECGLeadCache","text":"Geselowitz1989ECGLeadCache(problem, torso_grid, Îº, Îºáµ¢, electrode_sets, [ground, linear_solver, solution_vector_type, system_matrix_type])\n\nHere the lead field, Z, is computed using the discretization of problem. The lead field is computed as the solution of\n\nnabla cdot(mathbfkappa nabla Z)=leftbeginarraycl\n-1  text  at the positive electrode  \n1  text  at the negative electrode  \n0  text  else where \nendarrayright\n\nWhere kappa is the bulk conductivity tensor.\n\nReturns a cache contain the lead fields that are used to compute the lead potentials as proposed in [29]. Calling reinit! with this method simply evaluates the following integral efficiently:\n\nV(t)=int nabla Z(boldsymbolx) cdot boldsymbolkappa_mathrmi nabla varphi_mathrmm mathrmdboldsymbolx\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.evaluate_ecg","page":"Utility","title":"Thunderbolt.evaluate_ecg","text":"evaluate_ecg(method::Plonsey1964ECGGaussCache, x::Vec, Îºâ‚œ::Real)\n\nCompute the pseudo ECG at a given point x by evaluating:\n\nvarphi_e(x)=frac14 pi kappa_t int_Omega frac kappa_ Ï†â‚˜ cdot (tildex-x)(tildex-x)^3mathrmdtildex\n\nFor more information please read the docstring for Plonsey1964ECGGaussCache\n\n\n\n\n\n","category":"function"},{"location":"tutorials/cm06_heartvalves/#mechanics-tutorial_heartvalves","page":"CM06: Heart Valves (TODO)","title":"Mechanics Tutorial 6: Coupling Heart Valve Models","text":"todo: Todo\nshow heart valve dynamics closely\n\nThis tutorial shows how to include heart valve models in your simulations.\n\ntodo: Todo\nProvide context.","category":"section"},{"location":"tutorials/cm06_heartvalves/#Commented-Program","page":"CM06: Heart Valves (TODO)","title":"Commented Program","text":"todo: Todo\nFinalize subdomain management and use this as second simple showcase. We need to figure out where to get the geometry with the strings.","category":"section"},{"location":"tutorials/cm06_heartvalves/#References","page":"CM06: Heart Valves (TODO)","title":"References","text":"","category":"section"},{"location":"tutorials/cm06_heartvalves/#mechanics-tutorial_heartvalves-plain-program","page":"CM06: Heart Valves (TODO)","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: cm06_heartvalves.jl.\n\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api-reference/problems/#Problems","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"tutorials/cm02_prestress/#mechanics-tutorial_prestress","page":"CM02: Prestressing (WIP)","title":"Mechanics Tutorial 2: Prestressing the Heart","text":"todo: Todo\ndecide which image to show here\n\nThis tutorial shows how to couple include prestress in your simulations and how to recover the correct initial condition.\n\ntodo: Todo\nProvide context.","category":"section"},{"location":"tutorials/cm02_prestress/#Commented-Program","page":"CM02: Prestressing (WIP)","title":"Commented Program","text":"info: Info\nWe are preparing a research paper on this topic and will upstream the relevant code into Thunderbolt during review.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#Thunderbolt.jl","page":"Home","title":"Thunderbolt.jl","text":"A high performance cardiac multiphysics system written in Julia\n\nWelcome to the documentation for Thunderbolt. The main goal of this project is to provide a single framework where we can develop new models and high  performance parallel solvers.\n\nwarning: Warning\nThis package is under heavy development. Expect regular breaking changes for now. If you are interested in joining development, then either comment an issue or reach out via julialang.zulipchat.com, via mail or via  julialang.slack.com. Alternatively open a discussion if you have something  specific in mind.\n\nnote: Note\nIf you are interested in using this package, then I am also happy to to get some constructive feedback, especially if things don't work out in the current design. This can be done via julialang.slack.com, julialang.zulipchat.com or via mail.\n\nnote: Note\nIf you use this package in an academic context, then I would be happy if you could cite it. Please also cite additionally the corresponding sources for models, numerical methods and utilities used in your code via this package.","category":"section"},{"location":"#How-the-documentation-is-organized","page":"Home","title":"How the documentation is organized","text":"This high level view of the documentation structure will help you find what you are looking for. The document is organized as follows[1]:\n\nTutorials are thoroughly documented examples which guides you through the process of building and solving cardiac models in Thunderbolt.\nTopic guides contains more in-depth explanations and discussions about multiphysics modeling concepts and their numerical treatment, and specifically how  these are realized in Thunderbolt.\nAPI Reference contains the technical API reference of functions and methods (e.g. the documentation strings).\nHow-to guides will guide you through the steps involved in addressing common tasks and use-cases. These usually build on top of the tutorials and thus assume basic knowledge of how Thunderbolt works.\n\n[1]: The organization of the document follows the DiÃ¡taxis Framework.\n\nIn addition there is the Developer documentation, for documentation of Ferrite internal code.","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"If you are new to the Thunderbolt project, it is suggested to start with the tutorials section before tackling more complex problems.\n\ntodo: Todo\nWe should provide a template for computational studies, possibly via DrWatson.jl (DrWatsonSim.jl?), to guide users towards best practices for computational studies.","category":"section"},{"location":"#Getting-help","page":"Home","title":"Getting help","text":"If you have questions about Thunderbolt it is suggested to use the #Thunderbolt.jl stream on Zulip. Zulip is preferred over Slack, because the discussions are available over longer time periods.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To use Thunderbolt you first need to install Julia, see https://julialang.org/ for details. Installing Thunderbolt can then be done from the Pkg REPL; press ] at the julia> promp to enter pkg> mode:\n\npkg> add https://github.com/JuliaHealth/Thunderbolt.jl#main\n\nThis will install Thunderbolt and all necessary dependencies. Press backspace to get back to the julia> prompt. (See the documentation for Pkg, Julia's package manager, for more help regarding package installation and project management.)\n\nFinally, to load Thunderbolt, use\n\nusing Thunderbolt\n\nYou are now all set to start using Thunderbolt!","category":"section"},{"location":"#Contributing-to-Thunderbolt","page":"Home","title":"Contributing to Thunderbolt","text":"Thunderbolt is under very active development. If you find a bug, then please open an issue on GitHub with a reproducer. If you are interested in joining development, then either comment an issue or reach out via Zulip, via mail or via  Slack. Alternatively open a discussion if you have something  specific in mind - please just check for open discussion before opening a new one.\n\nA detailed contributor guide is coming soon...","category":"section"},{"location":"api-reference/discretization/#Discretization","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"api-reference/discretization/#Interface","page":"Discretization","title":"Interface","text":"","category":"section"},{"location":"api-reference/discretization/#Thunderbolt.FiniteElementDiscretization","page":"Discretization","title":"Thunderbolt.FiniteElementDiscretization","text":"Descriptor for a finite element discretization of a part of a PDE over some subdomain.\n\nnote: Note\nThe current implementation is restricted to Bubnov-Galerkin methods. Petrov-Galerkin support will come in the future.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/discretization/#Thunderbolt.semidiscretize","page":"Discretization","title":"Thunderbolt.semidiscretize","text":"semidiscretize(model, discretization, mesh)\n\nTransform a space-time model into a pure time-dependent problem.\n\n\n\n\n\n","category":"function"}]
}
