var documenterSearchIndex = {"docs":
[{"location":"vroom/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"vroom/","page":"Performance Tips","title":"Performance Tips","text":"Many algorithms in Thunderbolt run in shared memory parallel by default if you launch julia with threads, e.g. via","category":"page"},{"location":"vroom/","page":"Performance Tips","title":"Performance Tips","text":"julia --thread=<num_physical_cores>","category":"page"},{"location":"vroom/","page":"Performance Tips","title":"Performance Tips","text":"In our experience exceeding the number of physical cores breaks performance for most simulations. Depending on your cache size simulations can even run faster if not all physical cores are utilized.","category":"page"},{"location":"vroom/","page":"Performance Tips","title":"Performance Tips","text":"We also recommend to pin to cores for threaded simulations.","category":"page"},{"location":"vroom/","page":"Performance Tips","title":"Performance Tips","text":"using ThreadPinning\npinthreads(:cores)","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"R. Chadwick. Mechanics of the left ventricle. Biophysical journal 39, 279–288 (1982).\n\n\n\nJ. M. Guccione, L. K. Waldman and A. D. McCulloch. Mechanics of Active Contraction in Cardiac Muscle: Part II—Cylindrical Models of the Systolic Left Ventricle. Journal of Biomechanical Engineering 115, 82–90 (1993).\n\n\n\nF. Regazzoni, M. Salvador, P. C. Africa, M. Fedele, L. Dedè and A. Quarteroni. A cardiac electromechanical model coupled with a lumped-parameter model for closed-loop blood circulation. Journal of Computational Physics 457, 111083 (2022).\n\n\n\nA. V. Ponnaluri, I. A. Verzhbinsky, J. D. Eldredge, A. Garfinkel, D. B. Ennis and L. E. Perotti. Model of left ventricular contraction: Validation criteria and boundary conditions. In: Functional Imaging and Modeling of the Heart: 10th International Conference, FIMH 2019, Bordeaux, France, June 6–8, 2019, Proceedings 10 (Springer, 2019); pp. 294–303.\n\n\n\nS. Lie. Theorie der Transformationsgruppen I. Mathematische Annalen 16, 441–528 (1880).\n\n\n\nH. F. Trotter. On the Product of Semi-Groups of Operators. Proceedings of the American Mathematical Society 10, 545–551 (1959).\n\n\n\nS. K. Godunov. A difference method for numerical calculation of discontinuous solutions of the equations of hydrodynamics. Matematicheskii Sbornik 89, 271–306 (1959).\n\n\n\nN. Rabbat, A. Sangiovanni-Vincentelli and H. Hsieh. A multilevel Newton algorithm with macromodeling and latency for the analysis of large-scale nonlinear circuits in the time domain. IEEE Transactions on Circuits and Systems 26, 733–741 (1979).\n\n\n\nD. Ogiermann, D. Balzani and L. E. Perotti. An Extended Generalized Hill Model for Cardiac Tissue: Comparison with Different Approaches Based on Experimental Data. In: Functional Imaging and Modeling of the Heart, edited by O. Bernard, P. Clarysse, N. Duchateau, J. Ohayon and M. Viallon (Cham, 2023); pp. 555–564.\n\n\n\nJ. Stålhand, A. Klarbring and G. A. Holzapfel. Smooth muscle contraction: mechanochemical formulation for homogeneous finite strains. Progress in biophysics and molecular biology 96, 465–481 (2008).\n\n\n\nS. Göktepe, A. Menzel and E. Kuhl. The Generalized Hill Model: A Kinematic Approach towards Active Muscle Contraction. Journal of the Mechanics and Physics of Solids 72, 20–39 (2014).\n\n\n\nG. A. Holzapfel and R. W. Ogden. Constitutive modelling of passive myocardium: a structurally based framework for material characterization. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 367, 3445–3475 (2009).\n\n\n\nD. H. Lin and F. C. Yin. A Multiaxial Constitutive Law for Mammalian Left Ventricular Myocardium in Steady-State Barium Contracture or Tetanus. Journal of Biomechanical Engineering 120, 504–517 (1998).\n\n\n\nJ. D. Humphrey, R. K. Strumpf and F. C. Yin. Determination of a Constitutive Relation for Passive Myocardium: I. A New Functional Form. Journal of Biomechanical Engineering 112, 333–339 (1990).\n\n\n\nJ. M. Guccione, A. D. McCulloch and L. K. Waldman. Passive Material Properties of Intact Ventricular Myocardium Determined From a Cylindrical Model. Journal of Biomechanical Engineering 113, 42–55 (1991).\n\n\n\nY. Zheng, W. X. Chan, S. Nielles-Vallespin, A. D. Scott, P. F. Ferreira, H. L. Leo and C. H. Yap. Effects of myocardial sheetlet sliding on left ventricular function. Biomechanics and Modeling in Mechanobiology, 1–20 (2023).\n\n\n\nS. Rossi, T. Lassila, R. Ruiz-Baier, A. Sequeira and A. Quarteroni. Thermodynamically consistent orthotropic activation model capturing ventricular systolic wall thickening in cardiac electromechanics. European Journal of Mechanics-A/Solids 48, 129–142 (2014).\n\n\n\nR. Piersanti, F. Regazzoni, M. Salvador, A. F. Corno, C. Vergara and A. Quarteroni. 3D–0D closed-loop model for the simulation of cardiac biventricular electromechanics. Computer Methods in Applied Mechanics and Engineering 391, 114607 (2022).\n\n\n\nS. Hartmann and P. Neff. Polyconvexity of generalized polynomial-type hyperelastic strain energy functions for near-incompressibility. International journal of solids and structures 40, 2767–2791 (2003).\n\n\n\nR. FitzHugh. Impulses and physiological states in theoretical models of nerve membrane. Biophysical journal 1, 445–466 (1961).\n\n\n\nJ. Nagumo, S. Arimoto and S. Yoshizawa. An active pulse transmission line simulating nerve axon. Proceedings of the IRE 50, 2061–2070 (1962).\n\n\n\nP. Pathmanathan, J. M. Cordeiro and R. A. Gray. Comprehensive uncertainty quantification and sensitivity analysis for cardiac action potential models. Frontiers in physiology 10, 721 (2019).\n\n\n\nM. Hirschvogel, M. Bassilious, L. Jagschies, S. M. Wildhirt and M. W. Gee. A monolithic 3D-0D coupled closed-loop model of the heart and the vascular system: experiment-based parameter estimation for patient-specific cardiac mechanics. International journal for numerical methods in biomedical engineering 33, e2842 (2017).\n\n\n\nA. H. Baker, R. D. Falgout, T. V. Kolev and U. M. Yang. Multigrid Smoothers for Ultraparallel Computing. SIAM Journal on Scientific Computing 33, 2864–2887 (2011), arXiv:https://doi.org/10.1137/100798806.\n\n\n\nD. Ogiermann, L. E. Perotti and D. Balzani. A simple and efficient adaptive time stepping technique for low-order operator splitting schemes applied to cardiac electrophysiology. International Journal for Numerical Methods in Biomedical Engineering (2023).\n\n\n\nM. Potse, B. Dube, J. Richer, A. Vinet and R. M. Gulrajani. A Comparison of Monodomain and Bidomain Reaction-Diffusion Models for Action Potential Propagation in the Human Heart. IEEE Transactions on Biomedical Engineering 53, 2425–2435 (2006).\n\n\n\nD. Ogiermann, D. Balzani and L. E. Perotti. The Effect of Modeling Assumptions on the ECG in Monodomain and Bidomain Simulations. In: Functional Imaging and Modeling of the Heart, Vol. 12738, edited by D. B. Ennis, L. E. Perotti and V. Y. Wang (Springer, Cham, 2021); pp. 503–514.\n\n\n\nR. Plonsey. Volume Conductor Fields of Action Currents. Biophysical Journal 4, 317–328 (1964).\n\n\n\nD. Geselowitz. On the theory of the electrocardiogram. Proceedings of the IEEE 77, 857–876 (1989).\n\n\n\n","category":"page"},{"location":"topics/nonlinear-solver/#Nonlinear-Solver","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"","category":"section"},{"location":"topics/nonlinear-solver/#Multi-Level-Newton-Raphson","page":"Nonlinear Solver","title":"Multi-Level Newton-Raphson","text":"","category":"section"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"A quadratically convergent Newton-Raphson scheme has been proposed by Rabbat et al. [8]. Let us assume we have a block-nonlinear problem with unknowns hatbmu and hatbmq of the following form:","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"beginaligned\n    bmhatf_textrmG(hatbmu hatbmq) = 0 \n    bmhatf_textrmL(hatbmu hatbmq) = 0\nendaligned","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"where solving bmhatf_textrmL(hatbmu hatbmq) = 0 is easy to solve for fixed hatbmu. If we can enforce this constraint, then we can rewrite the first equation by implicit function theorem as:","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"bmhatf_textrmG(hatbmu hatbmq(hatbmu)) = 0","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"Solving this modified problem with a Newton-Raphson algorithm requires a linearization around hatbmu, such that we have to solve at each Newton step the following linear problem","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"left( fracpartial  bmhatf_textrmG partial hatbmu + fracpartial bmhatf_textrmG partial hatbmq fracmathrmd hatbmq mathrmd hatbmu right) Delta hatbmu = -bmhatf_textrmG(hatbmu hatbmq(hatbmu))","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"In the continuum mechanics community the system matrix is also known as the consistent linearization.","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"The last missing piece the implicit function part for the system matrix, which is determined by solving an additional linear system:","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"fracpartial bmhatf_textrmL(hatbmu^i hatbmq^i) partial hatbmq fracmathrmd hatbmq mathrmd hatbmu = -fracpartial bmhatf_textrmL(hatbmu^i hatbmq^i) partial hatbmu","category":"page"},{"location":"topics/nonlinear-solver/#Using-finite-element-structure","page":"Nonlinear Solver","title":"Using finite-element structure","text":"","category":"section"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"Time discretization schemes applied to finite element semi-discretizations with L_2 variables (called internal variables) usually lead to block-nonlinear problems with local-global structure, as described above. This is commonly found in continuum mechanics problems. The local-global structure is simply a result of the algebraic decoupling of the internal variables, as they are associated with the quadrature points. For the resulting nonlinear form of the space-time discretization with field unknowns u and internal unknowns q = (q_1  q_nqp), we can write the finite element discretization formally as","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"beginaligned\n    f_G(uqpt) =  \n    f_Q(uqpt) =  \nendaligned","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"TODO picture with the fundamental decomposition operators","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"The internal unknowns q are located at the quadrature points which implies the following structure","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"beginaligned\n    f_Q_1(uq_1pt) =  \n    f_Q_2(uq_2pt) =  \n    vdots \n    f_Q_nqp(uq_nqppt) =  \nendaligned","category":"page"},{"location":"topics/nonlinear-solver/#Example:-Creep-Test-of-1D-Linear-Viscoelasticity","page":"Nonlinear Solver","title":"Example: Creep Test of 1D Linear Viscoelasticity","text":"","category":"section"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"A simple linear viscoelastic material model in 1D in weak form is:","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"beginaligned\n                0 = int_Omega (E_0 partial_x u(xt) + E_1 (partial_x u(xt) + q(xt))) cdot partial_x delta u(x) textrmdx + Neumann \npartial_t q(xt) = fracE_1eta_1 (partial_x u(xt)-q(xt))\nendaligned","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"Assuming we have a single 1D element Omega = -11 with linear ansatz functions and Gauss-Legendre quadrature (i.e. 2 points) the Neumann condition partial_x u(1t) = 1 and the Dirichlet condition u(-1t) = 0, then applying a Galerkin semi-discretization yields the following linear DAE in mass matrix form:","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"beginaligned\n            0   =  tildeu_1 \n            0   =  05left(-(E_0 + E_1) tildeu_1 + (E_0 + E_1) tildeu_2 - E_1 tildeq_1 - E_1 tildeq_2 + 1right) \nd_t tildeq_1 = fracE_1eta_1 (-tildeu_1+tildeu_2-tildeq_1) \nd_t tildeq_2 = fracE_1eta_1 (-tildeu_1+tildeu_2-tildeq_2)\nendaligned","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"or, after condensing the first equation,","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"beginaligned\n            0   = 05left((E_0 + E_1) tildeu_2(t) - E_1 tildeq_1(t) - E_1 tildeq_2(t) + 1right) \nd_t tildeq_1(t) = fracE_1eta_1 (-tildeu_1+tildeu_2(t)-tildeq_1(t)) \nd_t tildeq_2(t) = fracE_1eta_1 (-tildeu_1+tildeu_2(t)-tildeq_2(t))\nendaligned","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"Applying the Backward Euler in time to this system we obtain the ,,nonlinear'' system","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"beginaligned\n 0 = 05left((E_0 + E_1) hattildeu^n_2 - E_1 hattildeq_1 - E_1 hattildeq_2 + f(t_n)right) = f_G(hattildeu_2 hattildeq_1 hattildeq_2) \n 0 = hattildeq^n_1 - hattildeq^n-1_1 - Delta t_n fracE_1eta_1 (-hattildeu_1+hattildeu_2-hattildeq_1) = f_Q_1(hattildeu_2 hattildeq_1) \n 0 = hattildeq^n_2 - hattildeq^n-1_2 - Delta t_n fracE_1eta_1 (-hattildeu_1+hattildeu_2-hattildeq_2) = f_Q_2(hattildeu_2 hattildeq_2) \nendaligned","category":"page"},{"location":"topics/nonlinear-solver/","page":"Nonlinear Solver","title":"Nonlinear Solver","text":"where we can observe that the internal problems are decoupled. The system can now be solved with the multi-level Newton-Raphson as described above.","category":"page"},{"location":"devdocs/#Developer-documentation","page":"Overview","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/#Design-details","page":"Overview","title":"Design details","text":"","category":"section"},{"location":"devdocs/#Models","page":"Overview","title":"Models","text":"","category":"section"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"In Thunderbolt a model essentially describes a set of PDEs, their boundary conditions and their coupling information on a high level.","category":"page"},{"location":"devdocs/#Functions","page":"Overview","title":"Functions","text":"","category":"section"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"Functions are simply semidiscretizations together with boundary condition and coupling information for the semidiscrete form.","category":"page"},{"location":"devdocs/#Problems","page":"Overview","title":"Problems","text":"","category":"section"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"A function equipped with a time interval and an initial guess.","category":"page"},{"location":"devdocs/#Operators","page":"Overview","title":"Operators","text":"","category":"section"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"Operators decouple the function description from their evaluation.","category":"page"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"assemble_element","category":"page"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"Questions:","category":"page"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"How to deal with quasi-static problems which also need velocities?\nHow to make recursive assemble_element definitions for volume coupled problems?","category":"page"},{"location":"devdocs/#Solver","page":"Overview","title":"Solver","text":"","category":"section"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"Solvers construct operators from given functions and solve some problem with the function info.","category":"page"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"setup_solver_caches(problem, solver, t₀) takes the problem and a solver to setup the operators needed during solve.","category":"page"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"Questions: ","category":"page"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"How to control which exact operator?\nWhen and how to check if the operator is compatible with the solver?","category":"page"},{"location":"devdocs/","page":"Overview","title":"Overview","text":"See also my brain flushing in real time some design decisions.","category":"page"},{"location":"howto/custom-sarcomere/","page":"Adding Sarcomeres","title":"Adding Sarcomeres","text":"EditURL = \"../literate-howto/custom-sarcomere.jl\"","category":"page"},{"location":"howto/custom-sarcomere/#how-to-custom-sarcomere","page":"Adding Sarcomeres","title":"Adding Sarcomeres","text":"","category":"section"},{"location":"howto/custom-sarcomere/","page":"Adding Sarcomeres","title":"Adding Sarcomeres","text":"todo: Todo\nFinalize the sarcomere interface and document some examples here.","category":"page"},{"location":"howto/custom-sarcomere/","page":"Adding Sarcomeres","title":"Adding Sarcomeres","text":"","category":"page"},{"location":"howto/custom-sarcomere/","page":"Adding Sarcomeres","title":"Adding Sarcomeres","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"EditURL = \"../literate-tutorials/ep04_geselowitz-ecg.jl\"","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/#ep-tutorial_geselowitz-ecg","page":"EP04: Monodomain ECG","title":"Electrophysiology Tutorial 4: Geselowitz ECG with Monodomain Model","text":"","category":"section"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"todo: Todo\nShow computed ECG.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"This tutorial shows how to setup ECG problems with monodomain models as the source and compute the QRS complex in a simple toy problem.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"todo: Todo\nProvide context.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/#Commented-Program","page":"EP04: Monodomain ECG","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"using Thunderbolt, LinearAlgebra, StaticArrays","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"todo: Todo\nThe initializer API is not yet finished and hence we deconstruct stuff here manually. Please note that this method is quite fragile w.r.t. to many changes you can make in the code below.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"function steady_state_initializer!(u₀, f::GenericSplitFunction)\n    # TODO cleaner implementation. We need to extract this from the types or via dispatch.\n    heatfun = f.functions[1]\n    heat_dofrange = f.solution_indices[1]\n    odefun = f.functions[2]\n    ionic_model = odefun.ode\n\n    φ₀ = @view u₀[heat_dofrange];\n    # TODO extraction these via utility functions\n    dh = heatfun.dh\n    s₀flat = @view u₀[(ndofs(dh)+1):end];\n    # Should not be reshape but some array of arrays fun\n    s₀ = reshape(s₀flat, (ndofs(dh), Thunderbolt.num_states(ionic_model)-1));\n    default_values = Thunderbolt.default_initial_state(ionic_model)\n\n    φ₀ .= default_values[1]\n    for i ∈ 1:(Thunderbolt.num_states(ionic_model)-1)\n        s₀[:, i] .= default_values[i+1]\n    end\nend","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"We start by defining a custom activation function","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"Base.@kwdef struct UniformEndocardialActivation <: Function\n    transmural_depth::Float64 = 0.15\nend\nfunction (p::UniformEndocardialActivation)(x::Vec{3}, t)\n    τᶠ = 0.25\n    # TODO source for this\n    if t ≤ 2.0 && x[1] < p.transmural_depth\n        return 0.5/τᶠ * exp(t/τᶠ)\n    else\n        return 0.0\n    end\nend\nprotocol = Thunderbolt.AnalyticalTransmembraneStimulationProtocol(\n    AnalyticalCoefficient(\n        UniformEndocardialActivation(),\n        CartesianCoordinateSystem{3}()\n    ),\n    [SVector((-Inf, Inf))],\n)","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"We also generate both meshes","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"num_elements_heart = (32,16,16)\nnum_elements_heart = (8,4,4) # hide\nheart_mesh = generate_mesh(Tetrahedron, num_elements_heart, Vec((1.5, 1.5, 0.0)), Vec((5.5, 3.5, 2.0)))\nnum_elements_torso = (56,40,28)\nnum_elements_torso = (14,10,7) # hide\ntorso_mesh = generate_mesh(Hexahedron,  num_elements_torso, Vec((0.0, 0.0, 0.0)), Vec((7.0, 5.0, 3.5)))","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"Then we place some electrodes and leads.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"ground_vertex = Thunderbolt.get_closest_vertex(Vec(0.0, 0.0, 0.0), torso_mesh)\nleads = [\n    [Vec( 0.,   0.,  1.5), Vec( 7.,   0.,  1.5)],\n    [Vec( 3.5,  0.,  1.5), Vec( 3.5,  5.,  1.5)],\n]","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"For our toy problem we use a very simple microstructure.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"microstructure = OrthotropicMicrostructureModel(\n    ConstantCoefficient((Vec(0.0,0.0,1.0))),\n    ConstantCoefficient((Vec(0.0,1.0,0.0))),\n    ConstantCoefficient((Vec(1.0,0.0,0.0))),\n)","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"With the microstructure we setup the diffusion tensor field in spectral form.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"todo: Todo\ncitation","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"κ₁ = 0.17 * 0.62 / (0.17 + 0.62)\nκᵣ = 0.019 * 0.24 / (0.019 + 0.24)\ndiffusion_tensor_field = SpectralTensorCoefficient(\n    microstructure,\n    ConstantCoefficient(SVector(κ₁, κᵣ, κᵣ))\n)","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"Now we setup our monodomain solver as usual.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"cellmodel = Thunderbolt.PCG2019()\nheart_model = MonodomainModel(\n    ConstantCoefficient(1.0),\n    ConstantCoefficient(1.0),\n    diffusion_tensor_field,\n    protocol,\n    cellmodel,\n    :φₘ, :s\n)\nheart_odeform = semidiscretize(\n    ReactionDiffusionSplit(heart_model),\n    FiniteElementDiscretization(Dict(:φₘ => LagrangeCollection{1}())),\n    heart_mesh,\n)\nu₀ = zeros(Float64, OS.function_size(heart_odeform))\nsteady_state_initializer!(u₀, heart_odeform)\ndt₀ = 0.01\ndtvis = 0.5\nTₘₐₓ = 50.0\nTₘₐₓ = dtvis # hide\ntspan = (0.0, Tₘₐₓ)\nproblem = OS.OperatorSplittingProblem(heart_odeform, u₀, tspan)\ntimestepper = OS.LieTrotterGodunov((\n    BackwardEulerSolver(),\n    ForwardEulerCellSolver(),\n))\nintegrator = init(problem, timestepper, dt=dt₀, verbose=true)","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"Now that the time integrator is ready we setup the ECG problem.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"torso_mesh_κᵢ = ConstantCoefficient(1.0)\ntorso_mesh_κ  = ConstantCoefficient(1.0)","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"todo: Todo\nShow how to transfer diffusion_tensor_field onto the torso mesh.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"geselowitz_ecg = Thunderbolt.Geselowitz1989ECGLeadCache(\n    heart_odeform,\n    torso_mesh,\n    torso_mesh_κᵢ,\n    torso_mesh_κ,\n    leads;\n    ground = Thunderbolt.OrderedSet([ground_vertex])\n)","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"todo: Todo\nImprove the ECG API to not spill all the internals. :)","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"We compute the ECG online as follows.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"io = ParaViewWriter(\"ep04_ecg\")\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    dh = heart_odeform.functions[1].dh\n    φ = u[heart_odeform.solution_indices[1]]\n    store_timestep!(io, t, dh.grid) do file\n        Thunderbolt.store_timestep_field!(file, t, dh, φ, :φₘ)\n    end\n\n    # To compute the ECG we just need to update the ecg cache\n    Thunderbolt.update_ecg!(geselowitz_ecg, φ)\n    # which then allows us to evaluate the leads like this\n    electrode_values = Thunderbolt.evaluate_ecg(geselowitz_ecg)\n    @info \"$t: Lead 1=$(electrode_values[1]) | Lead 2= $(electrode_values[2])\"\nend","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/#References","page":"EP04: Monodomain ECG","title":"References","text":"","category":"section"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/#ep-tutorial_geselowitz-ecg-plain-program","page":"EP04: Monodomain ECG","title":"Plain program","text":"","category":"section"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"Here follows a version of the program without any comments. The file is also available here: ep04_geselowitz-ecg.jl.","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"using Thunderbolt, LinearAlgebra, StaticArrays\n\nfunction steady_state_initializer!(u₀, f::GenericSplitFunction)\n    # TODO cleaner implementation. We need to extract this from the types or via dispatch.\n    heatfun = f.functions[1]\n    heat_dofrange = f.solution_indices[1]\n    odefun = f.functions[2]\n    ionic_model = odefun.ode\n\n    φ₀ = @view u₀[heat_dofrange];\n    # TODO extraction these via utility functions\n    dh = heatfun.dh\n    s₀flat = @view u₀[(ndofs(dh)+1):end];\n    # Should not be reshape but some array of arrays fun\n    s₀ = reshape(s₀flat, (ndofs(dh), Thunderbolt.num_states(ionic_model)-1));\n    default_values = Thunderbolt.default_initial_state(ionic_model)\n\n    φ₀ .= default_values[1]\n    for i ∈ 1:(Thunderbolt.num_states(ionic_model)-1)\n        s₀[:, i] .= default_values[i+1]\n    end\nend\n\nBase.@kwdef struct UniformEndocardialActivation <: Function\n    transmural_depth::Float64 = 0.15\nend\nfunction (p::UniformEndocardialActivation)(x::Vec{3}, t)\n    τᶠ = 0.25\n    # TODO source for this\n    if t ≤ 2.0 && x[1] < p.transmural_depth\n        return 0.5/τᶠ * exp(t/τᶠ)\n    else\n        return 0.0\n    end\nend\nprotocol = Thunderbolt.AnalyticalTransmembraneStimulationProtocol(\n    AnalyticalCoefficient(\n        UniformEndocardialActivation(),\n        CartesianCoordinateSystem{3}()\n    ),\n    [SVector((-Inf, Inf))],\n)\n\nnum_elements_heart = (32,16,16)\nnum_elements_heart = (8,4,4) # hide\nheart_mesh = generate_mesh(Tetrahedron, num_elements_heart, Vec((1.5, 1.5, 0.0)), Vec((5.5, 3.5, 2.0)))\nnum_elements_torso = (56,40,28)\nnum_elements_torso = (14,10,7) # hide\ntorso_mesh = generate_mesh(Hexahedron,  num_elements_torso, Vec((0.0, 0.0, 0.0)), Vec((7.0, 5.0, 3.5)))\n\nground_vertex = Thunderbolt.get_closest_vertex(Vec(0.0, 0.0, 0.0), torso_mesh)\nleads = [\n    [Vec( 0.,   0.,  1.5), Vec( 7.,   0.,  1.5)],\n    [Vec( 3.5,  0.,  1.5), Vec( 3.5,  5.,  1.5)],\n]\n\nmicrostructure = OrthotropicMicrostructureModel(\n    ConstantCoefficient((Vec(0.0,0.0,1.0))),\n    ConstantCoefficient((Vec(0.0,1.0,0.0))),\n    ConstantCoefficient((Vec(1.0,0.0,0.0))),\n)\n\nκ₁ = 0.17 * 0.62 / (0.17 + 0.62)\nκᵣ = 0.019 * 0.24 / (0.019 + 0.24)\ndiffusion_tensor_field = SpectralTensorCoefficient(\n    microstructure,\n    ConstantCoefficient(SVector(κ₁, κᵣ, κᵣ))\n)\n\ncellmodel = Thunderbolt.PCG2019()\nheart_model = MonodomainModel(\n    ConstantCoefficient(1.0),\n    ConstantCoefficient(1.0),\n    diffusion_tensor_field,\n    protocol,\n    cellmodel,\n    :φₘ, :s\n)\nheart_odeform = semidiscretize(\n    ReactionDiffusionSplit(heart_model),\n    FiniteElementDiscretization(Dict(:φₘ => LagrangeCollection{1}())),\n    heart_mesh,\n)\nu₀ = zeros(Float64, OS.function_size(heart_odeform))\nsteady_state_initializer!(u₀, heart_odeform)\ndt₀ = 0.01\ndtvis = 0.5\nTₘₐₓ = 50.0\nTₘₐₓ = dtvis # hide\ntspan = (0.0, Tₘₐₓ)\nproblem = OS.OperatorSplittingProblem(heart_odeform, u₀, tspan)\ntimestepper = OS.LieTrotterGodunov((\n    BackwardEulerSolver(),\n    ForwardEulerCellSolver(),\n))\nintegrator = init(problem, timestepper, dt=dt₀, verbose=true)\n\ntorso_mesh_κᵢ = ConstantCoefficient(1.0)\ntorso_mesh_κ  = ConstantCoefficient(1.0)\n\ngeselowitz_ecg = Thunderbolt.Geselowitz1989ECGLeadCache(\n    heart_odeform,\n    torso_mesh,\n    torso_mesh_κᵢ,\n    torso_mesh_κ,\n    leads;\n    ground = Thunderbolt.OrderedSet([ground_vertex])\n)\n\nio = ParaViewWriter(\"ep04_ecg\")\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    dh = heart_odeform.functions[1].dh\n    φ = u[heart_odeform.solution_indices[1]]\n    store_timestep!(io, t, dh.grid) do file\n        Thunderbolt.store_timestep_field!(file, t, dh, φ, :φₘ)\n    end\n\n    # To compute the ECG we just need to update the ecg cache\n    Thunderbolt.update_ecg!(geselowitz_ecg, φ)\n    # which then allows us to evaluate the leads like this\n    electrode_values = Thunderbolt.evaluate_ecg(geselowitz_ecg)\n    @info \"$t: Lead 1=$(electrode_values[1]) | Lead 2= $(electrode_values[2])\"\nend","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"","category":"page"},{"location":"tutorials/ep04_geselowitz-ecg/","page":"EP04: Monodomain ECG","title":"EP04: Monodomain ECG","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howto/benchmarking/#Benchmarking","page":"Benchmarking","title":"Benchmarking","text":"","category":"section"},{"location":"howto/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"To investiage the performance we can use the following code snippet, which should be self-explanatory","category":"page"},{"location":"howto/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"using Thunderbolt.TimerOutputs\nTimerOutputs.enable_debug_timings(Thunderbolt)\nTimerOutputs.reset_timer!()\nrun_simulation()\nTimerOutputs.print_timer()\nTimerOutputs.disable_debug_timings(Thunderbolt)","category":"page"},{"location":"howto/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"It makes sense to make sure the code is properly precompiled before benchmarkins, e.g. by calling run_simulation() once before running the code snippet.","category":"page"},{"location":"howto/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Internally we use TimerOutputs.jl for code annotations, marking performance critical sections.","category":"page"},{"location":"howto/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"More guides coming soon...","category":"page"},{"location":"tutorials/cm04_pericardium/","page":"CM04: Pericadium (TODO)","title":"CM04: Pericadium (TODO)","text":"EditURL = \"../literate-tutorials/cm04_pericardium.jl\"","category":"page"},{"location":"tutorials/cm04_pericardium/#mechanics-tutorial_pericardium","page":"CM04: Pericadium (TODO)","title":"Mechanics Tutorial 4: Pericardial Boundary Conditions","text":"","category":"section"},{"location":"tutorials/cm04_pericardium/","page":"CM04: Pericadium (TODO)","title":"CM04: Pericadium (TODO)","text":"todo: Todo\nshow pericardium","category":"page"},{"location":"tutorials/cm04_pericardium/","page":"CM04: Pericadium (TODO)","title":"CM04: Pericadium (TODO)","text":"This tutorial shows how to couple include prestress in your simulations and how to recover the correct initial condition.","category":"page"},{"location":"tutorials/cm04_pericardium/","page":"CM04: Pericadium (TODO)","title":"CM04: Pericadium (TODO)","text":"todo: Todo\nProvide context.","category":"page"},{"location":"tutorials/cm04_pericardium/#Commented-Program","page":"CM04: Pericadium (TODO)","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/cm04_pericardium/","page":"CM04: Pericadium (TODO)","title":"CM04: Pericadium (TODO)","text":"todo: Todo\nImplement [4]","category":"page"},{"location":"tutorials/cm04_pericardium/#References","page":"CM04: Pericadium (TODO)","title":"References","text":"","category":"section"},{"location":"tutorials/cm04_pericardium/","page":"CM04: Pericadium (TODO)","title":"CM04: Pericadium (TODO)","text":"A. V. Ponnaluri, I. A. Verzhbinsky, J. D. Eldredge, A. Garfinkel, D. B. Ennis and L. E. Perotti. Model of left ventricular contraction: Validation criteria and boundary conditions. In: Functional Imaging and Modeling of the Heart: 10th International Conference, FIMH 2019, Bordeaux, France, June 6–8, 2019, Proceedings 10 (Springer, 2019); pp. 294–303.\n\n\n\n","category":"page"},{"location":"tutorials/cm04_pericardium/#mechanics-tutorial_pericardium-plain-program","page":"CM04: Pericadium (TODO)","title":"Plain program","text":"","category":"section"},{"location":"tutorials/cm04_pericardium/","page":"CM04: Pericadium (TODO)","title":"CM04: Pericadium (TODO)","text":"Here follows a version of the program without any comments. The file is also available here: cm04_pericardium.jl.","category":"page"},{"location":"tutorials/cm04_pericardium/","page":"CM04: Pericadium (TODO)","title":"CM04: Pericadium (TODO)","text":"","category":"page"},{"location":"tutorials/cm04_pericardium/","page":"CM04: Pericadium (TODO)","title":"CM04: Pericadium (TODO)","text":"","category":"page"},{"location":"tutorials/cm04_pericardium/","page":"CM04: Pericadium (TODO)","title":"CM04: Pericadium (TODO)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"DocTestSetup = :(using Thunderbolt)","category":"page"},{"location":"api-reference/models/#models-api","page":"Models","title":"Models","text":"","category":"section"},{"location":"api-reference/models/#Coefficient","page":"Models","title":"Coefficient","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"ConstantCoefficient\nFieldCoefficient\nAnalyticalCoefficient\nSpectralTensorCoefficient\nSpatiallyHomogeneousDataField\nevaluate_coefficient","category":"page"},{"location":"api-reference/models/#Thunderbolt.ConstantCoefficient","page":"Models","title":"Thunderbolt.ConstantCoefficient","text":"ConstantCoefficient(value)\n\nEvaluates to the same value in space and time everywhere.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.FieldCoefficient","page":"Models","title":"Thunderbolt.FieldCoefficient","text":"FieldCoefficient(data, interpolation)\n\nA constant in time data field, interpolated per element with a given interpolation.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.AnalyticalCoefficient","page":"Models","title":"Thunderbolt.AnalyticalCoefficient","text":"AnalyticalCoefficient(f::Function, cs::CoordinateSystemCoefficient)\n\nA coefficient given as the analytical function f(x,t) in the specified coordiante system.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.SpectralTensorCoefficient","page":"Models","title":"Thunderbolt.SpectralTensorCoefficient","text":"SpectralTensorCoefficient(eigenvector_coefficient, eigenvalue_coefficient)\n\nRepresent a tensor A via spectral decomposition ∑ᵢ λᵢ vᵢ ⊗ vᵢ.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.SpatiallyHomogeneousDataField","page":"Models","title":"Thunderbolt.SpatiallyHomogeneousDataField","text":"SpatiallyHomogeneousDataField(timings::Vector, data::Vector)\n\nA data field which is constant in space and piecewise constant in time.\n\nThe value during the time interval [tᵢ,tᵢ₊₁] is dataᵢ, where t₀ is negative infinity and the last time point+1 is positive infinity.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#microstructure-api","page":"Models","title":"Microstructure","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"AnisotropicPlanarMicrostructureModel\nOrthotropicMicrostructureModel\ncreate_microstructure_model\nODB25LTMicrostructureParameters","category":"page"},{"location":"api-reference/models/#Thunderbolt.create_microstructure_model","page":"Models","title":"Thunderbolt.create_microstructure_model","text":"create_microstructure_model(coordinate_system::CoordinateSystemCoefficient, ip::VectorInterpolationCollection, parameters)\n\nCreate a rotating fiber field by deducing the circumferential direction from apicobasal and transmural gradients.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/models/#Thunderbolt.ODB25LTMicrostructureParameters","page":"Models","title":"Thunderbolt.ODB25LTMicrostructureParameters","text":"Linear transmural distribution of the microstructure with three angles to describe all reachable physiological angles.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Boundary-Conditions","page":"Models","title":"Boundary Conditions","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"RobinBC\nNormalSpringBC\nBendingSpringBC\nConstantPressureBC\nPressureFieldBC","category":"page"},{"location":"api-reference/models/#Thunderbolt.RobinBC","page":"Models","title":"Thunderbolt.RobinBC","text":"RobinBC(α, boundary_name::String)\n\nbmP(bmu) cdot bmn_0 = - alpha bmu quad textbfx in partial Omega_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.NormalSpringBC","page":"Models","title":"Thunderbolt.NormalSpringBC","text":"NormalSpringBC(kₛ boundary_name::String)\n\nbmP(bmu) cdot bmn_0 = - k_s bmu cdot n_0 quad textbfx in partial Omega_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.BendingSpringBC","page":"Models","title":"Thunderbolt.BendingSpringBC","text":"BendingSpringBC(kᵇ, boundary_name::String)\n\nbmP(bmu) cdot bmn_0 = - partial_F frac12 k_b left (cof(F) n_0 - n_0 right) quad textbfx in partial Omega_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ConstantPressureBC","page":"Models","title":"Thunderbolt.ConstantPressureBC","text":"ConstantPressureBC(p::Real, boundary_name::String)\n\nbmP(bmu) cdot bmn_0 = - p n_0 quad textbfx in partial Omega_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.PressureFieldBC","page":"Models","title":"Thunderbolt.PressureFieldBC","text":"PressureFieldBC(pressure_field, boundary_name::String)\n\nbmP(bmu) cdot bmn_0 = - k_s bmu cdot n_0 quad textbfx in partial Omega_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Solid-Mechanics","page":"Models","title":"Solid Mechanics","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"QuasiStaticModel\nExtendedHillModel\nGeneralizedHillModel\nActiveStressModel\nPK1Model\nPrestressedMechanicalModel","category":"page"},{"location":"api-reference/models/#Thunderbolt.QuasiStaticModel","page":"Models","title":"Thunderbolt.QuasiStaticModel","text":"QuasiStaticModel(displacement_sym, mechanical_model, face_models)\n\nA generic model for quasi-static mechanical problems.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ExtendedHillModel","page":"Models","title":"Thunderbolt.ExtendedHillModel","text":"ExtendedHillModel(passive_spring_model, active_spring_model, active_deformation_gradient_model,contraction_model, microstructure_model)\n\nThe extended (generalized) Hill model as proposed by Ogiermann et al. [9]. The original formulation dates back to Stålhand et al. [10] for smooth muscle tissues.\n\nIn this framework the model is formulated as an energy minimization problem with the following additively split energy:\n\nW(mathbfF mathbfF^rma) = W_rmpassive(mathbfF) + mathcalN(bmalpha)W_rmactive(mathbfFmathbfF^-rma)\n\nWhere W_rmpassive is the passive material response and W_rmactive the active response respectvely. mathcalN is the amount of formed crossbridges. We refer to the original paper [9] for more details.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.GeneralizedHillModel","page":"Models","title":"Thunderbolt.GeneralizedHillModel","text":"GeneralizedHillModel(passive_spring_model, active_spring_model, active_deformation_gradient_model,contraction_model, microstructure_model)\n\nThe generalized Hill framework as proposed by Göktepe et al. [11].\n\nIn this framework the model is formulated as an energy minimization problem with the following additively split energy:\n\nW(mathbfF mathbfF^rma) = W_rmpassive(mathbfF) + W_rmactive(mathbfFmathbfF^-rma)\n\nWhere W_rmpassive is the passive material response and W_rmactive the active response respectvely.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ActiveStressModel","page":"Models","title":"Thunderbolt.ActiveStressModel","text":"ActiveStressModel(material_model, active_stress_model, contraction_model, microstructure_model)\n\nThe active stress model as originally proposed by Guccione et al. [2].\n\nIn this framework the model is formulated via balance of linear momentum in the first Piola Kirchhoff mathbfP:\n\nmathbfP(mathbfFT^rma) = partial_mathbfF W_rmpassive(mathbfF) + mathbfP^rma(mathbfF T^rma)\n\nwhere the passive material response can be described by an energy W_rmpassive and T^rma the active tension generated by the contraction model.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.PK1Model","page":"Models","title":"Thunderbolt.PK1Model","text":"PK1Model(material, coefficient_field)\nPK1Model(material, internal_model, coefficient_field)\n\nModels the stress formulated in the 1st Piola-Kirchhoff stress tensor. If the material is energy-based, then the term is formulated as follows: $\\int{\\Omega0} P(u,s) \\cdot \\delta F dV = \\int{\\Omega0} \\partial_{F} \\psi(u,s) \\cdot \\delta \\nabla u $\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.PrestressedMechanicalModel","page":"Models","title":"Thunderbolt.PrestressedMechanicalModel","text":"PrestressedMechanicalModel(inner_model, prestress_field)\n\nModels the stress formulated in the 1st Piola-Kirchhoff stress tensor based on a multiplicative split of the deformation gradient F = F_textrme F_0 where we compute P(F_textrme) = P(F F^-1_0).\n\nPlease note that it is assumed that F^-1_0 is the quantity computed by prestress_field.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Passive-Energies","page":"Models","title":"Passive Energies","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"NullEnergyModel\nLinearSpringModel\nTransverseIsotopicNeoHookeanModel\nHolzapfelOgden2009Model\nLinYinPassiveModel\nLinYinActiveModel\nHumphreyStrumpfYinModel\nGuccione1991PassiveModel\nThunderbolt.BioNeoHookean","category":"page"},{"location":"api-reference/models/#Thunderbolt.NullEnergyModel","page":"Models","title":"Thunderbolt.NullEnergyModel","text":"A simple dummy energy with Psi = 0.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.LinearSpringModel","page":"Models","title":"Thunderbolt.LinearSpringModel","text":"A simple linear fiber spring model for testing purposes.\n\nPsi^rma = fraca^rmf2(I_e^rme-1)^2\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.TransverseIsotopicNeoHookeanModel","page":"Models","title":"Thunderbolt.TransverseIsotopicNeoHookeanModel","text":"https://onlinelibrary.wiley.com/doi/epdf/10.1002/cnm.2866\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.HolzapfelOgden2009Model","page":"Models","title":"Thunderbolt.HolzapfelOgden2009Model","text":"The well-known orthotropic material model for the passive response of cardiac tissues by Holzapfel and Ogden [12].\n\nPsi = fraca2b e^b(I_1-3) + sum_iinrmfrms fraca^i2b^i(e^b^iI_4^i - 1^2-1) + fraca^rmfs2b^rmfs(e^b^rmfsI_8^rmfs^2-1)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.LinYinPassiveModel","page":"Models","title":"Thunderbolt.LinYinPassiveModel","text":"This is the Fung-type transverse isotropic material model for the passive  response of cardiac tissue proposed by Lin and Yin [13].\n\nPsi = C_1(e^C_2(I_1-3)^2 + C_3(I_1-3)(I_4-1) + C_4(I_4-1)^2-1)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.LinYinActiveModel","page":"Models","title":"Thunderbolt.LinYinActiveModel","text":"This is the transverse isotropic material model for the active  response of cardiac tissue proposed by Lin and Yin [13].\n\nPsi=C_0 + C_1*(I_1-3)(I_4-1) + C_2(I_1-3)^2 + C_3*(I_4-1)^2 + C_3*(I_1-3) + C_5*(I_4-1)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.HumphreyStrumpfYinModel","page":"Models","title":"Thunderbolt.HumphreyStrumpfYinModel","text":"This is the transverse isotropic material model for the active  response of cardiac tissue proposed by Humphrey et al. [14].\n\nPsi = C_1(sqrtI_4-1)^2 + C_2(sqrtI_4-1)^3 + C_3(sqrtI_4-1)(I_1-3) + C_3(I_1-3)^2\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.Guccione1991PassiveModel","page":"Models","title":"Thunderbolt.Guccione1991PassiveModel","text":"An orthotropic material model for the passive myocardial tissue response by Guccione et al. [15].\n\nPsi = B^rmff E^rmff^2 + B^rmssE^rmss^2 + B^rmnnE^rmnn^2 + B^rmns(E^rmns^2+E^rmsn^2) + B^rmfs(E^rmfs^2+E^rmsf^2) + B^rmfn(E^rmfn^2+E^rmnf^2)\n\nThe default parameterization is taken from from [16].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.BioNeoHookean","page":"Models","title":"Thunderbolt.BioNeoHookean","text":"BioNeoHookean\n\nA simple isotropic Neo-Hookean model of the form\n\nPsi = alpha (barI_1-3)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Active-Energies","page":"Models","title":"Active Energies","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"SimpleActiveSpring\nActiveMaterialAdapter","category":"page"},{"location":"api-reference/models/#Thunderbolt.SimpleActiveSpring","page":"Models","title":"Thunderbolt.SimpleActiveSpring","text":"SimpleActiveSpring\n\nA simple linear fiber spring as for example found in [11].\n\nPsi^rma = fraca^rmf2(I_e^rme-1)^2\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ActiveMaterialAdapter","page":"Models","title":"Thunderbolt.ActiveMaterialAdapter","text":"A simple helper to use a passive material model as an active material for GeneralizedHillModel, ExtendedHillModel and ActiveStressModel.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Active-Deformation-Gradients","page":"Models","title":"Active Deformation Gradients","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"GMKActiveDeformationGradientModel\nGMKIncompressibleActiveDeformationGradientModel\nRLRSQActiveDeformationGradientModel","category":"page"},{"location":"api-reference/models/#Thunderbolt.GMKActiveDeformationGradientModel","page":"Models","title":"Thunderbolt.GMKActiveDeformationGradientModel","text":"The active deformation gradient formulation by Göktepe et al. [11].\n\nF^rma = (lambda^rma-1) f_0 otimes f_0\n\nI$\n\nSee also [9] for a further analysis.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.GMKIncompressibleActiveDeformationGradientModel","page":"Models","title":"Thunderbolt.GMKIncompressibleActiveDeformationGradientModel","text":"An incompressivle version of the active deformation gradient formulation by Göktepe et al. [11].\n\nF^rma = lambda^rma f_0 otimes f_0 + frac1sqrtlambda^rma(s_0 otimes s_0 + n_0 otimes n_0)\n\nSee also [9] for a further analysis.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.RLRSQActiveDeformationGradientModel","page":"Models","title":"Thunderbolt.RLRSQActiveDeformationGradientModel","text":"The active deformation gradient formulation by Rossi et al. [17].\n\nF^rma = lambda^rma f_0 otimes f_0 + (1+kappa(lambda^rma-1)) s_0 otimes s_0 + frac11+kappa(lambda^rma-1))lambda^rma n_0 otimes n_0\n\nWhere kappa geq 0 is the sheelet part.\n\nSee also [9] for a further analysis.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Active-Stresses","page":"Models","title":"Active Stresses","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"SimpleActiveStress\nPiersantiActiveStress\nGuccione1993ActiveModel","category":"page"},{"location":"api-reference/models/#Thunderbolt.SimpleActiveStress","page":"Models","title":"Thunderbolt.SimpleActiveStress","text":"A simple active stress component.\n\nT^rma = T^rmmax  Ca_rmi frac(F cdot f_0) otimes f_0F cdot f_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.PiersantiActiveStress","page":"Models","title":"Thunderbolt.PiersantiActiveStress","text":"The active stress component described by Piersanti et al. [18] (Eq. 3).\n\nT^rma = T^rmmax  Ca_rmi left(p^f frac(F cdot f_0) otimes f_0F cdot f_0 + p^rms frac(F cdot s_0) otimes s_0F cdot s_0 + p^rmn frac(F cdot n_0) otimes n_0F cdot n_0right)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.Guccione1993ActiveModel","page":"Models","title":"Thunderbolt.Guccione1993ActiveModel","text":"The active stress component as described by Guccione et al. [2].\n\nT^rma = T^rmmax  Ca_rmi (F cdot f_0) otimes f_0\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Compression","page":"Models","title":"Compression","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"NullCompressionPenalty\nSimpleCompressionPenalty\nHartmannNeffCompressionPenalty1\nHartmannNeffCompressionPenalty2\nHartmannNeffCompressionPenalty3","category":"page"},{"location":"api-reference/models/#Thunderbolt.NullCompressionPenalty","page":"Models","title":"Thunderbolt.NullCompressionPenalty","text":"A simple dummy compression model with U(I_3) = 0.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.SimpleCompressionPenalty","page":"Models","title":"Thunderbolt.SimpleCompressionPenalty","text":"A compression model with U(I_3) = beta (I_3 -1 - 2log(sqrtI_3))^a.\n\nnote: Note\nCitation missing. How is this one called in literature?\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.HartmannNeffCompressionPenalty1","page":"Models","title":"Thunderbolt.HartmannNeffCompressionPenalty1","text":"An isochoric compression model where\n\nU(I_3) = beta (I_3^b + I_3^-b -2)^a\n\nwith ab geq 1.\n\nEntry 1 from table 3 in [19].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.HartmannNeffCompressionPenalty2","page":"Models","title":"Thunderbolt.HartmannNeffCompressionPenalty2","text":"An isochoric compression model where \n\nU(I_3) = beta (sqrtI_3-1)^a\n\nwith a  1.\n\nEntry 2 from table 3 in [19].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.HartmannNeffCompressionPenalty3","page":"Models","title":"Thunderbolt.HartmannNeffCompressionPenalty3","text":"An isochoric compression model where \n\nU(I_3) = beta (I_3 - 2log(sqrtI_3) + 4log(sqrtI_3)^2))\n\nEntry 3 from table 3 in [19].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Electrophysiology","page":"Models","title":"Electrophysiology","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"Thunderbolt.TransientDiffusionModel\nThunderbolt.SteadyDiffusionModel\nMonodomainModel\nThunderbolt.ParabolicParabolicBidomainModel\nThunderbolt.ParabolicEllipticBidomainModel\nReactionDiffusionSplit","category":"page"},{"location":"api-reference/models/#Thunderbolt.TransientDiffusionModel","page":"Models","title":"Thunderbolt.TransientDiffusionModel","text":"TransientDiffusionModel(conductivity_coefficient, source_term, solution_variable_symbol)\n\nModel formulated as partial_t u = nabla cdot kappa(x) nabla u + f\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.SteadyDiffusionModel","page":"Models","title":"Thunderbolt.SteadyDiffusionModel","text":"SteadyDiffusionModel(conductivity_coefficient, source_term, solution_variable_symbol)\n\nModel formulated as nabla cdot kappa(x) nabla u = f\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.MonodomainModel","page":"Models","title":"Thunderbolt.MonodomainModel","text":"Simplification of the bidomain model with the structure\n\nχCₘ∂ₜφₘ = ∇⋅κ∇φₘ + χ(Iᵢₒₙ(φₘ,𝐬) + Iₛₜᵢₘ(t))     ∂ₜ𝐬  = g(φₘ,𝐬)\n\n(TODO citation). Can be derived through the assumption (TODO), but also when the assumption is violated we can construct optimal κ (TODO citation+example) for the reconstruction of φₘ.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ParabolicParabolicBidomainModel","page":"Models","title":"Thunderbolt.ParabolicParabolicBidomainModel","text":"The original model formulation (TODO citation) with the structure\n\nχCₘ∂ₜφₘ = ∇⋅κᵢ∇φᵢ + χ(Iᵢₒₙ(φₘ,𝐬,x) + Iₛₜᵢₘ,ᵢ(x,t))  χCₘ∂ₜφₘ = ∇⋅κₑ∇φₑ - χ(Iᵢₒₙ(φₘ,𝐬,x) + Iₛₜᵢₘ,ₑ(x,t))     ∂ₜ𝐬  = g(φₘ,𝐬,x)  φᵢ - φₑ = φₘ\n\nwarn: Warn\nNot implemented yet.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ParabolicEllipticBidomainModel","page":"Models","title":"Thunderbolt.ParabolicEllipticBidomainModel","text":"Transformed bidomain model with the structure\n\nχCₘ∂ₜφₘ = ∇⋅κᵢ∇φₘ + ∇⋅κᵢ∇φₑ      + χ(Iᵢₒₙ(φₘ,𝐬,x) + Iₛₜᵢₘ(x,t))       0  = ∇⋅κᵢ∇φₘ + ∇⋅(κᵢ+κₑ)∇φₑ +  Iₛₜᵢₘ,ₑ(t) - Iₛₜᵢₘ,ᵢ(t)     ∂ₜ𝐬  = g(φₘ,𝐬,x)       φᵢ = φₘ + φₑ\n\nThis formulation is a transformation of the parabolic-parabolic form (c.f. TODO citation) and has been derived by (TODO citation) first.\n\nwarn: Warn\nNot implemented yet.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ReactionDiffusionSplit","page":"Models","title":"Thunderbolt.ReactionDiffusionSplit","text":"ReactionDiffusionSplit(model)\nReactionDiffusionSplit(model, coeff)\n\nAnnotation for the classical reaction-diffusion split of a given model. The second argument is a coefficient describing the input x for the reaction model rhs, which is usually some generalized coordinate.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"NoStimulationProtocol\nTransmembraneStimulationProtocol\nAnalyticalTransmembraneStimulationProtocol","category":"page"},{"location":"api-reference/models/#Thunderbolt.NoStimulationProtocol","page":"Models","title":"Thunderbolt.NoStimulationProtocol","text":"A dummy protocol describing the absence of stimuli for a simulation.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.TransmembraneStimulationProtocol","page":"Models","title":"Thunderbolt.TransmembraneStimulationProtocol","text":"Supertype for all stimulation protocols fulfilling I_rmstime = I_rmstimi.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.AnalyticalTransmembraneStimulationProtocol","page":"Models","title":"Thunderbolt.AnalyticalTransmembraneStimulationProtocol","text":"Describe the transmembrane stimulation by some analytical function on a given set of time intervals.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Cells","page":"Models","title":"Cells","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"warning: Warning\nThese are intended to be replaced by ModelingToolkit analogues!","category":"page"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"Thunderbolt.ParametrizedFHNModel\nThunderbolt.ParametrizedPCG2019Model","category":"page"},{"location":"api-reference/models/#Thunderbolt.ParametrizedFHNModel","page":"Models","title":"Thunderbolt.ParametrizedFHNModel","text":"The classical neuron electrophysiology model independently found by FitzHugh [20] and Nagumo et al. [21]. This model is less stiff and cheaper than any cardiac electrophysiology model, which maks it  a good choice for quick testing if things work at all.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.ParametrizedPCG2019Model","page":"Models","title":"Thunderbolt.ParametrizedPCG2019Model","text":"The canine ventricular cardiomyocyte electrophysiology model by Pathmanathan et al. [22].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Fluid-Mechanics","page":"Models","title":"Fluid Mechanics","text":"","category":"section"},{"location":"api-reference/models/#Lumped-Models","page":"Models","title":"Lumped Models","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"Thunderbolt.DummyLumpedCircuitModel\nMTKLumpedCicuitModel\nRSAFDQ2022LumpedCicuitModel","category":"page"},{"location":"api-reference/models/#Thunderbolt.DummyLumpedCircuitModel","page":"Models","title":"Thunderbolt.DummyLumpedCircuitModel","text":"Keep the volume at a certain level.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.MTKLumpedCicuitModel","page":"Models","title":"Thunderbolt.MTKLumpedCicuitModel","text":"MTKLumpedCicuitModel\n\nA lumped (0D) circulatory model for LV simulations as presented in Regazzoni et al. [3].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.RSAFDQ2022LumpedCicuitModel","page":"Models","title":"Thunderbolt.RSAFDQ2022LumpedCicuitModel","text":"RSAFDQ2022LumpedCicuitModel\n\nA lumped (0D) circulatory model for LV simulations as presented in Regazzoni et al. [3].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Multiphysics","page":"Models","title":"Multiphysics","text":"","category":"section"},{"location":"api-reference/models/#Generic-Interface","page":"Models","title":"Generic Interface","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"Thunderbolt.InterfaceCoupler\nThunderbolt.VolumeCoupler\nCoupling\nCoupledModel","category":"page"},{"location":"api-reference/models/#Thunderbolt.InterfaceCoupler","page":"Models","title":"Thunderbolt.InterfaceCoupler","text":"Abstract supertype for all interface coupling schemes.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.VolumeCoupler","page":"Models","title":"Thunderbolt.VolumeCoupler","text":"Abstract supertype for all volume coupling schemes.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.Coupling","page":"Models","title":"Thunderbolt.Coupling","text":"Helper to describe the coupling between problems.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.CoupledModel","page":"Models","title":"Thunderbolt.CoupledModel","text":"A descriptor for a coupled model.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#FSI","page":"Models","title":"FSI","text":"","category":"section"},{"location":"api-reference/models/","page":"Models","title":"Models","text":"LumpedFluidSolidCoupler\nHirschvogel2017SurrogateVolume\nRSAFDQ2022SurrogateVolume\nRSAFDQ2022Split\nRSAFDQ2022Model","category":"page"},{"location":"api-reference/models/#Thunderbolt.LumpedFluidSolidCoupler","page":"Models","title":"Thunderbolt.LumpedFluidSolidCoupler","text":"Enforce the constraints that   chamber volume 3D (solid model) = chamber volume 0D (lumped circuit) via Lagrange multiplied, where a surface pressure integral is introduced such that   ∫  ∂Ωendo Here chamber_volume_method is responsible to compute the 3D volume.\n\nThis approach has been proposed by Regazzoni et al. [3].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.Hirschvogel2017SurrogateVolume","page":"Models","title":"Thunderbolt.Hirschvogel2017SurrogateVolume","text":"Chamber volume estimator as presented in [23].\n\nCompute the chamber volume as a surface integral via the integral\n\n∫ (x + d) det(F) cof(F) N ∂Ωendo\n\nwhere it is assumed that the chamber is convex, zero displacement in apicobasal direction at the valvular plane occurs and the plane normal is aligned with the z axis, where the origin is at z=0.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.RSAFDQ2022SurrogateVolume","page":"Models","title":"Thunderbolt.RSAFDQ2022SurrogateVolume","text":"Compute the chamber volume as a surface integral via the integral   -∫ det(F) ((h ⊗ h)(x + d - b)) adj(F) N ∂Ωendo\n\nas proposed by Regazzoni et al. [3].\n\nnote: Note\nThis integral basically measures the volume via displacement on a given axis.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.RSAFDQ2022Split","page":"Models","title":"Thunderbolt.RSAFDQ2022Split","text":"Annotation for the split described by Regazzoni et al. [3].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/models/#Thunderbolt.RSAFDQ2022Model","page":"Models","title":"Thunderbolt.RSAFDQ2022Model","text":"The split model described by Regazzoni et al. [3] alone.\n\n\n\n\n\n","category":"type"},{"location":"topics/couplers/#Couplers","page":"Couplers","title":"Couplers","text":"","category":"section"},{"location":"topics/couplers/","page":"Couplers","title":"Couplers","text":"Many multiphysics problems can be described by having individual physics + coupling terms. Couplers act as the abstraction layer to describe these terms.","category":"page"},{"location":"topics/couplers/","page":"Couplers","title":"Couplers","text":"More detailed information coming soon...","category":"page"},{"location":"tutorials/ep03_bidomain/","page":"EP03: Defibrillation (TODO)","title":"EP03: Defibrillation (TODO)","text":"EditURL = \"../literate-tutorials/ep03_bidomain.jl\"","category":"page"},{"location":"tutorials/ep03_bidomain/#ep-tutorial_defibrillation","page":"EP03: Defibrillation (TODO)","title":"Electrophysiology Tutorial 3: Defibrillation with Bidomain Models","text":"","category":"section"},{"location":"tutorials/ep03_bidomain/","page":"EP03: Defibrillation (TODO)","title":"EP03: Defibrillation (TODO)","text":"todo: Todo\nShow ECG and shock.","category":"page"},{"location":"tutorials/ep03_bidomain/","page":"EP03: Defibrillation (TODO)","title":"EP03: Defibrillation (TODO)","text":"This tutorial shows how to setup Bidomain models and how to induce Spitzenumkehrtachykardie.","category":"page"},{"location":"tutorials/ep03_bidomain/","page":"EP03: Defibrillation (TODO)","title":"EP03: Defibrillation (TODO)","text":"todo: Todo\nProvide context.","category":"page"},{"location":"tutorials/ep03_bidomain/#Commented-Program","page":"EP03: Defibrillation (TODO)","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/ep03_bidomain/","page":"EP03: Defibrillation (TODO)","title":"EP03: Defibrillation (TODO)","text":"todo: Todo\nImplement bidomain model. Should be quite easy. We should also showcase subdomain managmeent and some ECG here.","category":"page"},{"location":"tutorials/ep03_bidomain/#References","page":"EP03: Defibrillation (TODO)","title":"References","text":"","category":"section"},{"location":"tutorials/ep03_bidomain/","page":"EP03: Defibrillation (TODO)","title":"EP03: Defibrillation (TODO)","text":"","category":"page"},{"location":"tutorials/ep03_bidomain/#ep-tutorial_bidomain-plain-program","page":"EP03: Defibrillation (TODO)","title":"Plain program","text":"","category":"section"},{"location":"tutorials/ep03_bidomain/","page":"EP03: Defibrillation (TODO)","title":"EP03: Defibrillation (TODO)","text":"Here follows a version of the program without any comments. The file is also available here: ep03_bidomain.jl.","category":"page"},{"location":"tutorials/ep03_bidomain/","page":"EP03: Defibrillation (TODO)","title":"EP03: Defibrillation (TODO)","text":"","category":"page"},{"location":"tutorials/ep03_bidomain/","page":"EP03: Defibrillation (TODO)","title":"EP03: Defibrillation (TODO)","text":"","category":"page"},{"location":"tutorials/ep03_bidomain/","page":"EP03: Defibrillation (TODO)","title":"EP03: Defibrillation (TODO)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"EditURL = \"../literate-howto/custom-ep-cell-model.jl\"","category":"page"},{"location":"howto/custom-ep-cell-model/#how-to-custom-ep-cell-model","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"","category":"section"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"using Thunderbolt","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"We first need to define a struct holding all the parameters. If you want to have parameters with spatial variation, which can be exchanged easily, then simply add a field with custom type and a function which accepts a coordinate x and a time t as input, as for example here for the parameter e:","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"tip: Tip\nParametrize the cell model parameters with the used float type to easily change precision for GPU simulations, as some GPUs perform very bad with Float64.","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"Base.@kwdef struct HeterogeneousFHNModel{T, T2} <: Thunderbolt.AbstractIonicModel\n    a::T = T(0.1)\n    b::T = T(0.5)\n    c::T = T(1.0)\n    d::T = T(0.0)\n    e::T2 = (x,t)->0.01\nend\nHeterogeneousFHNModel(::Type{T}, e::F) where {T,F} = HeterogeneousFHNModel{T,F}(0.1,0.5,1.0,0.0,e)","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"We now need to dispatch all functions of the cell EP API. First we need to give an index for the transmembrane potential, which we e.g. need for operator splitting methods and during post-processing.","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"Thunderbolt.transmembranepotential_index(cell_model::HeterogeneousFHNModel) = 1","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"Now we need the number of state variables in the model. Here we have only a single internal state s.","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"Thunderbolt.num_states(::HeterogeneousFHNModel) = 1","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"For convenience, we should dispatch this function which contains some admissible initial state for the model in its default parametrization.","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"Thunderbolt.default_initial_state(::HeterogeneousFHNModel) = [0.0, 0.0]","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"Finally we also need to provide the right hand side of the model. The API is similar to what we have in SciML, but we have one additional input x. x contains spatial information to distinguish individual cells, allowing spatial gradients of cellular behavior. If no spatial information is provded, then x === nothing. Usually the types for x are either Vec{sdim}, if the coordinate is carthesian, or some generalized coordinate. Please consult the coordinate system API docs for more details.","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"note: Note\nYou may have noticed that all inputs are parametrized. This seems to be necessary to force specialization for the GPU code – removing the type parameters leads to cryptic CUDA.jl errors.","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"function Thunderbolt.cell_rhs!(du::TD,u::TU,x::TX,t::TT,p::TP) where {TD,TU,TX,TT,TP <: HeterogeneousFHNModel}\n    # Flatten out parameters ...\n    (;a,b,c,d) = p\n    # ... and the state variables\n    φₘ = u[1]\n    s  = u[2]\n    # Now we assign the rates.\n    du[1] = φₘ*(1-φₘ)*(φₘ-a) - s\n    du[2] = p.e(x,t)*(b*φₘ - c*s - d)\n    # Return nothing so no oopsies happen. :)\n    return nothing\nend","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"todo: Todo\nShow how users can control which the coordiante system information is passed into the cell model.","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"","category":"page"},{"location":"howto/custom-ep-cell-model/","page":"Adding EP Cell Models","title":"Adding EP Cell Models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"EditURL = \"../literate-tutorials/cm03_3d0d-coupling.jl\"","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/#mechanics-tutorial_3d0dcoupling","page":"CM03: 0D Blood Circuit","title":"Mechanics Tutorial 3: Coupling with Lumped Blood Circuits","text":"","category":"section"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"(Image: Pressure Volume Loop)","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"This tutorial shows how to couple 3d chamber models with 0d fluid models.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/#Introduction","page":"CM03: 0D Blood Circuit","title":"Introduction","text":"","category":"section"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"In this tutorial we will reproduce a simplified version of the model presented by Regazzoni et al. [3].","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"warning: Warning\nThe API for 3D-0D coupling is work in progress and is hence subject to potential breaking changes.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/#Commented-Program","page":"CM03: 0D Blood Circuit","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"We start by loading Thunderbolt and LinearSolve to use a custom direct solver of our choice.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"using Thunderbolt, LinearSolve","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"Furthermore we will use CirculatorySystemModels to define the blood circuit model.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"using CirculatorySystemModels","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"Finally, we try to approach a valid initial state by solving a simpler model first.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"using ModelingToolkit, OrdinaryDiffEqTsit5","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"We start by defining a MTK component to couple the circuit model with Thunderbolt.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"@component function PressureCouplingChamber(;name)\n    @named in = CirculatorySystemModels.Pin()\n    @named out = CirculatorySystemModels.Pin()\n    sts = @variables begin\n        V(t) = 0.0#, [description = \"Volume of the lumped 0D chamber\"]\n        p(t)\n    end\n    ps = @parameters begin\n        p3D(t), [description = \"Pressure of the associated 3D chamber\"]\n    end\n\n    D = Differential(t)\n\n    eqs = [\n        0 ~ in.p - out.p\n        p ~ in.p\n        p ~ p3D\n        D(V) ~ in.q + out.q\n    ]\n\n    compose(ODESystem(eqs, t, sts, ps; name=name), in, out)\nend;\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"Regazzoni et al. [3] use a leaky diode for the heart valves, which is not part of CirculatorySystemModels.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"@component function LeakyResistorDiode(;name, Rₘᵢₙ, Rₘₐₓ)\n    @named oneport = CirculatorySystemModels.OnePort()\n    @unpack Δp, q = oneport\n    ps = @parameters Rₘᵢₙ = Rₘᵢₙ Rₘₐₓ = Rₘₐₓ\n    eqs = [\n        q ~ - (Δp / Rₘᵢₙ * (Δp < 0) + Δp / Rₘₐₓ * (Δp ≥ 0))\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend;\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"These are the parameters from the paper [3]","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"τ = 1.0e3\n#\nRsysₐᵣ  = (0.8e3)\nRpulₐᵣ  = (0.1625e3)\nRsysᵥₑₙ = (0.26e3)\nRpulᵥₑₙ = (0.1625e3)\n#\nCsysₐᵣ  = (1.2)\nCpulₐᵣ  = (10.0)\nCsysᵥₑₙ = (60.0)\nCpulᵥₑₙ = (16.0)\n#\nLsysₐᵣ  = (5e3)\nLpulₐᵣ  = (5e2)\nLsysᵥₑₙ = (5e2)\nLpulᵥₑₙ = (5e2)\n# Valve stuff\nRmin = (0.0075e3)\nRmax = (75000.0e3)\n# Passive elastance\nEpassₗₐ = (0.15)\nEpassᵣₐ = (0.15)\nEpassᵣᵥ = (0.1)\n# Active elastance\nEactmaxₗₐ = (0.1)\nEactmaxᵣₐ = (0.1)\nEactmaxᵣᵥ = (1.4)\n# \"Initial volume\"\nV0ₗₐ = (4.0)\nV0ᵣₐ = (4.0)\nV0ᵣᵥ = (10.0)\n# Event timings\ntCₗₐ = (0.6e3)\nTCₗₐ = (0.104e3)\nTRₗₐ = (0.68e3)\nTRᵣₐ = (0.56e3)\ntCᵣₐ = (0.064e3)\nTCᵣₐ = (0.64e3)\ntCᵣᵥ = (0.0e3)\nTCᵣᵥ = (0.272e3)\nTRᵣᵥ = (0.12e3)","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"τ = (0.8e3)","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"# Extra parameters to emulate the LV\nV0ₗᵥ = (5.0)\nEpassₗᵥ = (0.125)\nEactmaxₗᵥ = (2.4)\nTCₗᵥ = (0.30e3)\nTRₗᵥ = (0.15e3)\n\nEshiftᵣᵥ = 0.0\nEshiftₗₐ = 1.0-tCₗₐ/τ\nEshiftᵣₐ = 1.0-tCᵣₐ/τ\n\nLV_Vt0 = 500.0\nRV_Vt0 = 500.0\nLA_Vt0 = 20.0\nRA_Vt0 = 20.0","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"todo: Todo\nI made some unit conversion error somewhere here. This needs to be fixed.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"We now setup the model for the initial state","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"# Start Modelling\n@independent_variables t\n\n# Atria and ventricles\n@named LV = ShiChamber(V₀=V0ₗᵥ, p₀=0.0, Eₘᵢₙ=Epassₗᵥ, Eₘₐₓ=Epassₗᵥ+Eactmaxₗᵥ, τ=τ, τₑₛ=TCₗᵥ, τₑₚ=TCₗᵥ+TRₗᵥ, Eshift=0.0)\n@named LA = ShiChamber(V₀=V0ₗₐ, p₀=0.0, Eₘᵢₙ=Epassₗₐ, Eₘₐₓ=Epassₗₐ+Eactmaxₗₐ, τ=τ, τₑₛ=TCₗₐ, τₑₚ=TCₗₐ+TRₗₐ, Eshift=Eshiftₗₐ)\n@named RV = ShiChamber(V₀=V0ᵣᵥ, p₀=0.0, Eₘᵢₙ=Epassᵣᵥ, Eₘₐₓ=Epassᵣᵥ+Eactmaxᵣᵥ, τ=τ, τₑₛ=TCᵣᵥ, τₑₚ=TCᵣᵥ+TRᵣᵥ, Eshift=0.0)\n@named RA = ShiChamber(V₀=V0ᵣₐ, p₀=0.0, Eₘᵢₙ=Epassᵣₐ, Eₘₐₓ=Epassᵣₐ+Eactmaxᵣₐ, τ=τ, τₑₛ=TCᵣₐ, τₑₚ=TCₗₐ+TRₗₐ, Eshift=Eshiftᵣₐ)\n\n# Valves as leaky diodes\n@named AV = LeakyResistorDiode(Rₘᵢₙ = Rmin, Rₘₐₓ = Rmax)\n@named MV = LeakyResistorDiode(Rₘᵢₙ = Rmin, Rₘₐₓ = Rmax)\n@named TV = LeakyResistorDiode(Rₘᵢₙ = Rmin, Rₘₐₓ = Rmax)\n@named PV = LeakyResistorDiode(Rₘᵢₙ = Rmin, Rₘₐₓ = Rmax)\n\n####### Systemic Loop #######\n# Systemic Artery ##\n@named SYSAR = CRL(C=Csysₐᵣ, R=Rsysₐᵣ, L=Lsysₐᵣ)\n# Systemic Vein ##\n@named SYSVEN = CRL(C=Csysᵥₑₙ, R=Rsysᵥₑₙ, L=Lsysᵥₑₙ)\n\n####### Pulmonary Loop #######\n# Pulmonary Artery ##\n@named PULAR = CRL(C=Cpulₐᵣ, R=Rpulₐᵣ, L=Lpulₐᵣ)\n# Pulmonary Vein ##\n@named PULVEN = CRL(C=Cpulᵥₑₙ, R=Rpulᵥₑₙ, L=Lpulᵥₑₙ)\n\n#\ncirc_eqs_init = [\n    connect(LV.out, AV.in)\n    connect(AV.out, SYSAR.in)\n    connect(SYSAR.out, SYSVEN.in)\n    connect(SYSVEN.out, RA.in)\n    connect(RA.out, TV.in)\n    connect(TV.out, RV.in)\n    connect(RV.out, PV.in)\n    connect(PV.out,  PULAR.in)\n    connect(PULAR.out, PULVEN.in)\n    connect(PULVEN.out, LA.in)\n    connect(LA.out, MV.in)\n    connect(MV.out, LV.in)\n]\n\n# Compose the whole ODE system\n@named _circ_model_init = ODESystem(circ_eqs_init, t)\n@named circ_model_init = compose(_circ_model_init,\n    [LV, RV, LA, RA, AV, MV, PV, TV, SYSAR, SYSVEN, PULAR, PULVEN])\n\n# And simplify it\ncirc_sys_init = structural_simplify(circ_model_init)\n\n# Setup ODE with reasonable initial guess\nu0 = [\n    LV.V => LV_Vt0\n    RV.V => RV_Vt0\n    RA.V => RA_Vt0\n    LA.V => LA_Vt0\n    SYSAR.C.V => 100.0 * Csysₐᵣ\n    SYSAR.L.q => 0.0\n    SYSVEN.C.V => 0.0\n    SYSVEN.L.q => 0.0\n    PULAR.C.V => 30.0 * Cpulₐᵣ\n    PULAR.L.q => 0.0\n    PULVEN.C.V => 0.0\n    PULVEN.L.q => 0.0\n];\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"Simulate the full 0D model for a few heat beats using Tsit5.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"prob = OrdinaryDiffEqTsit5.ODEProblem(circ_sys_init, u0, (0.0, 20.0e3))","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"todo: Todo\nOnce Thudnerbolt is compatible with OrdinaryDiffEq we should remove the namespacing here.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"@time circ_sol_init = solve(prob, Tsit5(), reltol=1e-9, abstol=1e-12, saveat=18e3:0.01e3:20e3);\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"tip: Tip\nWe can visualize the last pressure-volume loop as follows with GLMakieusing GLMakie\nf = Figure()\naxs = [\n    Axis(f[1, 1], title=\"LV\"),\n    Axis(f[1, 2], title=\"RV\"),\n    Axis(f[2, 1], title=\"LA\"),\n    Axis(f[2, 2], title=\"RA\")\n]\n\nlines!(axs[1], circ_sol_init[LV.V], circ_sol_init[LV.p])\nlines!(axs[2], circ_sol_init[RV.V], circ_sol_init[RV.p])\nlines!(axs[3], circ_sol_init[LA.V], circ_sol_init[LA.p])\nlines!(axs[4], circ_sol_init[RA.V], circ_sol_init[RA.p])","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"With the solution we now extract the initial guess for the full problem.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"u0new = copy(circ_sol_init.u[end]);\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"todo: Todo\nThis is illegal. Figure out how to do the transfer correctly.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"Now that we have a sensible initial guess we build actual 3d-0d coupled system For this, we first instantiate the coupling component","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"@named LVc = PressureCouplingChamber();\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"and connect it with the other equations","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"circ_eqs = [\n    connect(LVc.out, AV.in)\n    connect(AV.out, SYSAR.in)\n    connect(SYSAR.out, SYSVEN.in)\n    connect(SYSVEN.out, RA.in)\n    connect(RA.out, TV.in)\n    connect(TV.out, RV.in)\n    connect(RV.out, PV.in)\n    connect(PV.out,  PULAR.in)\n    connect(PULAR.out, PULVEN.in)\n    connect(PULVEN.out, LA.in)\n    connect(LA.out, MV.in)\n    connect(MV.out, LVc.in)\n];\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"Now we compose the whole ODE system first","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"@named _circ_model = ODESystem(circ_eqs, t)\n@named circ_model = compose(_circ_model,\n    [LVc, RV, LA, RA, AV, MV, PV, TV, SYSAR, SYSVEN, PULAR, PULVEN])\ncirc_sys = structural_simplify(circ_model);\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"We now generate the mechanical subproblem as in the first tutorial","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"scaling_factor = 3.0;\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"warning: Warning\nTuning parameter until all bugs are fixed in this tutorial :)","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"mesh = generate_ideal_lv_mesh(8,2,5;\n    inner_radius = scaling_factor*0.7,\n    outer_radius = scaling_factor*1.0,\n    longitudinal_upper = scaling_factor*0.2,\n    apex_inner = scaling_factor* 1.3,\n    apex_outer = scaling_factor*1.5\n)\nmesh = Thunderbolt.hexahedralize(mesh)","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"todo: Todo\nThe 3D0D coupling does not yet support multiple subdomains.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"coordinate_system = compute_lv_coordinate_system(mesh)\nmicrostructure    = create_microstructure_model(\n    coordinate_system,\n    LagrangeCollection{1}()^3,\n    ODB25LTMicrostructureParameters(),\n);\npassive_material_model = Guccione1991PassiveModel()\nactive_material_model  = Guccione1993ActiveModel()\nfunction calcium_profile_function(x::LVCoordinate,t)\n    linear_interpolation(t,y1,y2,t1,t2) = y1 + (t-t1) * (y2-y1)/(t2-t1)\n    ca_peak(x)                          = 1.0\n    if 0 ≤ t ≤ 300.0\n        return linear_interpolation(t,        0.0, ca_peak(x),   0.0, 300.0)\n    elseif t ≤ 500.0\n        return linear_interpolation(t, ca_peak(x),        0.0, 300.0, 500.0)\n    else\n        return 0.0\n    end\nend\ncalcium_field = AnalyticalCoefficient(\n    calcium_profile_function,\n    coordinate_system,\n)\nsarcomere_model = CaDrivenInternalSarcomereModel(ConstantStretchModel(), calcium_field)\nactive_stress_model = ActiveStressModel(\n    passive_material_model,\n    active_material_model,\n    sarcomere_model,\n    microstructure,\n)\nweak_boundary_conditions = (NormalSpringBC(1.0, \"Epicardium\"),)\nsolid_model = QuasiStaticModel(:displacement, active_stress_model, weak_boundary_conditions);\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"The solid model is now couple with the circuit model by adding a Lagrange multipliers constraining the 3D chamber volume to match the chamber volume in the 0D model.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"p3D = LVc.p3D\nV0D = LVc.V\nfluid_model = MTKLumpedCicuitModel(circ_sys, u0new, [p3D])\ncoupler = LumpedFluidSolidCoupler(\n    [\n        ChamberVolumeCoupling(\n            \"Endocardium\",\n            RSAFDQ2022SurrogateVolume(),\n            V0D\n        )\n    ],\n    :displacement,\n)\ncoupled_model = RSAFDQ2022Model(solid_model,fluid_model,coupler);\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"todo: Todo\nOnce we figure out a nicer way to do this we should add more detailed docs here.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"Now we semidiscretize the model spatially as usual with finite elements and annotate the model with a stable split.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"spatial_discretization_method = FiniteElementDiscretization(\n    Dict(:displacement => LagrangeCollection{1}()^3),\n    [\n        Dirichlet(:displacement, getfacetset(mesh, \"Base\"), (x,t) -> [0.0], [3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor1\"), (x,t) -> (0.0, 0.0, 0.0), [1,2,3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor2\"), (x,t) -> (0.0, 0.0), [2,3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor3\"), (x,t) -> (0.0,), [3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor4\"), (x,t) -> (0.0,), [3])\n    ],\n)\nsplitform = semidiscretize(\n    RSAFDQ2022Split(coupled_model),\n    spatial_discretization_method,\n    mesh,\n)\n\ndt₀ = 1.0\ndtvis = 5.0\ntspan = (0.0, 1000.0)","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"This speeds up the CI # hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"tspan = (0.0, dtvis)    # hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"The remaining code is very similar to how we use SciML solvers.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"chamber_solver = HomotopyPathSolver(\n    NewtonRaphsonSolver(;\n        max_iter=10,\n        tol=1e-2,\n        inner_solver=SchurComplementLinearSolver(\n            LinearSolve.UMFPACKFactorization()\n        )\n    )\n)\nblood_circuit_solver = ForwardEulerSolver(rate=ceil(Int, dt₀/0.001)) # Force time step to about 0.001\ntimestepper = LieTrotterGodunov((chamber_solver, blood_circuit_solver))\n\nu₀ = zeros(solution_size(splitform))\nu₀[OS.get_dofrange(splitform, 2)] .= u0new;\nnothing #hide","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"todo: Todo\nHow to map this correctly? If I understand correctly, then there is no guarantee that the states match.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"problem = OperatorSplittingProblem(splitform, u₀, tspan)\nintegrator = init(problem, timestepper, dt=dt₀, verbose=true);\n\n\n# f2 = Figure()\n# axs = [\n#     Axis(f2[1, 1], title=\"LV\"),\n#     Axis(f2[1, 2], title=\"RV\"),\n#     Axis(f2[2, 1], title=\"LA\"),\n#     Axis(f2[2, 2], title=\"RA\")\n# ]\n\n# vlv = Observable(Float64[])\n# plv = Observable(Float64[])\n\n# vrv = Observable(Float64[])\n# prv = Observable(Float64[])\n\n# vla = Observable(Float64[])\n# pla = Observable(Float64[])\n\n# vra = Observable(Float64[])\n# pra = Observable(Float64[])\n\n# lines!(axs[1], vlv, plv)\n# lines!(axs[2], vrv, prv)\n# lines!(axs[3], vla, pla)\n# lines!(axs[4], vra, pra)\n# for i in 1:4\n#     xlims!(axs[1], 0.0, 180.0)\n#     ylims!(axs[1], 0.0, 180.0)\n# end\n# display(f2)","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"todo: Todo\nrecover online visualization of the pressure volume loop","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"todo: Todo\nThe post-processing API is not yet finished. Please revisit the tutorial later to see how to post-process the simulation online. Right now the solution is just exported into VTK, such that users can visualize the solution in e.g. ParaView.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"Now we can finally solve the coupled problem in time.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"io = ParaViewWriter(\"CM03_3d0d-coupling\");\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    chamber_function = OS.get_operator(splitform, 1)\n    (; dh) = chamber_function.structural_function\n    store_timestep!(io, t, dh.grid)\n    Thunderbolt.store_timestep_field!(io, t, dh, u[1:ndofs(dh)], :displacement) # TODO allow views\n    Thunderbolt.finalize_timestep!(io, t)\n\n    # if t > 0.0\n    #     lv = chamber_function.tying_info.chambers[1]\n    #     append!(vlv.val, lv.V⁰ᴰval)\n    #     append!(plv.val, u[lv.pressure_dof_index_global])\n    #     notify(vlv)\n    #     notify(plv)\n    # end\n    # TODO plot other chambers\nend","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"tip: Tip\nIf you want to see more details of the solution process launch Julia with Thunderbolt as debug module:JULIA_DEBUG=Thunderbolt julia --project --threads=auto my_simulation_runner.jl","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/#References","page":"CM03: 0D Blood Circuit","title":"References","text":"","category":"section"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"F. Regazzoni, M. Salvador, P. C. Africa, M. Fedele, L. Dedè and A. Quarteroni. A cardiac electromechanical model coupled with a lumped-parameter model for closed-loop blood circulation. Journal of Computational Physics 457, 111083 (2022).\n\n\n\n","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/#mechanics-tutorial_3d0dcoupling-plain-program","page":"CM03: 0D Blood Circuit","title":"Plain program","text":"","category":"section"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"Here follows a version of the program without any comments. The file is also available here: cm03_3d0d-coupling.jl.","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"using Thunderbolt, LinearSolve\n\nusing CirculatorySystemModels\n\nusing ModelingToolkit, OrdinaryDiffEqTsit5\n\n@component function PressureCouplingChamber(;name)\n    @named in = CirculatorySystemModels.Pin()\n    @named out = CirculatorySystemModels.Pin()\n    sts = @variables begin\n        V(t) = 0.0#, [description = \"Volume of the lumped 0D chamber\"]\n        p(t)\n    end\n    ps = @parameters begin\n        p3D(t), [description = \"Pressure of the associated 3D chamber\"]\n    end\n\n    D = Differential(t)\n\n    eqs = [\n        0 ~ in.p - out.p\n        p ~ in.p\n        p ~ p3D\n        D(V) ~ in.q + out.q\n    ]\n\n    compose(ODESystem(eqs, t, sts, ps; name=name), in, out)\nend;\n\n@component function LeakyResistorDiode(;name, Rₘᵢₙ, Rₘₐₓ)\n    @named oneport = CirculatorySystemModels.OnePort()\n    @unpack Δp, q = oneport\n    ps = @parameters Rₘᵢₙ = Rₘᵢₙ Rₘₐₓ = Rₘₐₓ\n    eqs = [\n        q ~ - (Δp / Rₘᵢₙ * (Δp < 0) + Δp / Rₘₐₓ * (Δp ≥ 0))\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend;\n\nτ = 1.0e3\n#\nRsysₐᵣ  = (0.8e3)\nRpulₐᵣ  = (0.1625e3)\nRsysᵥₑₙ = (0.26e3)\nRpulᵥₑₙ = (0.1625e3)\n#\nCsysₐᵣ  = (1.2)\nCpulₐᵣ  = (10.0)\nCsysᵥₑₙ = (60.0)\nCpulᵥₑₙ = (16.0)\n#\nLsysₐᵣ  = (5e3)\nLpulₐᵣ  = (5e2)\nLsysᵥₑₙ = (5e2)\nLpulᵥₑₙ = (5e2)\n# Valve stuff\nRmin = (0.0075e3)\nRmax = (75000.0e3)\n# Passive elastance\nEpassₗₐ = (0.15)\nEpassᵣₐ = (0.15)\nEpassᵣᵥ = (0.1)\n# Active elastance\nEactmaxₗₐ = (0.1)\nEactmaxᵣₐ = (0.1)\nEactmaxᵣᵥ = (1.4)\n# \"Initial volume\"\nV0ₗₐ = (4.0)\nV0ᵣₐ = (4.0)\nV0ᵣᵥ = (10.0)\n# Event timings\ntCₗₐ = (0.6e3)\nTCₗₐ = (0.104e3)\nTRₗₐ = (0.68e3)\nTRᵣₐ = (0.56e3)\ntCᵣₐ = (0.064e3)\nTCᵣₐ = (0.64e3)\ntCᵣᵥ = (0.0e3)\nTCᵣᵥ = (0.272e3)\nTRᵣᵥ = (0.12e3)\n\n# Extra parameters to emulate the LV\nV0ₗᵥ = (5.0)\nEpassₗᵥ = (0.125)\nEactmaxₗᵥ = (2.4)\nTCₗᵥ = (0.30e3)\nTRₗᵥ = (0.15e3)\n\nEshiftᵣᵥ = 0.0\nEshiftₗₐ = 1.0-tCₗₐ/τ\nEshiftᵣₐ = 1.0-tCᵣₐ/τ\n\nLV_Vt0 = 500.0\nRV_Vt0 = 500.0\nLA_Vt0 = 20.0\nRA_Vt0 = 20.0\n\n# Start Modelling\n@independent_variables t\n\n# Atria and ventricles\n@named LV = ShiChamber(V₀=V0ₗᵥ, p₀=0.0, Eₘᵢₙ=Epassₗᵥ, Eₘₐₓ=Epassₗᵥ+Eactmaxₗᵥ, τ=τ, τₑₛ=TCₗᵥ, τₑₚ=TCₗᵥ+TRₗᵥ, Eshift=0.0)\n@named LA = ShiChamber(V₀=V0ₗₐ, p₀=0.0, Eₘᵢₙ=Epassₗₐ, Eₘₐₓ=Epassₗₐ+Eactmaxₗₐ, τ=τ, τₑₛ=TCₗₐ, τₑₚ=TCₗₐ+TRₗₐ, Eshift=Eshiftₗₐ)\n@named RV = ShiChamber(V₀=V0ᵣᵥ, p₀=0.0, Eₘᵢₙ=Epassᵣᵥ, Eₘₐₓ=Epassᵣᵥ+Eactmaxᵣᵥ, τ=τ, τₑₛ=TCᵣᵥ, τₑₚ=TCᵣᵥ+TRᵣᵥ, Eshift=0.0)\n@named RA = ShiChamber(V₀=V0ᵣₐ, p₀=0.0, Eₘᵢₙ=Epassᵣₐ, Eₘₐₓ=Epassᵣₐ+Eactmaxᵣₐ, τ=τ, τₑₛ=TCᵣₐ, τₑₚ=TCₗₐ+TRₗₐ, Eshift=Eshiftᵣₐ)\n\n# Valves as leaky diodes\n@named AV = LeakyResistorDiode(Rₘᵢₙ = Rmin, Rₘₐₓ = Rmax)\n@named MV = LeakyResistorDiode(Rₘᵢₙ = Rmin, Rₘₐₓ = Rmax)\n@named TV = LeakyResistorDiode(Rₘᵢₙ = Rmin, Rₘₐₓ = Rmax)\n@named PV = LeakyResistorDiode(Rₘᵢₙ = Rmin, Rₘₐₓ = Rmax)\n\n####### Systemic Loop #######\n# Systemic Artery ##\n@named SYSAR = CRL(C=Csysₐᵣ, R=Rsysₐᵣ, L=Lsysₐᵣ)\n# Systemic Vein ##\n@named SYSVEN = CRL(C=Csysᵥₑₙ, R=Rsysᵥₑₙ, L=Lsysᵥₑₙ)\n\n####### Pulmonary Loop #######\n# Pulmonary Artery ##\n@named PULAR = CRL(C=Cpulₐᵣ, R=Rpulₐᵣ, L=Lpulₐᵣ)\n# Pulmonary Vein ##\n@named PULVEN = CRL(C=Cpulᵥₑₙ, R=Rpulᵥₑₙ, L=Lpulᵥₑₙ)\n\n#\ncirc_eqs_init = [\n    connect(LV.out, AV.in)\n    connect(AV.out, SYSAR.in)\n    connect(SYSAR.out, SYSVEN.in)\n    connect(SYSVEN.out, RA.in)\n    connect(RA.out, TV.in)\n    connect(TV.out, RV.in)\n    connect(RV.out, PV.in)\n    connect(PV.out,  PULAR.in)\n    connect(PULAR.out, PULVEN.in)\n    connect(PULVEN.out, LA.in)\n    connect(LA.out, MV.in)\n    connect(MV.out, LV.in)\n]\n\n# Compose the whole ODE system\n@named _circ_model_init = ODESystem(circ_eqs_init, t)\n@named circ_model_init = compose(_circ_model_init,\n    [LV, RV, LA, RA, AV, MV, PV, TV, SYSAR, SYSVEN, PULAR, PULVEN])\n\n# And simplify it\ncirc_sys_init = structural_simplify(circ_model_init)\n\n# Setup ODE with reasonable initial guess\nu0 = [\n    LV.V => LV_Vt0\n    RV.V => RV_Vt0\n    RA.V => RA_Vt0\n    LA.V => LA_Vt0\n    SYSAR.C.V => 100.0 * Csysₐᵣ\n    SYSAR.L.q => 0.0\n    SYSVEN.C.V => 0.0\n    SYSVEN.L.q => 0.0\n    PULAR.C.V => 30.0 * Cpulₐᵣ\n    PULAR.L.q => 0.0\n    PULVEN.C.V => 0.0\n    PULVEN.L.q => 0.0\n];\n\nprob = OrdinaryDiffEqTsit5.ODEProblem(circ_sys_init, u0, (0.0, 20.0e3))\n\n@time circ_sol_init = solve(prob, Tsit5(), reltol=1e-9, abstol=1e-12, saveat=18e3:0.01e3:20e3);\n\nu0new = copy(circ_sol_init.u[end]);\n\n@named LVc = PressureCouplingChamber();\n\ncirc_eqs = [\n    connect(LVc.out, AV.in)\n    connect(AV.out, SYSAR.in)\n    connect(SYSAR.out, SYSVEN.in)\n    connect(SYSVEN.out, RA.in)\n    connect(RA.out, TV.in)\n    connect(TV.out, RV.in)\n    connect(RV.out, PV.in)\n    connect(PV.out,  PULAR.in)\n    connect(PULAR.out, PULVEN.in)\n    connect(PULVEN.out, LA.in)\n    connect(LA.out, MV.in)\n    connect(MV.out, LVc.in)\n];\n\n@named _circ_model = ODESystem(circ_eqs, t)\n@named circ_model = compose(_circ_model,\n    [LVc, RV, LA, RA, AV, MV, PV, TV, SYSAR, SYSVEN, PULAR, PULVEN])\ncirc_sys = structural_simplify(circ_model);\n\nscaling_factor = 3.0;\n\nmesh = generate_ideal_lv_mesh(8,2,5;\n    inner_radius = scaling_factor*0.7,\n    outer_radius = scaling_factor*1.0,\n    longitudinal_upper = scaling_factor*0.2,\n    apex_inner = scaling_factor* 1.3,\n    apex_outer = scaling_factor*1.5\n)\nmesh = Thunderbolt.hexahedralize(mesh)\n\ncoordinate_system = compute_lv_coordinate_system(mesh)\nmicrostructure    = create_microstructure_model(\n    coordinate_system,\n    LagrangeCollection{1}()^3,\n    ODB25LTMicrostructureParameters(),\n);\npassive_material_model = Guccione1991PassiveModel()\nactive_material_model  = Guccione1993ActiveModel()\nfunction calcium_profile_function(x::LVCoordinate,t)\n    linear_interpolation(t,y1,y2,t1,t2) = y1 + (t-t1) * (y2-y1)/(t2-t1)\n    ca_peak(x)                          = 1.0\n    if 0 ≤ t ≤ 300.0\n        return linear_interpolation(t,        0.0, ca_peak(x),   0.0, 300.0)\n    elseif t ≤ 500.0\n        return linear_interpolation(t, ca_peak(x),        0.0, 300.0, 500.0)\n    else\n        return 0.0\n    end\nend\ncalcium_field = AnalyticalCoefficient(\n    calcium_profile_function,\n    coordinate_system,\n)\nsarcomere_model = CaDrivenInternalSarcomereModel(ConstantStretchModel(), calcium_field)\nactive_stress_model = ActiveStressModel(\n    passive_material_model,\n    active_material_model,\n    sarcomere_model,\n    microstructure,\n)\nweak_boundary_conditions = (NormalSpringBC(1.0, \"Epicardium\"),)\nsolid_model = QuasiStaticModel(:displacement, active_stress_model, weak_boundary_conditions);\n\np3D = LVc.p3D\nV0D = LVc.V\nfluid_model = MTKLumpedCicuitModel(circ_sys, u0new, [p3D])\ncoupler = LumpedFluidSolidCoupler(\n    [\n        ChamberVolumeCoupling(\n            \"Endocardium\",\n            RSAFDQ2022SurrogateVolume(),\n            V0D\n        )\n    ],\n    :displacement,\n)\ncoupled_model = RSAFDQ2022Model(solid_model,fluid_model,coupler);\n\nspatial_discretization_method = FiniteElementDiscretization(\n    Dict(:displacement => LagrangeCollection{1}()^3),\n    [\n        Dirichlet(:displacement, getfacetset(mesh, \"Base\"), (x,t) -> [0.0], [3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor1\"), (x,t) -> (0.0, 0.0, 0.0), [1,2,3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor2\"), (x,t) -> (0.0, 0.0), [2,3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor3\"), (x,t) -> (0.0,), [3]),\n        Dirichlet(:displacement, getnodeset(mesh, \"MyocardialAnchor4\"), (x,t) -> (0.0,), [3])\n    ],\n)\nsplitform = semidiscretize(\n    RSAFDQ2022Split(coupled_model),\n    spatial_discretization_method,\n    mesh,\n)\n\ndt₀ = 1.0\ndtvis = 5.0\ntspan = (0.0, 1000.0)\n\ntspan = (0.0, dtvis)    # hide\n\nchamber_solver = HomotopyPathSolver(\n    NewtonRaphsonSolver(;\n        max_iter=10,\n        tol=1e-2,\n        inner_solver=SchurComplementLinearSolver(\n            LinearSolve.UMFPACKFactorization()\n        )\n    )\n)\nblood_circuit_solver = ForwardEulerSolver(rate=ceil(Int, dt₀/0.001)) # Force time step to about 0.001\ntimestepper = LieTrotterGodunov((chamber_solver, blood_circuit_solver))\n\nu₀ = zeros(solution_size(splitform))\nu₀[OS.get_dofrange(splitform, 2)] .= u0new;\n\nproblem = OperatorSplittingProblem(splitform, u₀, tspan)\nintegrator = init(problem, timestepper, dt=dt₀, verbose=true);\n\n\n# f2 = Figure()\n# axs = [\n#     Axis(f2[1, 1], title=\"LV\"),\n#     Axis(f2[1, 2], title=\"RV\"),\n#     Axis(f2[2, 1], title=\"LA\"),\n#     Axis(f2[2, 2], title=\"RA\")\n# ]\n\n# vlv = Observable(Float64[])\n# plv = Observable(Float64[])\n\n# vrv = Observable(Float64[])\n# prv = Observable(Float64[])\n\n# vla = Observable(Float64[])\n# pla = Observable(Float64[])\n\n# vra = Observable(Float64[])\n# pra = Observable(Float64[])\n\n# lines!(axs[1], vlv, plv)\n# lines!(axs[2], vrv, prv)\n# lines!(axs[3], vla, pla)\n# lines!(axs[4], vra, pra)\n# for i in 1:4\n#     xlims!(axs[1], 0.0, 180.0)\n#     ylims!(axs[1], 0.0, 180.0)\n# end\n# display(f2)\n\nio = ParaViewWriter(\"CM03_3d0d-coupling\");\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    chamber_function = OS.get_operator(splitform, 1)\n    (; dh) = chamber_function.structural_function\n    store_timestep!(io, t, dh.grid)\n    Thunderbolt.store_timestep_field!(io, t, dh, u[1:ndofs(dh)], :displacement) # TODO allow views\n    Thunderbolt.finalize_timestep!(io, t)\n\n    # if t > 0.0\n    #     lv = chamber_function.tying_info.chambers[1]\n    #     append!(vlv.val, lv.V⁰ᴰval)\n    #     append!(plv.val, u[lv.pressure_dof_index_global])\n    #     notify(vlv)\n    #     notify(plv)\n    # end\n    # TODO plot other chambers\nend","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"","category":"page"},{"location":"tutorials/cm03_3d0d-coupling/","page":"CM03: 0D Blood Circuit","title":"CM03: 0D Blood Circuit","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/#Tutorials","page":"Overview","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"On this page you find an overview of Thunderbolt tutorials. The tutorials explain and show the indended usage of Thunderbolt to simulate cardiac problems. Tutorials are sorted by their physical domain and written in a way that users can start with reading the tutorials (in order) of the physics they are interested in, without necessarily going through the tutorials for the other phyiscal domains.","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"The tutorials all follow roughly the same structure:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"Introduction introduces the problem to be solved and discusses the learning outcomes of the tutorial.\nCommented program is the code for solving the problem with explanations and comments.\nPlain program is the raw source code of the program.","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"When studying the tutorials it is a good idea to obtain a local copy of the code and run it on your own machine as you read along. Some of the tutorials also include suggestions for tweaks to the program that you can try out on your own.","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"danger: Danger\nThe tutorials are work in progress and not all necessary features are implemented yet.","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"tip: Tip\nParallel assembly and solvers are automatically enabled when you start julia with multiple threads, e.g. viajulia --project --threads=auto","category":"page"},{"location":"tutorials/#Cardiac-Mechanics","page":"Overview","title":"Cardiac Mechanics","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"This section explains how cardiac solid mechanics simulations can be carried out, how these simulations can be coupled with blood circuit models and how to add mechanical custom models.","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[Mechanics-Tutorial-01:-Simple-Active-Stress](@ref-mechanics-tutorial_simple-active-stress)","page":"Overview","title":"Mechanics Tutorial 01: Simple Active Stress","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"setup a basic contraction simulation\nuse the homotpy path solver (,,Load Stepping'') and choose a custom inner solver\nextract quantities to post-process solutions online and offline","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[Mechanics-Tutorial-02:-Prestress](@ref-mechanics-tutorial_prestress)-(TODO)","page":"Overview","title":"Mechanics Tutorial 02: Prestress (TODO)","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"add residual strains to a model\nadd preload to a model\nfind the new reference configuration","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[Mechanics-Tutorial-03:-Coupling-A-Ciculatory-System-Model](@ref-mechanics-tutorial_3d0dcoupling)","page":"Overview","title":"Mechanics Tutorial 03: Coupling A Ciculatory System Model","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"define a blood circuit model\ncouple the blood circuit model with a single heart chamber\nvisualize pressure-volume loops and the blood circuit solution along the","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[Mechanics-Tutorial-04:-Pericardial-Boundary-Condtions](@ref-mechanics-tutorial_pericardium)-(TODO)","page":"Overview","title":"Mechanics Tutorial 04: Pericardial Boundary Condtions (TODO)","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"generate a pericardium\nadd pericardial boundary condtions to a model","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[Mechanics-Tutorial-05:-Four-Chamber-Models](@ref-mechanics-tutorial_fourchamber)-(TODO)","page":"Overview","title":"Mechanics Tutorial 05: Four Chamber Models (TODO)","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"handle and couple multiple subdomains\ncouple the blood circuit model with a multiple heart chambers","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[Mechanics-Tutorial-06:-Heart-Valves](@ref-mechanics-tutorial_heartvalves)-(TODO)","page":"Overview","title":"Mechanics Tutorial 06: Heart Valves (TODO)","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"handle 1D and 2D elements in 3D\nadd a 3D fluid model to the heart\ncouple a 3D fluid model an external blood circuit model","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#Cardiac-Electrophysiology","page":"Overview","title":"Cardiac Electrophysiology","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"This section explains how cardiac electrophysiology simulations can be carried out, how these simulations can be coupled with Purkinje network models, how to extract the ECG and how to add mechanical electrophysiology models.","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[EP-Tutorial-01:-Spiral-Waves-with-a-Monodomain-Model](@ref-ep-tutorial_spiral-wave)","page":"Overview","title":"EP Tutorial 01: Spiral Waves with a Monodomain Model","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"setup a basic electrophysiology simulations\nset initial conditions\ndefine a custom stimulation protocols\nrun an electrophysiology simulation on a GPU","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[EP-Tutorial-02:-Activating-a-Left-Ventricle-via-Purkinje-Network](@ref-ep-tutorial_purkinje)-(TODO)","page":"Overview","title":"EP Tutorial 02: Activating a Left Ventricle via Purkinje Network (TODO)","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"generate a Purkinje Network\ncouple the chamber tissue with the network","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[EP-Tutorial-03:-ECG-with-a-Bidomain-Model](@ref-ep-tutorial_purkinje)-(TODO)","page":"Overview","title":"EP Tutorial 03: ECG with a Bidomain Model (TODO)","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"handle multiple subdomains with different physics\nhandle coefficients when facing multiple subdomains\nadd ground boundary conditons\ninduce Torsade de pointes\nadd defibrillation boundary conditions","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[EP-Tutorial-04:-ECG-with-a-Monodomain-Model](@ref-ep-tutorial_geselowitz-ecg)","page":"Overview","title":"EP Tutorial 04: ECG with a Monodomain Model","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"transfer coefficients and solutions between overlapping domains\ncompute the ECG form a monodomain model as a postprocessing step","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[EP-Tutorial-05:-Reaction-Eikonal-ECG](@ref-ep-tutorial_eikonal)-(TODO)","page":"Overview","title":"EP Tutorial 05: Reaction-Eikonal ECG (TODO)","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"perform ECG simulations with a simplified activation dynamics model","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"tutorials/#[EP-Tutorial-06:-Including-Pacemakers](@ref-ep-tutorial_pacemaker)-(TODO)","page":"Overview","title":"EP Tutorial 06: Including Pacemakers (TODO)","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"In this tutorial you will learn how to:","category":"page"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"Handling Heterogeneous Tissues","category":"page"},{"location":"api-reference/mesh/","page":"Mesh","title":"Mesh","text":"DocTestSetup = :(using Thunderbolt)","category":"page"},{"location":"api-reference/mesh/#Mesh","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"api-reference/mesh/","page":"Mesh","title":"Mesh","text":"Thunderbolt.SimpleMesh\nThunderbolt.to_mesh\nThunderbolt.elementtypes","category":"page"},{"location":"api-reference/mesh/#Thunderbolt.SimpleMesh","page":"Mesh","title":"Thunderbolt.SimpleMesh","text":"SimpleMesh{sdim, C <: AbstractCell, T <: Real} <: AbstractGrid{sdim}\n\nA grid which also has information abouts its vertices, faces and edges.\n\nIt is also a glorified domain manager for mixed grids and actual subdomains. TODO investigate whetehr we can remove the subdomains without a significant performance hit.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#coordinate-system-api","page":"Mesh","title":"Coordinate Systems","text":"","category":"section"},{"location":"api-reference/mesh/","page":"Mesh","title":"Mesh","text":"CartesianCoordinateSystem\nLVCoordinateSystem\nLVCoordinate\nBiVCoordinateSystem\nBiVCoordinate","category":"page"},{"location":"api-reference/mesh/#Thunderbolt.CartesianCoordinateSystem","page":"Mesh","title":"Thunderbolt.CartesianCoordinateSystem","text":"CartesianCoordinateSystem(mesh)\n\nStandard cartesian coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#Thunderbolt.LVCoordinateSystem","page":"Mesh","title":"Thunderbolt.LVCoordinateSystem","text":"LVCoordinateSystem(dh, u_transmural, u_apicobasal)\n\nSimplified universal ventricular coordinate on LV only, containing the transmural, apicobasal and rotational coordinates. See compute_lv_coordinate_system to construct it.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#Thunderbolt.LVCoordinate","page":"Mesh","title":"Thunderbolt.LVCoordinate","text":"LVCoordinate{T}\n\nLV only part of the universal ventricular coordinate, containing     * transmural     * apicobasal     * rotational\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#Thunderbolt.BiVCoordinateSystem","page":"Mesh","title":"Thunderbolt.BiVCoordinateSystem","text":"BiVCoordinateSystem(dh, u_transmural, u_apicobasal, u_rotational, u_transventricular)\n\nUniversal ventricular coordinate, containing the transmural, apicobasal, rotational  and transventricular coordinates.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#Thunderbolt.BiVCoordinate","page":"Mesh","title":"Thunderbolt.BiVCoordinate","text":"BiVCoordinate{T}\n\nBiventricular universal coordinate, containing     * transmural     * apicobasal     * rotational     * transventricular\n\n\n\n\n\n","category":"type"},{"location":"api-reference/mesh/#mesh-generator-api","page":"Mesh","title":"Mesh Generators","text":"","category":"section"},{"location":"api-reference/mesh/","page":"Mesh","title":"Mesh","text":"generate_mesh\ngenerate_ring_mesh\ngenerate_open_ring_mesh\ngenerate_quadratic_ring_mesh\ngenerate_quadratic_open_ring_mesh\ngenerate_ideal_lv_mesh","category":"page"},{"location":"api-reference/mesh/#Thunderbolt.generate_ring_mesh","page":"Mesh","title":"Thunderbolt.generate_ring_mesh","text":"generate_ring_mesh(num_elements_circumferential::Int, num_elements_radial::Int, num_elements_logintudinal::Int; inner_radius::T = Float64(0.75), outer_radius::T = Float64(1.0), longitudinal_lower::T = Float64(-0.2), longitudinal_upper::T = Float64(0.2), apicobasal_tilt::T=Float64(0.0)) where {T}\n\nGenerates an idealized full-hexahedral ring with linear ansatz. Geometrically it is the substraction of a small cylinder C_i of a large cylinder C_o. The number of elements for the cylindrical system can be controlled by the first three input parameters. The remaining parameters control the spatial dimensions and the ring shape.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/mesh/#Thunderbolt.generate_open_ring_mesh","page":"Mesh","title":"Thunderbolt.generate_open_ring_mesh","text":"generate_open_ring_mesh(num_elements_circumferential::Int, num_elements_radial::Int, num_elements_logintudinal::Int, opening_angle::Float64; inner_radius::T = Float64(0.75), outer_radius::T = Float64(1.0), longitudinal_lower::T = Float64(-0.2), longitudinal_upper::T = Float64(0.2), apicobasal_tilt::T=Float64(0.0)) where {T}\n\nGenerates an idealized full-hexahedral ring with given opening angle and linear ansatz. Geometrically it is the substraction of a small cylinder C_i of a large cylinder C_o. The number of elements for the cylindrical system can be controlled by the first three input parameters. The remaining parameters control the spatial dimensions and the ring shape. The ring is opened along the Cartesian x-z plane.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/mesh/#Thunderbolt.generate_quadratic_ring_mesh","page":"Mesh","title":"Thunderbolt.generate_quadratic_ring_mesh","text":"generate_quadratic_ring_mesh(num_elements_circumferential::Int, num_elements_radial::Int, num_elements_logintudinal::Int; inner_radius::T = Float64(0.75), outer_radius::T = Float64(1.0), longitudinal_lower::T = Float64(-0.2), longitudinal_upper::T = Float64(0.2), apicobasal_tilt::T=Float64(0.0)) where {T}\n\nGenerates an idealized full-hexahedral ring with quadratic ansatz. Geometrically it is the substraction of a small cylinder C_i of a large cylinder C_o. The number of elements for the cylindrical system can be controlled by the first three input parameters. The remaining parameters control the spatial dimensions and the ring shape.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/mesh/#Thunderbolt.generate_quadratic_open_ring_mesh","page":"Mesh","title":"Thunderbolt.generate_quadratic_open_ring_mesh","text":"generate_quadratic_open_ring_mesh(num_elements_circumferential::Int, num_elements_radial::Int, num_elements_logintudinal::Int, opening_angle::Float64; inner_radius::T = Float64(0.75), outer_radius::T = Float64(1.0), longitudinal_lower::T = Float64(-0.2), longitudinal_upper::T = Float64(0.2), apicobasal_tilt::T=Float64(0.0)) where {T}\n\nGenerates an idealized full-hexahedral ring with given opening angle and quadratic ansatz. Geometrically it is the substraction of a small cylinder C_i of a large cylinder C_o. The number of elements for the cylindrical system can be controlled by the first three input parameters. The remaining parameters control the spatial dimensions and the ring shape. The ring is opened along the Cartesian x-z plane.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/mesh/#Thunderbolt.generate_ideal_lv_mesh","page":"Mesh","title":"Thunderbolt.generate_ideal_lv_mesh","text":"generate_ideal_lv_mesh(num_elements_circumferential::Int, num_elements_radial::Int, num_elements_logintudinally::Int; inner_radius::T = Float64(0.7), outer_radius::T = Float64(1.0), longitudinal_upper::T = Float64(0.2), apex_inner::T = Float64(1.3), apex_outer::T = Float64(1.5))\n\nGenerate an idealized left ventricle as a truncated ellipsoid. The number of elements per axis are controlled by the first three parameters.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/mesh/#mesh-utility-api","page":"Mesh","title":"Utility","text":"","category":"section"},{"location":"api-reference/mesh/","page":"Mesh","title":"Mesh","text":"Thunderbolt.hexahedralize\nThunderbolt.uniform_refinement\nload_carp_mesh\nload_voom2_mesh\nload_mfem_mesh","category":"page"},{"location":"topics/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"topics/operators/#TLDR","page":"Operators","title":"TLDR","text":"","category":"section"},{"location":"topics/operators/","page":"Operators","title":"Operators","text":"In Thunderbolt ,,operators'' connect (spatial) finite element discretizations and time integration algorithms.","category":"page"},{"location":"topics/operators/#More","page":"Operators","title":"More","text":"","category":"section"},{"location":"topics/operators/","page":"Operators","title":"Operators","text":"Operators act as the translation layer between discretized problems and solvers by abstracting \"functions of functions\".","category":"page"},{"location":"topics/operators/","page":"Operators","title":"Operators","text":"Many multiphysics problems can be efficiently described as blocked problems, which gives rise to the concept of blocked operators by partitioning the input of the function into multiple ones.","category":"page"},{"location":"topics/operators/","page":"Operators","title":"Operators","text":"More detailed information coming soon...","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"EditURL = \"../literate-tutorials/ep01_spiral-wave.jl\"","category":"page"},{"location":"tutorials/ep01_spiral-wave/#ep-tutorial_spiral-wave","page":"EP01: Spiral Wave","title":"Electrophysiology Tutorial 1: Simple Spiral Wave","text":"","category":"section"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"(Image: Spiral Wave)","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"This tutorial shows how to perform a simulation of electrophysiological behavior of cardiac tissue.","category":"page"},{"location":"tutorials/ep01_spiral-wave/#Introduction","page":"EP01: Spiral Wave","title":"Introduction","text":"","category":"section"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"The most widespread model of cardiac electrophysiology is the monodomain model. It can be defined on a domain Omega as the system of partial differential equations","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"beginaligned\n  chi C_textrmm partial_t varphi = nabla cdot boldsymbolkappa nabla varphi - chi I(varphi boldsymbols t)  textrmin  Omega   \n  partial_t boldsymbols = mathbfg(varphi boldsymbols)  textrmin   Omega   \n  0 = boldsymbolkappa nabla varphi cdot mathbfn  mathrmon  partial Omega  \nendaligned","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"together with admissible initial conditions and a cellular ionic model to determine I and mathbfg. boldsymbolkappa denotes the conductivity tensor, varphi is the transmembrane potential field, chi is the volume to membrane surface ratio, C_mathrmm is the membrane capacitance, and I(varphi boldsymbols t) = I_textrmion(varphi boldsymbols) + I_textrmstim(t) denotes the sum of the ionic current due to the cell model and the applied stimulus current, respectively.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"In this tutorial we will apply a reaction-diffusion split to this model and solve it with an operator splitting solver. For some theory on operator splitting we refer to the theory manual on operator splitting.","category":"page"},{"location":"tutorials/ep01_spiral-wave/#Commented-Program","page":"EP01: Spiral Wave","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"We start by loading Thunderbolt and LinearSolve to use a custom direct solver of our choice.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"using Thunderbolt, LinearSolve","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"We start by constructing a square domain for our simulation.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"mesh = generate_mesh(Quadrilateral, (2^6, 2^6), Vec{2}((0.0,0.0)), Vec{2}((2.5,2.5)));\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"Here the first parameter is the element type and the second parameter is a tuple holding the number of subdivisions per dimension. The last two parameters are the corners defining the rectangular domain.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"tip: Tip\nWe can also load realistic geometries with external formats. For this simply use either FerriteGmsh.jl or one of the loader functions stated in the mesh API.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"We now define the parameters appearing in the model. For simplciity we assume C_mathrmm = chi = 10 and a homogeneous, anisotropic symmetric conductivity tensor.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"Cₘ = ConstantCoefficient(1.0)\nχ  = ConstantCoefficient(1.0)\nκ  = ConstantCoefficient(SymmetricTensor{2,2,Float64}((4.5e-5, 0, 2.0e-5)));\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"tip: Tip\nIf the mesh is properly annotated, then we can generate (or even load) a cardiac coordinate system. Consult coordinate system API documentation for details. With this information we can construct idealized microstructures to define heterogeneous conductivity tensors e.g. asmicrostructure = create_simple_microstructure_model(\n  coordinate_system,\n  LagrangeCollection{1}()^3;\n  endo_helix_angle = deg2rad(60.0),\n  epi_helix_angle = deg2rad(-60.0),\n)\nκ = SpectralTensorCoefficient(\n    microstructure,\n    ConstantCoefficient(SVector(κ₁, κ₂, κ₃))\n)where κ₁, κ₂, κ₃ are the eigenvalues for the fiber, sheet and normal direction.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"The spiral wave will unfold due to the specific construction of the initial conditions, hence we do not need to apply a stimulus.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"stimulation_protocol = NoStimulationProtocol();\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"Now we choose a cell model. For simplicity we choose a neuronal electrophysiology model, which is a nice playground.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"cell_model = Thunderbolt.FHNModel();\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"tip: Tip\nA full list of all models can be found in the API reference. To implement a custom cell model please consult the how-to section.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"todo: Todo\nThe initializer API is not yet finished and hence we deconstruct stuff here manually. Please note that this method is quite fragile w.r.t. to many changes you can make in the code below.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"Spiral wave initializer for the FitzHugh-Nagumo","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"function spiral_wave_initializer!(u₀, f::GenericSplitFunction)\n    # TODO cleaner implementation. We need to extract this from the types or via dispatch.\n    heatfun = f.functions[1]\n    heat_dofrange = f.solution_indices[1]\n    odefun = f.functions[2]\n    ionic_model = odefun.ode\n\n    φ₀ = @view u₀[heat_dofrange];\n    # TODO extraction these via utility functions\n    dh = heatfun.dh\n    s₀flat = @view u₀[(ndofs(dh)+1):end];\n    # Should not be reshape but some array of arrays fun, because in general (e.g. for heterogeneous tissues) we cannot reshape into a matrix\n    s₀ = reshape(s₀flat, (ndofs(dh), Thunderbolt.num_states(ionic_model)-1));\n\n    for cell in CellIterator(dh)\n        _celldofs = celldofs(cell)\n        φₘ_celldofs = _celldofs[dof_range(dh, :φₘ)]\n        # TODO query coordinate directly from the cell model\n        coordinates = getcoordinates(cell)\n        for (i, (x₁, x₂)) in zip(φₘ_celldofs,coordinates)\n            if x₁ <= 1.25 && x₂ <= 1.25\n                φ₀[i] = 1.0\n            end\n            if x₂ >= 1.25\n                s₀[i,1] = 0.1\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"Now we put the components together by instantiating the monodomain model.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"ep_model = MonodomainModel(\n    Cₘ,\n    χ,\n    κ,\n    stimulation_protocol,\n    cell_model,\n    :φₘ, :s,\n);\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"We now annotate the model to be reaction-diffusion split. Special solvers need special forms for the model. However, the same solver can work with different forms. In the case of operator splitting users might choose to split the equations differently. Hence we leave it as a user option which split they prefer, or if they even want work on the full problem.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"split_ep_model = ReactionDiffusionSplit(ep_model);\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"todo: Todo\nShow how to use solvers different that LTG (and implement them).","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"We now need to transform the space-time problem into a time-dependent problem by discretizing it spatially. This can be accomplished by the function semidiscretize, which takes a model and the disretization technique. Here we use a finite element discretization in space with first order Lagrange polynomials to discretize the displacement field.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"danger: Danger\nThe discretization API does now play well with multiple domains right now and will be updated with a possible breaking change in future releases.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"spatial_discretization_method = FiniteElementDiscretization(\n    Dict(:φₘ => LagrangeCollection{1}()),\n)\nodeform = semidiscretize(split_ep_model, spatial_discretization_method, mesh);\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"We now allocate a solution vector and set the initial condition.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"u₀ = zeros(Float32, OS.function_size(odeform))\nspiral_wave_initializer!(u₀, odeform);\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"We proceed by defining the time integration algorithms for each subproblem. First, there is the heat problem, which we will solve with a low-storage backward Euler method","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"heat_timestepper = BackwardEulerSolver(\n    inner_solver=KrylovJL_CG(atol=1e-6, rtol=1e-5),\n);\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"tip: Tip\nOn non-trivial geometries it is highly recommended to use a preconditioner. Please consult the LinearSolve.jl docs for details.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"And then there is the reaction subproblem, which decouples locally into \"number of dofs in the discrete heat problem\" separate ODE. We will solve these locally adaptive with forward Euler steps.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"cell_timestepper = AdaptiveForwardEulerSubstepper(;\n    reaction_threshold=0.1,\n);\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"Now we can just instantiate the operator splitting algorithm of our choice. Since our time integrators are both first order in time we opt for the standard first order accurrate operator splitting technique by Lie-Trotter (or Godunov).","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"timestepper = OS.LieTrotterGodunov((heat_timestepper, cell_timestepper));\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"The remaining code is very similar to how we use SciML solvers. We first define our time domain, initial time step length and some dt for visualization.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"dt₀ = 10.0\ndtvis = 25.0;\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"This speeds up the CI # hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"tspan = (0.0, dtvis);   # hide\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"Then we setup the problem. We have a split function, so the correct problem is an OperatorSplittingProblem.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"problem = OS.OperatorSplittingProblem(odeform, u₀, tspan);\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"tip: Tip\nIf we want to solve the problem on the GPU, or if we want to use special matrix and vector formats, we just need to adjust the vector and matrix types. For example, if we want to problem to be solved on a CUDA GPU with 32 bit precision, then we need to adjust the types as follows.u₀gpu = CuVector(u₀)\nheat_timestepper = BackwardEulerSolver(\n  solution_vector_type=CuVector{Float32},\n  system_matrix_type=CUDA.CUSPARSE.CuSparseMatrixCSR{Float32, Int32},\n  inner_solver=KrylovJL_CG(atol=1.0f-6, rtol=1.0f-5),\n)\ncell_timestepper = AdaptiveForwardEulerSubstepper(\n    solution_vector_type=CuVector{Float32},\n    reaction_threshold=0.1f0,\n)\n...\nproblem = OS.OperatorSplittingProblem(odeform, u₀gpu, tspan)","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"Now we initialize our time integrator as usual.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"integrator = OS.init(problem, timestepper, dt=dt₀);\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"todo: Todo\nThe post-processing API is not yet finished. Please revisit the tutorial later to see how to post-process the simulation online. Right now the solution is just exported into VTK, such that users can visualize the solution in e.g. ParaView.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"And finally we solve the problem in time.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"io = ParaViewWriter(\"EP01_spiral_wave\")\nfor (u, t) in OS.TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    (; dh) = odeform.functions[1]\n    φ = u[odeform.solution_indices[1]]\n    store_timestep!(io, t, dh.grid) do file\n        Thunderbolt.store_timestep_field!(file, t, dh, φ, :φₘ)\n    end\nend;\nnothing #hide","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"tip: Tip\nIf you want to see more details of the solution process launch Julia with Thunderbolt as debug module:JULIA_DEBUG=Thunderbolt julia --project --threads=auto my_simulation_runner.jl","category":"page"},{"location":"tutorials/ep01_spiral-wave/#References","page":"EP01: Spiral Wave","title":"References","text":"","category":"section"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"","category":"page"},{"location":"tutorials/ep01_spiral-wave/#mechanics-tutorial_spiral-wave-plain-program","page":"EP01: Spiral Wave","title":"Plain program","text":"","category":"section"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"Here follows a version of the program without any comments. The file is also available here: ep01_spiral_wave.jl.","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"using Thunderbolt, LinearSolve\n\nmesh = generate_mesh(Quadrilateral, (2^6, 2^6), Vec{2}((0.0,0.0)), Vec{2}((2.5,2.5)));\n\nCₘ = ConstantCoefficient(1.0)\nχ  = ConstantCoefficient(1.0)\nκ  = ConstantCoefficient(SymmetricTensor{2,2,Float64}((4.5e-5, 0, 2.0e-5)));\n\nstimulation_protocol = NoStimulationProtocol();\n\ncell_model = Thunderbolt.FHNModel();\n\nfunction spiral_wave_initializer!(u₀, f::GenericSplitFunction)\n    # TODO cleaner implementation. We need to extract this from the types or via dispatch.\n    heatfun = f.functions[1]\n    heat_dofrange = f.solution_indices[1]\n    odefun = f.functions[2]\n    ionic_model = odefun.ode\n\n    φ₀ = @view u₀[heat_dofrange];\n    # TODO extraction these via utility functions\n    dh = heatfun.dh\n    s₀flat = @view u₀[(ndofs(dh)+1):end];\n    # Should not be reshape but some array of arrays fun, because in general (e.g. for heterogeneous tissues) we cannot reshape into a matrix\n    s₀ = reshape(s₀flat, (ndofs(dh), Thunderbolt.num_states(ionic_model)-1));\n\n    for cell in CellIterator(dh)\n        _celldofs = celldofs(cell)\n        φₘ_celldofs = _celldofs[dof_range(dh, :φₘ)]\n        # TODO query coordinate directly from the cell model\n        coordinates = getcoordinates(cell)\n        for (i, (x₁, x₂)) in zip(φₘ_celldofs,coordinates)\n            if x₁ <= 1.25 && x₂ <= 1.25\n                φ₀[i] = 1.0\n            end\n            if x₂ >= 1.25\n                s₀[i,1] = 0.1\n            end\n        end\n    end\nend;\n\nep_model = MonodomainModel(\n    Cₘ,\n    χ,\n    κ,\n    stimulation_protocol,\n    cell_model,\n    :φₘ, :s,\n);\n\nsplit_ep_model = ReactionDiffusionSplit(ep_model);\n\nspatial_discretization_method = FiniteElementDiscretization(\n    Dict(:φₘ => LagrangeCollection{1}()),\n)\nodeform = semidiscretize(split_ep_model, spatial_discretization_method, mesh);\n\nu₀ = zeros(Float32, OS.function_size(odeform))\nspiral_wave_initializer!(u₀, odeform);\n\nheat_timestepper = BackwardEulerSolver(\n    inner_solver=KrylovJL_CG(atol=1e-6, rtol=1e-5),\n);\n\ncell_timestepper = AdaptiveForwardEulerSubstepper(;\n    reaction_threshold=0.1,\n);\n\ntimestepper = OS.LieTrotterGodunov((heat_timestepper, cell_timestepper));\n\ndt₀ = 10.0\ndtvis = 25.0;\n\ntspan = (0.0, dtvis);   # hide\n\nproblem = OS.OperatorSplittingProblem(odeform, u₀, tspan);\n\nintegrator = OS.init(problem, timestepper, dt=dt₀);\n\nio = ParaViewWriter(\"EP01_spiral_wave\")\nfor (u, t) in OS.TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    (; dh) = odeform.functions[1]\n    φ = u[odeform.solution_indices[1]]\n    store_timestep!(io, t, dh.grid) do file\n        Thunderbolt.store_timestep_field!(file, t, dh, φ, :φₘ)\n    end\nend;","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"","category":"page"},{"location":"tutorials/ep01_spiral-wave/","page":"EP01: Spiral Wave","title":"EP01: Spiral Wave","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/cm05_fourchambers/","page":"CM05: Four Chamber (TODO)","title":"CM05: Four Chamber (TODO)","text":"EditURL = \"../literate-tutorials/cm05_fourchambers.jl\"","category":"page"},{"location":"tutorials/cm05_fourchambers/#mechanics-tutorial_fourchamber","page":"CM05: Four Chamber (TODO)","title":"Mechanics Tutorial 5: Coupling Heart Valve Models","text":"","category":"section"},{"location":"tutorials/cm05_fourchambers/","page":"CM05: Four Chamber (TODO)","title":"CM05: Four Chamber (TODO)","text":"todo: Todo\nshow open four chamber geometry","category":"page"},{"location":"tutorials/cm05_fourchambers/","page":"CM05: Four Chamber (TODO)","title":"CM05: Four Chamber (TODO)","text":"This tutorial shows how to do four chamber simulations.","category":"page"},{"location":"tutorials/cm05_fourchambers/","page":"CM05: Four Chamber (TODO)","title":"CM05: Four Chamber (TODO)","text":"todo: Todo\nProvide context.","category":"page"},{"location":"tutorials/cm05_fourchambers/#Commented-Program","page":"CM05: Four Chamber (TODO)","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/cm05_fourchambers/","page":"CM05: Four Chamber (TODO)","title":"CM05: Four Chamber (TODO)","text":"todo: Todo\nFinalize subdomain management and use this as first simple showcase. Use free four chamber model.","category":"page"},{"location":"tutorials/cm05_fourchambers/#References","page":"CM05: Four Chamber (TODO)","title":"References","text":"","category":"section"},{"location":"tutorials/cm05_fourchambers/","page":"CM05: Four Chamber (TODO)","title":"CM05: Four Chamber (TODO)","text":"","category":"page"},{"location":"tutorials/cm05_fourchambers/#mechanics-tutorial_fourchamber-plain-program","page":"CM05: Four Chamber (TODO)","title":"Plain program","text":"","category":"section"},{"location":"tutorials/cm05_fourchambers/","page":"CM05: Four Chamber (TODO)","title":"CM05: Four Chamber (TODO)","text":"Here follows a version of the program without any comments. The file is also available here: cm05_fourchamber.jl.","category":"page"},{"location":"tutorials/cm05_fourchambers/","page":"CM05: Four Chamber (TODO)","title":"CM05: Four Chamber (TODO)","text":"","category":"page"},{"location":"tutorials/cm05_fourchambers/","page":"CM05: Four Chamber (TODO)","title":"CM05: Four Chamber (TODO)","text":"","category":"page"},{"location":"tutorials/cm05_fourchambers/","page":"CM05: Four Chamber (TODO)","title":"CM05: Four Chamber (TODO)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"devdocs/DifferentialEquationsjl-issue/#Brain-flush-about-relevant-design-decisions","page":"Brain flush about relevant design decisions","title":"Brain flush about relevant design decisions","text":"","category":"section"},{"location":"devdocs/DifferentialEquationsjl-issue/","page":"Brain flush about relevant design decisions","title":"Brain flush about relevant design decisions","text":"https://github.com/SciML/DifferentialEquations.jl/issues/997","category":"page"},{"location":"devdocs/DifferentialEquationsjl-issue/","page":"Brain flush about relevant design decisions","title":"Brain flush about relevant design decisions","text":"My personal roadmap is to publish Thunderbolt.jl soon, which is a multiphysics framework which tries to be close to the design of the libraries in the DifferentialEquations.jl ecosystem, and to upstream relevant parts (after cleaning up and settling the design). ","category":"page"},{"location":"devdocs/DifferentialEquationsjl-issue/","page":"Brain flush about relevant design decisions","title":"Brain flush about relevant design decisions","text":"In Thunderbolt.jl I approach the outlined problems as follows (in the spoiler because likely not relevant for most readers). I put it here to see what problems come if we follow one approach deeper into the PDE rabbit hole (multiphysics/coupled problems). I hope that we can learn something about the interface design from this description.","category":"page"},{"location":"devdocs/DifferentialEquationsjl-issue/","page":"Brain flush about relevant design decisions","title":"Brain flush about relevant design decisions","text":"1,2,3,5 I do not have a clear separation between the hypothetic PDEFunction and the PDEProblem, because I could not figure out how to untie them in a modular and generic fashion, yet. Instead I have a granular distinction between the different types of PDE problems which I encounter (CoupledProblem, SplitProblem, ParitionedProblem,PointwiseProblem,QuasiStaticNonlinearProblem,QuasiStaticDAEProblem...). I ended up here because I am not sure what the distinguishing property between the problems should be (in contrast to ODE/SDE/...-Problems, where it is immediately clear).","category":"page"},{"location":"devdocs/DifferentialEquationsjl-issue/","page":"Brain flush about relevant design decisions","title":"Brain flush about relevant design decisions","text":"4,7 When constructing the problem from some model the discrete mesh (with some coordinate system), a discretization technique and boundary condition information is passed. This way the problem can cache the boundary condition information for a specific discretization and it also directly has the solution vector sizes (+meta information about the degrees of freedom). This way I can only handle a limited number of methods from class B (partitioned, basically method of lines) above and technically it should be possible to provide support for A (not touched this one yet).","category":"page"},{"location":"devdocs/DifferentialEquationsjl-issue/","page":"Brain flush about relevant design decisions","title":"Brain flush about relevant design decisions","text":"6 Solvers are defined per problem, as in the SciML ecosystem. However, this does not feel like the best choice due to the fine granularity of the problems described above. Basically when constructing the solvers I am constructing a sequence of operators, such that I get discrete (Non)linearFunctions of the form f(ut) plus caches for evaluating f, as well as caches for the inner solvers (e.g. \"NewtonRaphsonCache\", which is very similar to NonlinearSolve.jl . The operator is probably closest to a PDEFunction. However, I can not find a way to hoist the operator construction directly into the *Problems yet, because different solvers might need different operators. I think we can do the hoisting and I just had not enough time to figure out how to do it properly in the data structures.","category":"page"},{"location":"devdocs/DifferentialEquationsjl-issue/","page":"Brain flush about relevant design decisions","title":"Brain flush about relevant design decisions","text":"8 Kinda of a blocker for releasing my package public. I am currently basically poking around in the solver caches with dispatches. Since I want to interface against the SciML ecosystem in the long term anyway I have not bothered investing time. But I have something analogue to the TimeChoiceIterator in mind. I should note here that it is usually impossible to store the the full space-time solution in RAM (in contrast to e.g. pure small ODE problems). It should be just made clear that evaluating u(xt) is possible, but quite costly and comes with inaccurracies if the mesh is nonlinear (because we basically have to find where to evaluate, which usually involves solving a nonlinear problem). It should also be considered that many problems involve more than one field (e.g. \"heat and mechanics\" fields), hence we also need some way to distinguish between fields in the iterator.","category":"page"},{"location":"devdocs/DifferentialEquationsjl-issue/","page":"Brain flush about relevant design decisions","title":"Brain flush about relevant design decisions","text":"I have not given much details on the caching infrastructure since I am currently reworking it (and I honestly do not think that in depth detail here really will help with the problems). But the idea is similar to what is done in any package in the DifferentialEquations.jl ecosystem. Solvers construct caches and use them to control dispatches. ","category":"page"},{"location":"devdocs/DifferentialEquationsjl-issue/","page":"Brain flush about relevant design decisions","title":"Brain flush about relevant design decisions","text":"The obvious problem with my approach is that we do not clearly separate between modeling and solver. Yes, it allows that the model structure can be easier utilized, but I think we should be able to get an interface with a clearer separation and better reusability of individual components.","category":"page"},{"location":"howto/#How-to-Guides-Overview","page":"Overview","title":"How-to Guides Overview","text":"","category":"section"},{"location":"howto/","page":"Overview","title":"Overview","text":"This page gives an overview of the how-to guides. How-to guides address various common tasks one might want to do in a cardiac multiphysics simuation. Many of the guides are extensions, or build on top of, the tutorials and, therefore,  some familiarity with Thunderbolt is assumed.","category":"page"},{"location":"howto/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"howto/#[Benchmarking](benchmarking.md)","page":"Overview","title":"Benchmarking","text":"","category":"section"},{"location":"howto/","page":"Overview","title":"Overview","text":"This guide shows how we can understand which parts of the simulation how to get information about where time and memory is spent.","category":"page"},{"location":"howto/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"howto/","page":"Overview","title":"Overview","text":"More coming soon...","category":"page"},{"location":"api-reference/solver/","page":"Solver","title":"Solver","text":"DocTestSetup = :(using Thunderbolt)","category":"page"},{"location":"api-reference/solver/#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"api-reference/solver/#Linear","page":"Solver","title":"Linear","text":"","category":"section"},{"location":"api-reference/solver/","page":"Solver","title":"Solver","text":"SchurComplementLinearSolver","category":"page"},{"location":"api-reference/solver/#Thunderbolt.SchurComplementLinearSolver","page":"Solver","title":"Thunderbolt.SchurComplementLinearSolver","text":"SchurComplementLinearSolver(inner_alg::AbstractLinearAlgorithm)\n\nA solver for block systems of the form\n\nbeginbmatrix\n    A_11  A_12 \n    A_21  0\nendbmatrix\nbeginbmatrix\n    u_1 \n    u_2\nendbmatrix\n=\nbeginbmatrix\n    b_1 \n    b_2\nendbmatrix\n\nwith small zero block of size N_2 times N_2 and invertible A_11 with size N_1 times N_1. The inner linear solver is responsible to solve for N_2 systems of the form A_11 z_i = c_i.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Preconditioners","page":"Solver","title":"Preconditioners","text":"","category":"section"},{"location":"api-reference/solver/","page":"Solver","title":"Solver","text":"Thunderbolt.Preconditioners.CPUSetting\nThunderbolt.Preconditioners.GPUSetting\nThunderbolt.Preconditioners.BlockPartitioning\nThunderbolt.Preconditioners.L1GSPrecBuilder\nThunderbolt.Preconditioners.L1GSPreconditioner","category":"page"},{"location":"api-reference/solver/#Thunderbolt.Preconditioners.CPUSetting","page":"Solver","title":"Thunderbolt.Preconditioners.CPUSetting","text":"CPUSetting(ncores::Ti)\n\nA configuration object for CPU backend. This struct encapsulates the number of CPU cores to be used for parallel computation.\n\nFields\n\nbackend::CPU: Represents the CPU backend (i.e. CPU()).\nncores::Ti: The number of CPU cores to be used for computation.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.Preconditioners.GPUSetting","page":"Solver","title":"Thunderbolt.Preconditioners.GPUSetting","text":"GPUSetting(backend::Backend, nblocks::Ti, nthreads::Ti)\n\nA configuration object for GPU backend. This struct encapsulates the number of GPU blocks and threads to be used for parallel computation.\n\n# Fields\n\nbackend::Backend: Represents the GPU backend (e.g. CUDABackend()).\nnblocks::Ti: The number of GPU blocks to be used for computation.\nnthreads::Ti: The number of threads per block to be used for computation.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.Preconditioners.BlockPartitioning","page":"Solver","title":"Thunderbolt.Preconditioners.BlockPartitioning","text":"BlockPartitioning{Ti<:Integer, Backend}\n\nStruct that encapsulates the diagonal partitioning configuration which is then used to distribute the work across multiple cores.\n\nFields\n\npartsize::Ti: Size of each partition (diagonal block).\nnparts::Ti: Number of partitions (i.e. size(A,1)/partsize).\nnchunks::Ti: Number of workgroups (e.g. CPU cores or GPU blocks).\nchunksize::Ti: Number of partitions assigned to each workgroup.\nbackend::Backend: Execution backend that determines where and how the preconditioner is applied, such as CPU() or CUDABackend().\n\nnote: Note\nchuncksize * nchunks doesn't have to be equal to nparts (can be less than or greater than). The diagonal partition iterator will take care of that throught strided iteration. The reason for this is obvious in GPUBackend, in which nblocks (i.e. nchunks) and nthreads (i.e. chunksize) are chosen to maximize occupancy, which may not be equal to nparts.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.Preconditioners.L1GSPrecBuilder","page":"Solver","title":"Thunderbolt.Preconditioners.L1GSPrecBuilder","text":"L1GSPrecBuilder(setting::AbstractBackendSetting)\n\nA builder for the L1 Gauss-Seidel preconditioner. This struct encapsulates the backend setting and provides a method to build the preconditioner.\n\nFields\n\nbacksetting::BackendSetting: The backend setting used for the preconditioner (e.g. CPUSetting, GPUSetting). More info CPUSetting & GPUSetting\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.Preconditioners.L1GSPreconditioner","page":"Solver","title":"Thunderbolt.Preconditioners.L1GSPreconditioner","text":"L1GSPreconditioner{Partitioning, VectorType}\n\nThe ℓ₁ Gauss–Seidel preconditioner is a robust and parallel-friendly preconditioner for sparse matrices.\n\nAlgorithm\n\nThe L1-GS preconditioner is constructed by dividing the matrix into diagonal blocks nparts:\n\nLet Ωₖ denote the block with index k.\nFor each Ωₖ, we define the following sets:\n$ Ωⁱ := {j ∈ Ωₖ : i ∈ Ωₖ} $ → the set of columns in the diagonal block for row i\n$ Ωⁱₒ := {j ∉ Ωₖ : i ∈ Ωₖ} $ →  the remaining “off-diagonal” columns in row i\n\nThe preconditioner matrix M_ℓ_1  is defined as:\n\nM_ℓ_1GS = M_HGS + D^ℓ_1 \n\nWhere D^ℓ_1 is a diagonal matrix with entries: d_ii^ℓ_1 = sum_j  Ωⁱₒ a_ij, and M_HGS is obtained when the diagonal partitions are chosen to be the Gauss–Seidel sweeps on $ A_{kk} $\n\nFields\n\npartitioning: Encapsulates partitioning data (e.g. nparts, partsize, backend).\nD_Dl1: D+D^ℓ_1.\nSLbuffer: Strictly lower triangular part of all diagonal blocks stacked in a vector.\n\nReference\n\nBaker, A. H., Falgout, R. D., Kolev, T. V., & Yang, U. M. (2011).   Multigrid Smoothers for Ultraparallel Computing,   SIAM J. Sci. Comput., 33(5), 2864–2887.\n\nnote: Note\nFor now M_HGS applies only a forward sweep of the Gauss–Seidel method, which is a lower triangular matrix.  The interface will be extended in future versions to allow for backward and symmetric sweeps.\n\nExample\n\nbackend = CPU()\nbuilder = L1GSPrecBuilder(backend) # ≡ L1GSPrecBuilder(CPUSetting(Threads.nthreads()))\nN = 800\nA = spdiagm(0 => 2 * ones(N), -1 => -ones(N-1), 1 => -ones(N-1))\npartsize = 100 \nprec = builder(A, partsize)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Nonlinear","page":"Solver","title":"Nonlinear","text":"","category":"section"},{"location":"api-reference/solver/","page":"Solver","title":"Solver","text":"NewtonRaphsonSolver\nMultiLevelNewtonRaphsonSolver","category":"page"},{"location":"api-reference/solver/#Thunderbolt.NewtonRaphsonSolver","page":"Solver","title":"Thunderbolt.NewtonRaphsonSolver","text":"NewtonRaphsonSolver{T}\n\nClassical Newton-Raphson solver to solve nonlinear problems of the form F(u) = 0. To use the Newton-Raphson solver you have to dispatch on\n\nupdate_linearization!\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.MultiLevelNewtonRaphsonSolver","page":"Solver","title":"Thunderbolt.MultiLevelNewtonRaphsonSolver","text":"MultilevelNewtonRaphsonSolver{T}\n\nMultilevel Newton-Raphson solver RabSanHsu:1979:mna for nonlinear problems of the form F(u,v) = 0; G(u,v) = 0. To use the Multilevel solver you have to dispatch on\n\nupdate_linearization!\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Time","page":"Solver","title":"Time","text":"","category":"section"},{"location":"api-reference/solver/","page":"Solver","title":"Solver","text":"BackwardEulerSolver\nForwardEulerSolver\nForwardEulerCellSolver\nAdaptiveForwardEulerSubstepper\nLoadDrivenSolver","category":"page"},{"location":"api-reference/solver/#Thunderbolt.ForwardEulerCellSolver","page":"Solver","title":"Thunderbolt.ForwardEulerCellSolver","text":"Simple forward euler to solve the cell model.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Operator-Splitting-Module","page":"Solver","title":"Operator Splitting Module","text":"","category":"section"},{"location":"api-reference/solver/","page":"Solver","title":"Solver","text":"Thunderbolt.OS.LieTrotterGodunov\nThunderbolt.OS.GenericSplitFunction\nThunderbolt.OS.OperatorSplittingIntegrator","category":"page"},{"location":"api-reference/solver/#Thunderbolt.OS.LieTrotterGodunov","page":"Solver","title":"Thunderbolt.OS.LieTrotterGodunov","text":"LieTrotterGodunov <: AbstractOperatorSplittingAlgorithm\n\nA first order operator splitting algorithm attributed to [5–7].\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Thunderbolt.OS.OperatorSplittingIntegrator","page":"Solver","title":"Thunderbolt.OS.OperatorSplittingIntegrator","text":"OperatorSplittingIntegrator <: AbstractODEIntegrator\n\nA variant of ODEIntegrator to perform opeartor splitting.\n\nDerived from https://github.com/CliMA/ClimaTimeSteppers.jl/blob/ef3023747606d2750e674d321413f80638136632/src/integrators.jl.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/solver/#Operator-Splitting-Adaptivity","page":"Solver","title":"Operator Splitting Adaptivity","text":"","category":"section"},{"location":"api-reference/solver/","page":"Solver","title":"Solver","text":"Thunderbolt.ReactionTangentController","category":"page"},{"location":"api-reference/solver/#Thunderbolt.ReactionTangentController","page":"Solver","title":"Thunderbolt.ReactionTangentController","text":"ReactionTangentController{LTG <: OS.LieTrotterGodunov, T <: Real} <: OS.AbstractOperatorSplittingAlgorithm\n\nA timestep length controller for LieTrotterGodunov [5–7] operator splitting using the reaction tangent as proposed in [25] The next timestep length is calculated as\n\nsigmaleft(R_max right)=left(10-frac11+exp left(left(sigma_mathrmc-R_max right) cdot sigma_mathrmsright)right) cdotleft(Delta t_max -Delta t_min right)+Delta t_min \n\nFields\n\nltg::LTG: LieTrotterGodunov algorithm\nσ_s::T: steepness\nσ_c::T: offset in R axis\nΔt_bounds::NTuple{2,T}: lower and upper timestep length bounds\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/","page":"Element Interface","title":"Element Interface","text":"DocTestSetup = :(using Thunderbolt)","category":"page"},{"location":"devdocs/element_interface/#Element-Interface","page":"Element Interface","title":"Element Interface","text":"","category":"section"},{"location":"devdocs/element_interface/#Entry-Points","page":"Element Interface","title":"Entry Points","text":"","category":"section"},{"location":"devdocs/element_interface/","page":"Element Interface","title":"Element Interface","text":"Thunderbolt.AbstractVolumetricElementCache\nThunderbolt.AbstractSurfaceElementCache\nThunderbolt.AbstractInterfaceElementCache\nThunderbolt.assemble_element!\nThunderbolt.assemble_face!\nThunderbolt.assemble_interface!","category":"page"},{"location":"devdocs/element_interface/#Thunderbolt.AbstractVolumetricElementCache","page":"Element Interface","title":"Thunderbolt.AbstractVolumetricElementCache","text":"Supertype for all caches to integrate over volumes.\n\nInterface:\n\nsetup_element_cache(model, qr, sdh)\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.AbstractSurfaceElementCache","page":"Element Interface","title":"Thunderbolt.AbstractSurfaceElementCache","text":"Supertype for all caches to integrate over surfaces.\n\nInterface:\n\nsetup_boundary_cache(model, qr, sdh)\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.AbstractInterfaceElementCache","page":"Element Interface","title":"Thunderbolt.AbstractInterfaceElementCache","text":"Supertype for all caches to integrate over interfaces.\n\nInterface:\n\nsetup_interface_cache(model, qr, ip, sdh)\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.assemble_element!","page":"Element Interface","title":"Thunderbolt.assemble_element!","text":"assemble_element!(Kₑ::AbstractMatrix, cell::CellCache, element_cache::AbstractVolumetricElementCache, time)\n\nMain entry point for bilinear operators\n\nassemble_element!(Kₑ::AbstractMatrix, uₑ::AbstractVector, cell::CellCache, element_cache::AbstractVolumetricElementCache, time)\n\nUpdate element matrix in nonlinear operators\n\nassemble_element!(Kₑ::AbstractMatrix, residualₑ::AbstractVector, uₑ::AbstractVector, cell::CellCache, element_cache::AbstractVolumetricElementCache, time)\n\nUpdate element matrix and residual in nonlinear operators\n\nassemble_element!(residualₑ::AbstractVector, uₑ::AbstractVector, cell::CellCache, element_cache::AbstractVolumetricElementCache, time)\n\nUpdate residual in nonlinear operators\n\nThe notation is as follows.\n\nK_e\nthe element stiffness matrix\nu_e\nthe element unknowns\nresidual_e\nthe element residual\n\n\n\n\n\n","category":"function"},{"location":"devdocs/element_interface/#Thunderbolt.assemble_face!","page":"Element Interface","title":"Thunderbolt.assemble_face!","text":"assemble_face!(Kₑ::AbstractMatrix, cell::CellCache, face_cache::AbstractSurfaceElementCache, time)\n\nMain entry point for bilinear operators\n\nassemble_face!(Kₑ::AbstractMatrix, uₑ::AbstractVector, cell::CellCache, face_cache::AbstractSurfaceElementCache, time)\n\nUpdate face matrix in nonlinear operators\n\nassemble_face!(Kₑ::AbstractMatrix, residualₑ::AbstractVector, uₑ::AbstractVector, cell::CellCache, face_cache::AbstractSurfaceElementCache, time)\n\nUpdate face matrix and residual in nonlinear operators\n\nassemble_face!(residualₑ::AbstractVector, uₑ::AbstractVector, cell::CellCache, face_cache::AbstractSurfaceElementCache, time)\n\nUpdate residual in nonlinear operators\n\nThe notation is as follows.\n\nK_e\nthe element stiffness matrix\nu_e\nthe element unknowns\nresidual_e\nthe element residual\n\n\n\n\n\n","category":"function"},{"location":"devdocs/element_interface/#Thunderbolt.assemble_interface!","page":"Element Interface","title":"Thunderbolt.assemble_interface!","text":"assemble_interface!(Kₑ::AbstractMatrix, cell::CellCache, face_cache::AbstractSurfaceElementCache, time)\n\nMain entry point for bilinear operators\n\nassemble_interface!(Kₑ::AbstractMatrix, uₑ::AbstractVector, cell::CellCache, face_cache::AbstractSurfaceElementCache, time)\n\nUpdate face matrix in nonlinear operators\n\nassemble_interface!(Kₑ::AbstractMatrix, residualₑ::AbstractVector, uₑ::AbstractVector, cell::CellCache, face_cache::AbstractSurfaceElementCache, time)\n\nUpdate face matrix and residual in nonlinear operators\n\nassemble_interface!(residualₑ::AbstractVector, uₑ::AbstractVector, cell::CellCache, face_cache::AbstractSurfaceElementCache, time)\n\nUpdate residual in nonlinear operators\n\nThe notation is as follows.\n\nK_e\nthe element pair stiffness matrix\nu_e\nthe element pair unknowns\nresidual_e\nthe element pair residual\n\n\n\n\n\n","category":"function"},{"location":"devdocs/element_interface/#Common","page":"Element Interface","title":"Common","text":"","category":"section"},{"location":"devdocs/element_interface/","page":"Element Interface","title":"Element Interface","text":"Thunderbolt.AnalyticalCoefficientElementCache\nThunderbolt.SimpleFacetCache","category":"page"},{"location":"devdocs/element_interface/#Thunderbolt.AnalyticalCoefficientElementCache","page":"Element Interface","title":"Thunderbolt.AnalyticalCoefficientElementCache","text":"AnalyticalCoefficientElementCache(f(x,t)->..., nonzero_in_time_intervals, cellvalues)\n\nAnalytical coefficient described by a function in space and time. Can be sparse in time.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.SimpleFacetCache","page":"Element Interface","title":"Thunderbolt.SimpleFacetCache","text":"Standard cache for surface integrals.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Composite","page":"Element Interface","title":"Composite","text":"","category":"section"},{"location":"devdocs/element_interface/","page":"Element Interface","title":"Element Interface","text":"Thunderbolt.CompositeVolumetricElementCache\nThunderbolt.CompositeSurfaceElementCache\nThunderbolt.CompositeInterfaceElementCache","category":"page"},{"location":"devdocs/element_interface/#Thunderbolt.CompositeVolumetricElementCache","page":"Element Interface","title":"Thunderbolt.CompositeVolumetricElementCache","text":"This cache allows to combine multiple elements over the same volume. If surface caches are passed they are handled properly. This requred dispatching     isfacetincache(facet::FacetIndex, geometrycache, my_cache::MyCacheType)\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.CompositeSurfaceElementCache","page":"Element Interface","title":"Thunderbolt.CompositeSurfaceElementCache","text":"This cache allows to combine multiple elements over the same surface.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.CompositeInterfaceElementCache","page":"Element Interface","title":"Thunderbolt.CompositeInterfaceElementCache","text":"This cache allows to combine multiple elements over the same interface.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Bilinear","page":"Element Interface","title":"Bilinear","text":"","category":"section"},{"location":"devdocs/element_interface/","page":"Element Interface","title":"Element Interface","text":"Thunderbolt.BilinearMassIntegrator\nThunderbolt.BilinearMassElementCache\nThunderbolt.BilinearDiffusionIntegrator\nThunderbolt.BilinearDiffusionElementCache","category":"page"},{"location":"devdocs/element_interface/#Thunderbolt.BilinearMassIntegrator","page":"Element Interface","title":"Thunderbolt.BilinearMassIntegrator","text":"BilinearMassIntegrator{MT, CV}\n\nRepresents the integrand of the bilinearform a(uv) = int rho(x) v(x) u(x) dx for uv from the same function space with some given density field rho(x).\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.BilinearMassElementCache","page":"Element Interface","title":"Thunderbolt.BilinearMassElementCache","text":"The cache associated with BilinearMassIntegrator to assemble element mass matrices.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.BilinearDiffusionIntegrator","page":"Element Interface","title":"Thunderbolt.BilinearDiffusionIntegrator","text":"BilinearDiffusionIntegrator{CoefficientType}\n\nRepresents the integrand of the bilinear form a(uv) = -int nabla v(x) cdot D(x) nabla u(x) dx for a given diffusion tensor D(x) and uv from the same function space.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Thunderbolt.BilinearDiffusionElementCache","page":"Element Interface","title":"Thunderbolt.BilinearDiffusionElementCache","text":"The cache associated with BilinearDiffusionIntegrator to assemble element diffusion matrices.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/element_interface/#Solid-Mechanics","page":"Element Interface","title":"Solid Mechanics","text":"","category":"section"},{"location":"devdocs/element_interface/#Elements","page":"Element Interface","title":"Elements","text":"","category":"section"},{"location":"devdocs/element_interface/","page":"Element Interface","title":"Element Interface","text":"Thunderbolt.StructuralElementCache","category":"page"},{"location":"howto/custom-elements/","page":"Adding New Elements","title":"Adding New Elements","text":"EditURL = \"../literate-howto/custom-elements.jl\"","category":"page"},{"location":"howto/custom-elements/#how-to-custom-element","page":"Adding New Elements","title":"Adding New Elements","text":"","category":"section"},{"location":"howto/custom-elements/","page":"Adding New Elements","title":"Adding New Elements","text":"todo: Todo\nFinalize the element interface and document some examples here.","category":"page"},{"location":"howto/custom-elements/","page":"Adding New Elements","title":"Adding New Elements","text":"","category":"page"},{"location":"howto/custom-elements/","page":"Adding New Elements","title":"Adding New Elements","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"EditURL = \"../literate-howto/custom-stimulation-protocols.jl\"","category":"page"},{"location":"howto/custom-stimulation-protocols/#how-to-custom-stim-protocol","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"","category":"section"},{"location":"howto/custom-stimulation-protocols/#Analytical-protocols","page":"Custom Stimulation Protocols","title":"Analytical protocols","text":"","category":"section"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"The easiest way to implement a custom stimulation protocol is to use the AnalyticalTransmembraneStimulationProtocol","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"We start by define a struct holding all the parameters and make it callable. The return value is the stimulus strength. If you want to have parameters with spatial variation, which can be exchanged easily, then simply add a field with custom type and a function which accepts a coordinate x and a time t as input.","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"Here we want to have a very simple S1S2 protocol with two spherical stimulus applied in a modular fashion. Hence, we define a struct holding two callable functions and the windows for the Stimuli.","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"using Thunderbolt, StaticArrays\n\nstruct SimpleS1S2Protocol{S1Type, S2Type, WT} <: Function\n    S1::S1Type\n    S1_window::WT\n    S2::S2Type\n    S2_window::WT\nend","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"The function call then simply selects the correct stimulus with time offset, and return 0 outside of the intervals.","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"function (protocol::SimpleS1S2Protocol)(x,t)\n    if protocol.S1_window[1] < t < protocol.S1_window[2]\n        return protocol.S1(x,t-protocol.S1_window[1])\n    elseif protocol.S2_window[1] < t < protocol.S2_window[2]\n        return protocol.S2(x,t-protocol.S2_window[1])\n    end\n    return 0.0\nend","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"It is now possible to use the protocol as follows","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"coordinate_system_coefficient = CartesianCoordinateSystem{3}() # Or some cardiac coordinate system\nstimulus_around_zero(x,t) = max(1.0-norm(x),0.0)\nstimulus_around_one(x,t)  = max(1.0-norm(x+one(x)),0.0)\ns1s2fun = SimpleS1S2Protocol(\n    stimulus_around_zero, SVector((  0.0,   1.0)),\n    stimulus_around_one , SVector((200.0, 201.0)),\n)\nprotocol_nonzero_intervals = [s1s2fun.S1_window, s1s2fun.S2_window]\nprotocol = Thunderbolt.AnalyticalTransmembraneStimulationProtocol(\n    AnalyticalCoefficient(\n        s1s2fun,\n        coordinate_system_coefficient,\n    ),\n    protocol_nonzero_intervals,\n)","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"where the coordinatesystemcoefficient determines the type of coordiante passed into the protocol.","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"todo: Todo\nWe should develop a way to define custom stimulation protocols symbolically, e.g. via MTK.","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"","category":"page"},{"location":"howto/custom-stimulation-protocols/","page":"Custom Stimulation Protocols","title":"Custom Stimulation Protocols","text":"This page was generated using Literate.jl.","category":"page"},{"location":"topics/time-integration/#Time-Integration","page":"Time Integration","title":"Time Integration","text":"","category":"section"},{"location":"topics/time-integration/#theory_homotopy-path-methods","page":"Time Integration","title":"Homotopy path methods","text":"","category":"section"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"Homotopy path methods solve nonlinear problems with pseudo-time t on some time interval t_0 t_1. An initial guess is provided for the first nonlinear solve. Formally we can write down the problem as follows. Find u(t) such that","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"0 = F(u(t) p t) qquad texton  t_0 t_1","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"where u usually descibes the displacement of some mechanical system and the operator F contains some mechanical load, hence a subclass of these methods are so-called load stepping techniques. For mechanical problems we obtain systems with this form if we assume that inertial terms are neglibile (rho d^2_tu approx 0).","category":"page"},{"location":"topics/time-integration/#theory_operator-splitting","page":"Time Integration","title":"Operator Splitting","text":"","category":"section"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"For operator splitting procedures we assume that we have some time-dependent problem with initial condition u_0 = u(t_0) and an operator F describing the right hand side. We assume that F can be additively split into N suboperators F_i. This can be formally written as","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"d_t u(t) = F(u(t) p t) = F_1(u(t) p t) +  + F_N(u(t) p t)  ","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"We call t time the u(t) the state of the system. This way we can define subproblems","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"beginaligned\n    d_t u(t) = F_1(u(t) p t) \n              vdots \n    d_t u(t) = F_N(u(t) p t)\nendaligned","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"Now, the key idea of operator splitting methods is that solving the subproblems can be easier, and hopefully more efficient, than solving the full problem. Arguably the easiest algorithm to advance the solution from t_0 to some time point t_1  t_0 is the Lie-Trotter-Godunov operator splitting [5–7]. Here the subproblems are solved consecutively, where the solution of one subproblem is taken as the initial guess for the next subproblem, until we have  solved all subproblems. In this case we have constructed an approximation  for u(t_1).","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"More formally we can write the Lie-Trotter-Godunov scheme [5–7] as follows:","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"beginaligned\n    textSolve quad d_t u^1(t) = F_1(u^1(t) p t)   quad texton  t_0 t_1  textwith  u^1(t_0) = u_0 \n    textSolve quad d_t u^2(t) = F_2(u^2(t) p t)   quad texton  t_0 t_1  textwith  u^2(t_0) = u^1(t_1) \n              vdots   \n    textSolve quad d_t u^N(t) = F_N(u^N(t) p t)   quad texton  t_0 t_1  textwith  u^N(t_0) = u^N-1(t_1)\nendaligned","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"Such that we obtain the approximation u(t_1) approx u^N-1(t_1). The approximation is first order in time, as we will show in the next section.","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"Probably the most widely spread application for operator splitting schemes is the solution forreaction diffusion systems. These have the form","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"d_t u(t) = Lu + R(u)","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"where L is some linear operator, usually coming from the linaerization of diffusion opeartors and a nonlinear reaction part R which has some interesting locality properties. This locallity property usually tells us that the time evolution of R natually decouples into many small blocks. This way we only have to solve for the time evolution of a linear problem d_t u(t) = Lu and a set of many very small nonlinear problems d_t u(t) = R(u).","category":"page"},{"location":"topics/time-integration/#Analysis-of-Lie-Trotter-Godunov","page":"Time Integration","title":"Analysis of Lie-Trotter-Godunov","text":"","category":"section"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"It should be noted that even if we solve all subproblems analytically, then operator splitting schemes themselves almost always come with their own approximation error, which is simply called the splitting error. For linear problems this error can vanish if all suboperators F_i commute, i.e. if F_j cdot F_i = F_i cdot F_j for all 1 leq ij leq N, which can be shown with the Baker-Campbell-Hausdorff formula. Let us investigate the convergence order for two bounded linear operators L_1 and L_2, i.e. on the following system of ODEs","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"d_t u = L_1 u + L_2 u  ","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"Here the exact solution u at time point t for some initial condition at t_0 = 0 is","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"u(t) = e^(L_1 + L_2)t u_0  ","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"while the solution for the Lie-Trotter-Godunov scheme is","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"tildeu(t) = e^L_1te^L_2t u_0  ","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"The local truncation error can be written as","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"epsilon(t) = e^L_1te^L_2t - e^(L_1 + L_2)t  u_0","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"if we now replace the exponentials with their definitions we obtain for the first norm","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"beginaligned\n(I + tL_1 + frach^22L_1^2 + )(I + tL_2 + frach^22L_2^2 + ) - (I + t(L_1 + L_2) + frach^22(L_1+L_2)^2 + )\n= frach^22 (L_1 L_2 - L_2 L_1) +   leq frach^22  (L_1 L_2 - L_2 L_1)  + O(h^3)\nendaligned","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"This shows that the local truncation error is O(h^2) and hence the scheme is first order accurate.","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"Showing stability is also straight forward. We assumed that L_1 and L_2 are bounded, so we obtain for all time points t  t and all repeated subdivisions n in mathbbN the following bound","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"(e^L_1fractne^L_2fractn)^n\nleq e^L_1fractne^L_2fractn^n\nleq e^L_1fractn^n e^L_2fractn^n\nleq e^L_1t e^L_2t\nleq e^L_1t e^L_2t\nleq C  infty","category":"page"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"which implies stability of the scheme.","category":"page"},{"location":"topics/time-integration/#References","page":"Time Integration","title":"References","text":"","category":"section"},{"location":"topics/time-integration/","page":"Time Integration","title":"Time Integration","text":"S. Lie. Theorie der Transformationsgruppen I. Mathematische Annalen 16, 441–528 (1880).\n\n\n\nH. F. Trotter. On the Product of Semi-Groups of Operators. Proceedings of the American Mathematical Society 10, 545–551 (1959).\n\n\n\nS. K. Godunov. A difference method for numerical calculation of discontinuous solutions of the equations of hydrodynamics. Matematicheskii Sbornik 89, 271–306 (1959).\n\n\n\n","category":"page"},{"location":"api-reference/operators/","page":"Operators","title":"Operators","text":"DocTestSetup = :(using Thunderbolt)","category":"page"},{"location":"api-reference/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"api-reference/operators/","page":"Operators","title":"Operators","text":"BlockOperator\nThunderbolt.AbstractNonlinearOperator\nThunderbolt.AbstractBilinearOperator\nThunderbolt.AbstractLinearOperator\nAssembledNonlinearOperator\nAssembledBilinearOperator\nDiagonalOperator\nNullOperator\nLinearNullOperator\nLinearOperator","category":"page"},{"location":"api-reference/operators/#Thunderbolt.AbstractNonlinearOperator","page":"Operators","title":"Thunderbolt.AbstractNonlinearOperator","text":"AbstractNonlinearOperator\n\nModels of a nonlinear function F(u)v, where v is a test function.\n\nInterface:     (op::AbstractNonlinearOperator)(residual::AbstractVector, in::AbstractNonlinearOperator)     eltype()     size()\n\n# linearization\nmul!(out::AbstractVector, op::AbstractNonlinearOperator, in::AbstractVector)\nmul!(out::AbstractVector, op::AbstractNonlinearOperator, in::AbstractVector, α, β)\nupdate_linearization!(op::AbstractNonlinearOperator, u::AbstractVector, time)\nupdate_linearization!(op::AbstractNonlinearOperator, residual::AbstractVector, u::AbstractVector, time)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/operators/#Thunderbolt.AbstractLinearOperator","page":"Operators","title":"Thunderbolt.AbstractLinearOperator","text":"AbstractLinearOperator\n\nSupertype for operators which only depend on the test space.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/domain_management/#Domain-management","page":"Domain management","title":"Domain management","text":"","category":"section"},{"location":"devdocs/domain_management/","page":"Domain management","title":"Domain management","text":"Having multiple coupled subdomains is very common in multiphyics problems. Furthermore it is also not uncommon to have mixed(-dimensional) grids, think e.g. about the Purkinje network and the myocardium in chamber electrophysiology simulations. To manage these cases Thunderbolt.jl comes with some utilities. The first one is the SimpleMesh, which is takes a [Ferrite.Grid] and extracts information about the subdomains. The subdomains are split up by element type to handle mixed grids properly.","category":"page"},{"location":"devdocs/domain_management/","page":"Domain management","title":"Domain management","text":"This subdomain information can then be used to construct [Ferrite.SubDofHandler] to manage the field variables on subdomains:","category":"page"},{"location":"devdocs/domain_management/","page":"Domain management","title":"Domain management","text":"Thunderbolt.add_subdomain!\nThunderbolt.ApproximationDescriptor","category":"page"},{"location":"devdocs/domain_management/#Thunderbolt.ApproximationDescriptor","page":"Domain management","title":"Thunderbolt.ApproximationDescriptor","text":"ApproximationDescriptor(symbol, interpolation_collection)\n\n\n\n\n\n","category":"type"},{"location":"devdocs/domain_management/","page":"Domain management","title":"Domain management","text":"Furthermore to manage data on subdomains we provide a non-uniform matrix-like data type.","category":"page"},{"location":"devdocs/domain_management/","page":"Domain management","title":"Domain management","text":"Thunderbolt.DenseDataRange\nThunderbolt.get_data_for_index","category":"page"},{"location":"devdocs/domain_management/#Thunderbolt.DenseDataRange","page":"Domain management","title":"Thunderbolt.DenseDataRange","text":"Examples:\n\nDenseDataRange{Vector{Int}, Vector{Int}} to map dofs (outer index) to elements (inner index)\nDenseDataRange{Vector{Vec{3,Float64}}, Vector{Int}} to store fluxes per quadrature point (inner index) per element (outer index)\n\n\n\n\n\n","category":"type"},{"location":"devdocs/domain_management/","page":"Domain management","title":"Domain management","text":"Two examples where this is used: The storate of element assembly and quadrature data on mixed grids.","category":"page"},{"location":"devdocs/domain_management/#Multidomain-Assembly","page":"Domain management","title":"Multidomain Assembly","text":"","category":"section"},{"location":"devdocs/domain_management/","page":"Domain management","title":"Domain management","text":"The operators in Thunderbolt work very similar w.r.t. the management of multiple domains. The all follow the following pattern:","category":"page"},{"location":"devdocs/domain_management/","page":"Domain management","title":"Domain management","text":"function update_operator(op, time)\n    # Sanity check to see if the operator is internally consistent\n    # e.g. are all fields are present in the associated dof handlers, ...\n    check_internal_correctness(op)\n    # Depending on the operator and matrix type we get the correct assembler\n    assembler = instantiate_specific_assembler(op)\n    for sdh in op.dh.subdofhandlers\n        # We create a new or get a from the operator some scratch to make the assembly loop allocation free\n        # and possibly to precompute some generic stuff\n        weak_form_cache = setup_or_query_cache_for_subdomain(op, sdh)\n        # This step also acts a function barrier and contains the hot loop over the elements on the subdomain\n        # which actually fills the matrix\n        assemble_on_subdomain!(assembler, sdh, weak_form_cache)\n    end\n    # Some assemblers need a finalization step, e.g. distributed assembly, COO assembly, EA collapse, ...\n    finalize_assembly(assembler)","category":"page"},{"location":"api-reference/#API-Reference-Overview","page":"Overview","title":"API Reference Overview","text":"","category":"section"},{"location":"api-reference/","page":"Overview","title":"Overview","text":"Pages = [\n    \"models.md\",\n    \"mesh.md\",\n    \"functions.md\",\n    \"problems.md\",\n    \"discretization.md\",\n    \"operators.md\",\n    \"solver.md\",\n    \"utility.md\",\n]","category":"page"},{"location":"topics/#Topic-Guide-Overview","page":"Overview","title":"Topic Guide Overview","text":"","category":"section"},{"location":"topics/","page":"Overview","title":"Overview","text":"Coming soon...","category":"page"},{"location":"tutorials/ep02_purkinje/","page":"EP02: Purkinje Network (TODO)","title":"EP02: Purkinje Network (TODO)","text":"EditURL = \"../literate-tutorials/ep02_purkinje.jl\"","category":"page"},{"location":"tutorials/ep02_purkinje/#ep-tutorial_purkinje","page":"EP02: Purkinje Network (TODO)","title":"Electrophysiology Tutorial 2: User Models","text":"","category":"section"},{"location":"tutorials/ep02_purkinje/","page":"EP02: Purkinje Network (TODO)","title":"EP02: Purkinje Network (TODO)","text":"todo: Todo\nUpload and reference my coupled simulation","category":"page"},{"location":"tutorials/ep02_purkinje/","page":"EP02: Purkinje Network (TODO)","title":"EP02: Purkinje Network (TODO)","text":"This tutorial shows how to generate a Purkinje network and how to couple it with the chamber.","category":"page"},{"location":"tutorials/ep02_purkinje/","page":"EP02: Purkinje Network (TODO)","title":"EP02: Purkinje Network (TODO)","text":"todo: Todo\nProvide context.","category":"page"},{"location":"tutorials/ep02_purkinje/#Commented-Program","page":"EP02: Purkinje Network (TODO)","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/ep02_purkinje/","page":"EP02: Purkinje Network (TODO)","title":"EP02: Purkinje Network (TODO)","text":"todo: Todo\nFinalize subdomain management first and we need the volumetric intersection.","category":"page"},{"location":"tutorials/ep02_purkinje/#References","page":"EP02: Purkinje Network (TODO)","title":"References","text":"","category":"section"},{"location":"tutorials/ep02_purkinje/","page":"EP02: Purkinje Network (TODO)","title":"EP02: Purkinje Network (TODO)","text":"","category":"page"},{"location":"tutorials/ep02_purkinje/#ep-tutorial_purkinje-plain-program","page":"EP02: Purkinje Network (TODO)","title":"Plain program","text":"","category":"section"},{"location":"tutorials/ep02_purkinje/","page":"EP02: Purkinje Network (TODO)","title":"EP02: Purkinje Network (TODO)","text":"Here follows a version of the program without any comments. The file is also available here: ep02_purkinje.jl.","category":"page"},{"location":"tutorials/ep02_purkinje/","page":"EP02: Purkinje Network (TODO)","title":"EP02: Purkinje Network (TODO)","text":"","category":"page"},{"location":"tutorials/ep02_purkinje/","page":"EP02: Purkinje Network (TODO)","title":"EP02: Purkinje Network (TODO)","text":"","category":"page"},{"location":"tutorials/ep02_purkinje/","page":"EP02: Purkinje Network (TODO)","title":"EP02: Purkinje Network (TODO)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api-reference/functions/","page":"Functions","title":"Functions","text":"DocTestSetup = :(using Thunderbolt)","category":"page"},{"location":"api-reference/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"api-reference/functions/","page":"Functions","title":"Functions","text":"Thunderbolt.AbstractSemidiscreteFunction\nThunderbolt.AbstractSemidiscreteBlockedFunction\nThunderbolt.AbstractSemidiscreteODEFunction\nThunderbolt.AbstractSemidiscreteDAEFunction\nThunderbolt.AbstractQuasiStaticFunction\nTransientDiffusionFunction\nSteadyDiffusionFunction\nPointwiseODEFunction\nQuasiStaticNonlinearFunction\nRSAFDQ20223DFunction","category":"page"},{"location":"api-reference/functions/#Thunderbolt.AbstractSemidiscreteFunction","page":"Functions","title":"Thunderbolt.AbstractSemidiscreteFunction","text":"AbstractSemidiscreteFunction <: DiffEqBase.AbstractDiffEqFunction{iip=true}\n\nSupertype for all functions coming from PDE discretizations.\n\nInterface\n\nsolution_size(::AbstractSemidiscreteFunction)\nget_strategy(::AbstractSemidiscreteFunction)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/functions/#Thunderbolt.AbstractSemidiscreteBlockedFunction","page":"Functions","title":"Thunderbolt.AbstractSemidiscreteBlockedFunction","text":"AbstractSemidiscreteBlockedFunction <: AbstractSemidiscreteFunction\n\nSupertype for all functions coming from PDE discretizations with blocked structure.\n\nInterface\n\nBlockArrays.blocksizes(::AbstractSemidiscreteFunction)\nBlockArrays.blocks(::AbstractSemidiscreteFunction) -> Iterable\n\n\n\n\n\n","category":"type"},{"location":"api-reference/functions/","page":"Functions","title":"Functions","text":"AbstractOperatorSplitFunction\nGenericSplitFunction","category":"page"},{"location":"api-reference/functions/#Thunderbolt.OS.GenericSplitFunction","page":"Functions","title":"Thunderbolt.OS.GenericSplitFunction","text":"GenericSplitFunction(functions::Tuple, solution_indices::Tuple)\nGenericSplitFunction(functions::Tuple, solution_indices::Tuple, syncronizers::Tuple)\n\nThis type of function describes a set of connected inner functions in mass-matrix form, as usually found in operator splitting procedures.\n\nnote: Automatic sync\nWe should be able to get rid of the synchronizer and handle the connection of coefficients and solutions in semidiscretize.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"EditURL = \"../literate-tutorials/cm01_simple-active-stress.jl\"","category":"page"},{"location":"tutorials/cm01_simple-active-stress/#mechanics-tutorial_simple-active-stress","page":"CM01: Simple Active Stress","title":"Mechanics Tutorial 1: Simple Contracting Ventricle","text":"","category":"section"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"(Image: Contracting Left Ventricle)","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"This tutorial shows how to perform a simulation for simple active mechanical behavior of heart chambers.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/#Introduction","page":"CM01: Simple Active Stress","title":"Introduction","text":"","category":"section"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"A general model to simulate the contractile behavior of cardiact issues it the active stress model. Let us denote with Omega_mathrmH our heart domain and with u  Omega_mathrmH to mathbbR^3 the unknown displacement field in three dimensional space. This induces a deformation gradient bmF = bmI + nabla bmu. With this formulation we can define a large class of active stress models in the first Piola-Kirchhoff stress with the following form:","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"bmP = partial_bmF psi_mathrmp + mathcalN(bmalpha)  partial_bmF psi_mathrma","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"According to Chadwick [1] the additive split of the stress in active and passive parts dates back to unpublished Peskin and has been popularized by Guccione et al. [2].","category":"page"},{"location":"tutorials/cm01_simple-active-stress/#Commented-Program","page":"CM01: Simple Active Stress","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"We start by loading Thunderbolt and LinearSolve to use a custom direct solver of our choice.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"using Thunderbolt, LinearSolve","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Our goal is to simulate the contraction of a left ventricle with a very simple active stress formulation. Hence in a first step we need to load a suitable mesh. Thunderbolt can generate idealized geometries as follows.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"mesh = generate_ideal_lv_mesh(11,2,5;\n    inner_radius = 0.7,\n    outer_radius = 1.0,\n    longitudinal_upper = 0.2,\n    apex_inner = 1.3,\n    apex_outer = 1.5\n);\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Here the first 3 parameters control the number of elements in circumferential, radial and longitudinal directions. The number of elements is very low, so users have an easy time to play around with it. For scientific studies the mesh needs to be finer, such that the simulation converges properly. The remaining parameters control the chamber geometry shape itself.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"tip: Tip\nWe can also load realistic geometries with external formats. For this simply use either FerriteGmsh.jl or one of the loader functions stated in the mesh API.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Next we will define a coordinate system, which helps us to work with cardiac geometries. This way we can reuse different methods, like for example fiber generators, across geometries.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"coordinate_system = compute_lv_coordinate_system(mesh);\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"In this coordinate system we will now create a microstructure with linearly varying helix angle in transmural direction. The compute microstructure field will be generated on the function space of piecewise continuous first order Lagrange polynomials.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"microstructure = create_microstructure_model(\n    coordinate_system,\n    LagrangeCollection{1}()^3,\n    ODB25LTMicrostructureParameters(),\n);\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Now we describe the model which we want to use. The models provided by Thunderbolt are designed to be highly modular, so you can quickly swap out individual component or compose models with each other. For the active stress formulation we need first the active and passive material models. For this tutorial we use the models described by Guccione.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"passive_material_model = Guccione1991PassiveModel()\nactive_material_model  = Guccione1993ActiveModel();\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Furthermore we need to describe the calcium field and associate it with the sarcomere model. To simplify this tutorial we will use an analytical calcium profile. Note that we can also use experimental data or a precomputed calcium profile here, too, by simply changing the function implementation below.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"function calcium_profile_function(x::LVCoordinate,t)\n    linear_interpolation(t,y1,y2,t1,t2) = y1 + (t-t1) * (y2-y1)/(t2-t1)\n    ca_peak(x)                          = 1.0\n    if 0 ≤ t ≤ 300.0\n        return linear_interpolation(t,        0.0, ca_peak(x),   0.0, 300.0)\n    elseif t ≤ 500.0\n        return linear_interpolation(t, ca_peak(x),        0.0, 300.0, 500.0)\n    else\n        return 0.0\n    end\nend\ncalcium_field = AnalyticalCoefficient(\n    calcium_profile_function,\n    coordinate_system,\n);\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"We will use for a very simple sarcomere model which is constant in the calcium concentration. Note that a using a sarcomere model which has evoluation equations or rate-dependent terms will require different solvers.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"sarcomere_model = CaDrivenInternalSarcomereModel(ConstantStretchModel(), calcium_field);\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Now we have everything set to describe our active stress model by passing all the model components into it.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"active_stress_model = ActiveStressModel(\n    passive_material_model,\n    active_material_model,\n    sarcomere_model,\n    microstructure,\n);\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Next we define some boundary conditions. In order to have a very rough approximation of the effect of the pericardium, we use a Robin boundary condition in normal direction.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"weak_boundary_conditions = (NormalSpringBC(1.0, \"Epicardium\"),)","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"We finalize the mechanical model by assigning a symbol to identify the unknown solution field and connect the active stress model with the weak boundary conditions.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"mechanical_model = QuasiStaticModel(:displacement, active_stress_model, weak_boundary_conditions)","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"tip: Tip\nA full list of all models can be found in the API reference.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"We now need to transform the space-time problem into a time-dependent problem by discretizing it spatially. This can be accomplished by the function semidiscretize, which takes a model and the disretization technique. Here we use a finite element discretization in space with first order Lagrange polynomials to discretize the displacement field.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"danger: Danger\nThe discretization API does now play well with multiple domains right now and will be updated with a possible breaking change in future releases.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"spatial_discretization_method = FiniteElementDiscretization(\n    Dict(:displacement => LagrangeCollection{1}()^3),\n)\nquasistaticform = semidiscretize(mechanical_model, spatial_discretization_method, mesh);\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"The remaining code is very similar to how we use SciML solvers. We first define our time domain, initial time step length and some dt for visualization.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"dt₀ = 10.0\ntspan = (0.0, 500.0)\ndtvis = 25.0;\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"This speeds up the CI # hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"tspan = (0.0, dtvis);   # hide\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Then we setup the problem. Since we have no time dependence in our active stress model the correct problem here is a quasistatic problem.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"problem = QuasiStaticProblem(quasistaticform, tspan);\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Next we define the time stepper. Since there are no time derivatives appearing in our formulation we have to opt for a homotopy path method, which solve the time depentent problems adaptively. As our non-linear solver we choose the standard Newton-Raphson method and a direct solver for the inner linear system. For the theory behind homotopy path methods we refer to the corresponding theory manual on homotopy path methods","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"timestepper = HomotopyPathSolver(\n    NewtonRaphsonSolver(\n        max_iter=10,\n        inner_solver=LinearSolve.UMFPACKFactorization(),\n    )\n);\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Now we initialize our time integrator as usual.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"integrator = init(problem, timestepper, dt=dt₀, verbose=true, adaptive=true, dtmax=25.0);\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"todo: Todo\nThe post-processing API is not yet finished. Please revisit the tutorial later to see how to post-process the simulation online. Right now the solution is just exported into VTK, such that users can visualize the solution in e.g. ParaView.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Finally we solve the problem in time.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"io = ParaViewWriter(\"CM01_simple_lv\");\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    @info t\n    (; dh) = problem.f\n    Thunderbolt.store_timestep!(io, t, dh.grid) do file\n    Thunderbolt.store_timestep_field!(io, t, dh, u, :displacement)\n    end\nend;\nnothing #hide","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"tip: Tip\nIf you want to see more details of the solution process launch Julia with Thunderbolt as debug module:JULIA_DEBUG=Thunderbolt julia --project --threads=auto my_simulation_runner.jl","category":"page"},{"location":"tutorials/cm01_simple-active-stress/#References","page":"CM01: Simple Active Stress","title":"References","text":"","category":"section"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"R. Chadwick. Mechanics of the left ventricle. Biophysical journal 39, 279–288 (1982).\n\n\n\nJ. M. Guccione, L. K. Waldman and A. D. McCulloch. Mechanics of Active Contraction in Cardiac Muscle: Part II—Cylindrical Models of the Systolic Left Ventricle. Journal of Biomechanical Engineering 115, 82–90 (1993).\n\n\n\n","category":"page"},{"location":"tutorials/cm01_simple-active-stress/#mechanics-tutorial_simple-active-stress-plain-program","page":"CM01: Simple Active Stress","title":"Plain program","text":"","category":"section"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"Here follows a version of the program without any comments. The file is also available here: cm01_simple-active-stress.jl.","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"using Thunderbolt, LinearSolve\n\nmesh = generate_ideal_lv_mesh(11,2,5;\n    inner_radius = 0.7,\n    outer_radius = 1.0,\n    longitudinal_upper = 0.2,\n    apex_inner = 1.3,\n    apex_outer = 1.5\n);\n\ncoordinate_system = compute_lv_coordinate_system(mesh);\n\nmicrostructure = create_microstructure_model(\n    coordinate_system,\n    LagrangeCollection{1}()^3,\n    ODB25LTMicrostructureParameters(),\n);\n\npassive_material_model = Guccione1991PassiveModel()\nactive_material_model  = Guccione1993ActiveModel();\n\nfunction calcium_profile_function(x::LVCoordinate,t)\n    linear_interpolation(t,y1,y2,t1,t2) = y1 + (t-t1) * (y2-y1)/(t2-t1)\n    ca_peak(x)                          = 1.0\n    if 0 ≤ t ≤ 300.0\n        return linear_interpolation(t,        0.0, ca_peak(x),   0.0, 300.0)\n    elseif t ≤ 500.0\n        return linear_interpolation(t, ca_peak(x),        0.0, 300.0, 500.0)\n    else\n        return 0.0\n    end\nend\ncalcium_field = AnalyticalCoefficient(\n    calcium_profile_function,\n    coordinate_system,\n);\n\nsarcomere_model = CaDrivenInternalSarcomereModel(ConstantStretchModel(), calcium_field);\n\nactive_stress_model = ActiveStressModel(\n    passive_material_model,\n    active_material_model,\n    sarcomere_model,\n    microstructure,\n);\n\nweak_boundary_conditions = (NormalSpringBC(1.0, \"Epicardium\"),)\n\nmechanical_model = QuasiStaticModel(:displacement, active_stress_model, weak_boundary_conditions)\n\nspatial_discretization_method = FiniteElementDiscretization(\n    Dict(:displacement => LagrangeCollection{1}()^3),\n)\nquasistaticform = semidiscretize(mechanical_model, spatial_discretization_method, mesh);\n\ndt₀ = 10.0\ntspan = (0.0, 500.0)\ndtvis = 25.0;\n\ntspan = (0.0, dtvis);   # hide\n\nproblem = QuasiStaticProblem(quasistaticform, tspan);\n\ntimestepper = HomotopyPathSolver(\n    NewtonRaphsonSolver(\n        max_iter=10,\n        inner_solver=LinearSolve.UMFPACKFactorization(),\n    )\n);\n\nintegrator = init(problem, timestepper, dt=dt₀, verbose=true, adaptive=true, dtmax=25.0);\n\nio = ParaViewWriter(\"CM01_simple_lv\");\nfor (u, t) in TimeChoiceIterator(integrator, tspan[1]:dtvis:tspan[2])\n    @info t\n    (; dh) = problem.f\n    Thunderbolt.store_timestep!(io, t, dh.grid) do file\n    Thunderbolt.store_timestep_field!(io, t, dh, u, :displacement)\n    end\nend;","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"","category":"page"},{"location":"tutorials/cm01_simple-active-stress/","page":"CM01: Simple Active Stress","title":"CM01: Simple Active Stress","text":"This page was generated using Literate.jl.","category":"page"},{"location":"howto/custom-energies/","page":"Adding Energies","title":"Adding Energies","text":"EditURL = \"../literate-howto/custom-energies.jl\"","category":"page"},{"location":"howto/custom-energies/#how-to-custom-energy","page":"Adding Energies","title":"Adding Energies","text":"","category":"section"},{"location":"howto/custom-energies/","page":"Adding Energies","title":"Adding Energies","text":"todo: Todo\nFinalize the element interface and document some examples here.","category":"page"},{"location":"howto/custom-energies/","page":"Adding Energies","title":"Adding Energies","text":"","category":"page"},{"location":"howto/custom-energies/","page":"Adding Energies","title":"Adding Energies","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/ep06_pacemaker/","page":"EP06: Pacemakers (TODO)","title":"EP06: Pacemakers (TODO)","text":"EditURL = \"../literate-tutorials/ep06_pacemaker.jl\"","category":"page"},{"location":"tutorials/ep06_pacemaker/#ep-tutorial_pacemaker","page":"EP06: Pacemakers (TODO)","title":"Electrophysiology Tutorial 6: Pacemakers","text":"","category":"section"},{"location":"tutorials/ep06_pacemaker/","page":"EP06: Pacemakers (TODO)","title":"EP06: Pacemakers (TODO)","text":"todo: Todo\nShow activation timings.","category":"page"},{"location":"tutorials/ep06_pacemaker/","page":"EP06: Pacemakers (TODO)","title":"EP06: Pacemakers (TODO)","text":"This tutorial shows how to solve Eikonal models and how to recover transemembrane potential fields.","category":"page"},{"location":"tutorials/ep06_pacemaker/","page":"EP06: Pacemakers (TODO)","title":"EP06: Pacemakers (TODO)","text":"todo: Todo\nProvide context.","category":"page"},{"location":"tutorials/ep06_pacemaker/#Commented-Program","page":"EP06: Pacemakers (TODO)","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/ep06_pacemaker/#References","page":"EP06: Pacemakers (TODO)","title":"References","text":"","category":"section"},{"location":"tutorials/ep06_pacemaker/","page":"EP06: Pacemakers (TODO)","title":"EP06: Pacemakers (TODO)","text":"","category":"page"},{"location":"tutorials/ep06_pacemaker/#ep-tutorial_pacemaker-plain-program","page":"EP06: Pacemakers (TODO)","title":"Plain program","text":"","category":"section"},{"location":"tutorials/ep06_pacemaker/","page":"EP06: Pacemakers (TODO)","title":"EP06: Pacemakers (TODO)","text":"Here follows a version of the program without any comments. The file is also available here: ep06_pacemaker.jl.","category":"page"},{"location":"tutorials/ep06_pacemaker/","page":"EP06: Pacemakers (TODO)","title":"EP06: Pacemakers (TODO)","text":"","category":"page"},{"location":"tutorials/ep06_pacemaker/","page":"EP06: Pacemakers (TODO)","title":"EP06: Pacemakers (TODO)","text":"","category":"page"},{"location":"tutorials/ep06_pacemaker/","page":"EP06: Pacemakers (TODO)","title":"EP06: Pacemakers (TODO)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/ep05_eikonal/","page":"EP05: Eikonal Models (WIP)","title":"EP05: Eikonal Models (WIP)","text":"EditURL = \"../literate-tutorials/ep05_eikonal.jl\"","category":"page"},{"location":"tutorials/ep05_eikonal/#ep-tutorial_eikonal","page":"EP05: Eikonal Models (WIP)","title":"Electrophysiology Tutorial 5: Eikonal Models","text":"","category":"section"},{"location":"tutorials/ep05_eikonal/","page":"EP05: Eikonal Models (WIP)","title":"EP05: Eikonal Models (WIP)","text":"todo: Todo\nShow activation timings.","category":"page"},{"location":"tutorials/ep05_eikonal/","page":"EP05: Eikonal Models (WIP)","title":"EP05: Eikonal Models (WIP)","text":"This tutorial shows how to solve Eikonal models and how to recover transemembrane potential fields.","category":"page"},{"location":"tutorials/ep05_eikonal/","page":"EP05: Eikonal Models (WIP)","title":"EP05: Eikonal Models (WIP)","text":"todo: Todo\nProvide context.","category":"page"},{"location":"tutorials/ep05_eikonal/#Commented-Program","page":"EP05: Eikonal Models (WIP)","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/ep05_eikonal/#References","page":"EP05: Eikonal Models (WIP)","title":"References","text":"","category":"section"},{"location":"tutorials/ep05_eikonal/","page":"EP05: Eikonal Models (WIP)","title":"EP05: Eikonal Models (WIP)","text":"","category":"page"},{"location":"tutorials/ep05_eikonal/#ep-tutorial_eikonal-plain-program","page":"EP05: Eikonal Models (WIP)","title":"Plain program","text":"","category":"section"},{"location":"tutorials/ep05_eikonal/","page":"EP05: Eikonal Models (WIP)","title":"EP05: Eikonal Models (WIP)","text":"Here follows a version of the program without any comments. The file is also available here: ep05_eikonal.jl.","category":"page"},{"location":"tutorials/ep05_eikonal/","page":"EP05: Eikonal Models (WIP)","title":"EP05: Eikonal Models (WIP)","text":"","category":"page"},{"location":"tutorials/ep05_eikonal/","page":"EP05: Eikonal Models (WIP)","title":"EP05: Eikonal Models (WIP)","text":"","category":"page"},{"location":"tutorials/ep05_eikonal/","page":"EP05: Eikonal Models (WIP)","title":"EP05: Eikonal Models (WIP)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api-reference/utility/","page":"Utility","title":"Utility","text":"DocTestSetup = :(using Thunderbolt)","category":"page"},{"location":"api-reference/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"api-reference/utility/#Collections","page":"Utility","title":"Collections","text":"","category":"section"},{"location":"api-reference/utility/","page":"Utility","title":"Utility","text":"Thunderbolt.InterpolationCollection\ngetinterpolation\nThunderbolt.ScalarInterpolationCollection\nThunderbolt.VectorInterpolationCollection\nThunderbolt.VectorizedInterpolationCollection\nLagrangeCollection\nQuadratureRuleCollection\ngetquadraturerule\nCellValueCollection\nFacetValueCollection","category":"page"},{"location":"api-reference/utility/#Thunderbolt.InterpolationCollection","page":"Utility","title":"Thunderbolt.InterpolationCollection","text":"InterpolationCollection\n\nA collection of compatible interpolations over some (possilby different) cells.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.ScalarInterpolationCollection","page":"Utility","title":"Thunderbolt.ScalarInterpolationCollection","text":"ScalarInterpolationCollection\n\nA collection of compatible scalar-valued interpolations over some (possilby different) cells.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.VectorInterpolationCollection","page":"Utility","title":"Thunderbolt.VectorInterpolationCollection","text":"VectorInterpolationCollection\n\nA collection of compatible vector-valued interpolations over some (possilby different) cells.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.VectorizedInterpolationCollection","page":"Utility","title":"Thunderbolt.VectorizedInterpolationCollection","text":"VectorizedInterpolationCollection{order} <: InterpolationCollection\n\nA collection of fixed-order vectorized Lagrange interpolations across different cell types.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.LagrangeCollection","page":"Utility","title":"Thunderbolt.LagrangeCollection","text":"LagrangeCollection{order} <: InterpolationCollection\n\nA collection of fixed-order Lagrange interpolations across different cell types.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.QuadratureRuleCollection","page":"Utility","title":"Thunderbolt.QuadratureRuleCollection","text":"QuadratureRuleCollection(order::Int)\n\nA collection of quadrature rules across different cell types.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.CellValueCollection","page":"Utility","title":"Thunderbolt.CellValueCollection","text":"CellValueCollection(::QuadratureRuleCollection, ::InterpolationCollection)\n\nHelper to construct and query the correct cell values on mixed grids.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.FacetValueCollection","page":"Utility","title":"Thunderbolt.FacetValueCollection","text":"FacetValueCollection(::QuadratureRuleCollection, ::InterpolationCollection)\n\nHelper to construct and query the correct face values on mixed grids.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Iteration","page":"Utility","title":"Iteration","text":"","category":"section"},{"location":"api-reference/utility/","page":"Utility","title":"Utility","text":"QuadraturePoint\nQuadratureIterator","category":"page"},{"location":"api-reference/utility/#Thunderbolt.QuadraturePoint","page":"Utility","title":"Thunderbolt.QuadraturePoint","text":"QuadraturePoint{dim, T}\n\nA simple helper to carry quadrature point information.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.QuadratureIterator","page":"Utility","title":"Thunderbolt.QuadratureIterator","text":"QuadratureIterator(::QuadratureRule)\nQuadratureIterator(::FacetQuadratureRule, local_face_idx::Int)\nQuadratureIterator(::CellValues)\nQuadratureIterator(::FacetValues)\n\nA helper to loop over the quadrature points in some rule or cache with type QuadraturePoint.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#IO","page":"Utility","title":"IO","text":"","category":"section"},{"location":"api-reference/utility/","page":"Utility","title":"Utility","text":"ParaViewWriter\nJLD2Writer\nstore_timestep!\nstore_timestep_celldata!\nstore_timestep_field!\nstore_coefficient!\nstore_green_lagrange!\nfinalize_timestep!\nfinalize!","category":"page"},{"location":"api-reference/utility/#Thunderbolt.ParaViewWriter","page":"Utility","title":"Thunderbolt.ParaViewWriter","text":"\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.JLD2Writer","page":"Utility","title":"Thunderbolt.JLD2Writer","text":"\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Transfer-Operators","page":"Utility","title":"Transfer Operators","text":"","category":"section"},{"location":"api-reference/utility/","page":"Utility","title":"Utility","text":"Thunderbolt.NodalIntergridInterpolation\nThunderbolt.transfer!","category":"page"},{"location":"api-reference/utility/#Thunderbolt.NodalIntergridInterpolation","page":"Utility","title":"Thunderbolt.NodalIntergridInterpolation","text":"NodalIntergridInterpolation(dh_from::DofHandler{sdim}, dh_to::DofHandler{sdim}, field_name_from::Symbol, field_name_to::Symbol; subdomain_from = 1:length(dh_from.subdofhandlers), subdomains_to = 1:length(dh_to.subdofhandlers))\nNodalIntergridInterpolation(dh_from::DofHandler{sdim}, dh_to::DofHandler{sdim}, field_name::Symbol; subdomain_from = 1:length(dh_from.subdofhandlers), subdomains_to = 1:length(dh_to.subdofhandlers))\nNodalIntergridInterpolation(dh_from::DofHandler{sdim}, dh_to::DofHandler{sdim}; subdomain_from = 1:length(dh_from.subdofhandlers), subdomains_to = 1:length(dh_to.subdofhandlers))\n\nConstruct a transfer operator to move a field field_name from dof handler dh_from to another dof handler dh_to, assuming that all spatial coordinates of the dofs for dh_to are in the interior or boundary of the mesh contained within dh_from. This is necessary to have valid interpolation values, as this operator does not have extrapolation functionality.\n\nnote: Note\nWe assume a continuous coordinate field, if the interpolation of the named field is continuous.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.transfer!","page":"Utility","title":"Thunderbolt.transfer!","text":"This is basically a fancy matrix-vector product to transfer the solution from one problem to another one.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/utility/#Postprocessing","page":"Utility","title":"Postprocessing","text":"","category":"section"},{"location":"api-reference/utility/#ECG","page":"Utility","title":"ECG","text":"","category":"section"},{"location":"api-reference/utility/","page":"Utility","title":"Utility","text":"Thunderbolt.PoissonECGReconstructionCache\nThunderbolt.Plonsey1964ECGGaussCache\nThunderbolt.Geselowitz1989ECGLeadCache\nThunderbolt.evaluate_ecg","category":"page"},{"location":"api-reference/utility/#Thunderbolt.PoissonECGReconstructionCache","page":"Utility","title":"Thunderbolt.PoissonECGReconstructionCache","text":"PoissonECGReconstructionCache(fₑₚ::GenericSplitFunction, Ωₜ::AbstractMesh, κᵢ, κ, electrodes::AbstractVector{<:Vec}; ground, linear_solver, solution_vector_type, system_matrix_type)\n\nSets up a cache for calculating varphi_mathrme by solving the Poisson problem\n\nnabla cdot (boldsymbolkappa_mathrmi + boldsymbolkappa_mathrme) nabla varphi_mathrme=-nabla cdotleft(boldsymbolkappa_mathrmi nabla varphi_mathrmmright)\n\nas for example proposed in [26] and investigated in [27] (as well as other studies). Here κₑ is the extracellular conductivity tensor and κᵢ is the intracellular conductivity tensor. The cache includes the assembled stiffness matrix with applied homogeneous Dirichlet boundary condition at the first vertex of the mesh. As the problem is solved for each timestep with only the right hand side changing.\n\nKeyword Arguments\n\nground               = Set([VertexIndex(1, 1)])\nlinear_solver        = LinearSolve.KrylovJL_CG()\nsolution_vector_type = Vector{Float64}\nsystem_matrix_type   = ThreadedSparseMatrixCSR{Float64,Int64}\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.Plonsey1964ECGGaussCache","page":"Utility","title":"Thunderbolt.Plonsey1964ECGGaussCache","text":"Plonsey1964ECGGaussCache(op::AbstractBilinearOperator, φₘ::AbstractVector)\n\nHere φₘ is the solution vector containing the transmembranepotential, op is the associated diffusion opeartor and κₜ is the torso's conductivity.\n\nReturns a cache to compute the lead field with the form proposed in [28] with the Gauss theorem applied to it, as for example described in [27]. Calling evaluate_ecg with this method simply evaluates the following integral efficiently:\n\nvarphi_e(x)=frac14 pi kappa_t int_Omega frac kappa_ φₘ cdot (tildex-x)(tildex-x)^3mathrmdtildex\n\nThe important simplifications taken are:\n\nSurrounding volume is an infinite, homogeneous sphere with isotropic conductivity\nThe extracellular space and surrounding volume share the same isotropic, homogeneous conductivity tensor\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.Geselowitz1989ECGLeadCache","page":"Utility","title":"Thunderbolt.Geselowitz1989ECGLeadCache","text":"Geselowitz1989ECGLeadCache(problem, torso_grid, κ, κᵢ, electrode_sets, [ground, linear_solver, solution_vector_type, system_matrix_type])\n\nHere the lead field, Z, is computed using the discretization of problem. The lead field is computed as the solution of\n\nnabla cdot(mathbfkappa nabla Z)=leftbeginarraycl\n-1  text  at the positive electrode  \n1  text  at the negative electrode  \n0  text  else where \nendarrayright\n\nWhere kappa is the bulk conductivity tensor.\n\nReturns a cache contain the lead fields that are used to compute the lead potentials as proposed in [29]. Calling reinit! with this method simply evaluates the following integral efficiently:\n\nV(t)=int nabla Z(boldsymbolx) cdot boldsymbolkappa_mathrmi nabla varphi_mathrmm mathrmdboldsymbolx\n\n\n\n\n\n","category":"type"},{"location":"api-reference/utility/#Thunderbolt.evaluate_ecg","page":"Utility","title":"Thunderbolt.evaluate_ecg","text":"evaluate_ecg(method::Plonsey1964ECGGaussCache, x::Vec, κₜ::Real)\n\nCompute the pseudo ECG at a given point x by evaluating:\n\nvarphi_e(x)=frac14 pi kappa_t int_Omega frac kappa_ φₘ cdot (tildex-x)(tildex-x)^3mathrmdtildex\n\nFor more information please read the docstring for Plonsey1964ECGGaussCache\n\n\n\n\n\n","category":"function"},{"location":"tutorials/cm06_heartvalves/","page":"CM06: Heart Valves (TODO)","title":"CM06: Heart Valves (TODO)","text":"EditURL = \"../literate-tutorials/cm06_heartvalves.jl\"","category":"page"},{"location":"tutorials/cm06_heartvalves/#mechanics-tutorial_heartvalves","page":"CM06: Heart Valves (TODO)","title":"Mechanics Tutorial 6: Coupling Heart Valve Models","text":"","category":"section"},{"location":"tutorials/cm06_heartvalves/","page":"CM06: Heart Valves (TODO)","title":"CM06: Heart Valves (TODO)","text":"todo: Todo\nshow heart valve dynamics closely","category":"page"},{"location":"tutorials/cm06_heartvalves/","page":"CM06: Heart Valves (TODO)","title":"CM06: Heart Valves (TODO)","text":"This tutorial shows how to include heart valve models in your simulations.","category":"page"},{"location":"tutorials/cm06_heartvalves/","page":"CM06: Heart Valves (TODO)","title":"CM06: Heart Valves (TODO)","text":"todo: Todo\nProvide context.","category":"page"},{"location":"tutorials/cm06_heartvalves/#Commented-Program","page":"CM06: Heart Valves (TODO)","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/cm06_heartvalves/","page":"CM06: Heart Valves (TODO)","title":"CM06: Heart Valves (TODO)","text":"todo: Todo\nFinalize subdomain management and use this as second simple showcase. We need to figure out where to get the geometry with the strings.","category":"page"},{"location":"tutorials/cm06_heartvalves/#References","page":"CM06: Heart Valves (TODO)","title":"References","text":"","category":"section"},{"location":"tutorials/cm06_heartvalves/","page":"CM06: Heart Valves (TODO)","title":"CM06: Heart Valves (TODO)","text":"","category":"page"},{"location":"tutorials/cm06_heartvalves/#mechanics-tutorial_heartvalves-plain-program","page":"CM06: Heart Valves (TODO)","title":"Plain program","text":"","category":"section"},{"location":"tutorials/cm06_heartvalves/","page":"CM06: Heart Valves (TODO)","title":"CM06: Heart Valves (TODO)","text":"Here follows a version of the program without any comments. The file is also available here: cm06_heartvalves.jl.","category":"page"},{"location":"tutorials/cm06_heartvalves/","page":"CM06: Heart Valves (TODO)","title":"CM06: Heart Valves (TODO)","text":"","category":"page"},{"location":"tutorials/cm06_heartvalves/","page":"CM06: Heart Valves (TODO)","title":"CM06: Heart Valves (TODO)","text":"","category":"page"},{"location":"tutorials/cm06_heartvalves/","page":"CM06: Heart Valves (TODO)","title":"CM06: Heart Valves (TODO)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api-reference/problems/","page":"Problems","title":"Problems","text":"DocTestSetup = :(using Thunderbolt)","category":"page"},{"location":"api-reference/problems/#Problems","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"api-reference/problems/","page":"Problems","title":"Problems","text":"Thunderbolt.NullProblem\nThunderbolt.CoupledProblem\nThunderbolt.PartitionedProblem\nThunderbolt.ODEProblem\nThunderbolt.AbstractPointwiseProblem\nThunderbolt.PointwiseODEProblem\nThunderbolt.QuasiStaticNonlinearProblem\nThunderbolt.QuasiStaticODEProblem\nThunderbolt.QuasiStaticDAEProblem","category":"page"},{"location":"api-reference/problems/","page":"Problems","title":"Problems","text":"OS.OperatorSplittingProblem","category":"page"},{"location":"api-reference/problems/#Thunderbolt.OS.OperatorSplittingProblem","page":"Problems","title":"Thunderbolt.OS.OperatorSplittingProblem","text":"OperatorSplittingProblem(f::AbstractOperatorSplitFunction, u0, tspan, p::Tuple)\n\n\n\n\n\n","category":"type"},{"location":"tutorials/cm02_prestress/","page":"CM02: Prestressing (WIP)","title":"CM02: Prestressing (WIP)","text":"EditURL = \"../literate-tutorials/cm02_prestress.jl\"","category":"page"},{"location":"tutorials/cm02_prestress/#mechanics-tutorial_prestress","page":"CM02: Prestressing (WIP)","title":"Mechanics Tutorial 2: Prestressing the Heart","text":"","category":"section"},{"location":"tutorials/cm02_prestress/","page":"CM02: Prestressing (WIP)","title":"CM02: Prestressing (WIP)","text":"todo: Todo\ndecide which image to show here","category":"page"},{"location":"tutorials/cm02_prestress/","page":"CM02: Prestressing (WIP)","title":"CM02: Prestressing (WIP)","text":"This tutorial shows how to couple include prestress in your simulations and how to recover the correct initial condition.","category":"page"},{"location":"tutorials/cm02_prestress/","page":"CM02: Prestressing (WIP)","title":"CM02: Prestressing (WIP)","text":"todo: Todo\nProvide context.","category":"page"},{"location":"tutorials/cm02_prestress/#Commented-Program","page":"CM02: Prestressing (WIP)","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/cm02_prestress/","page":"CM02: Prestressing (WIP)","title":"CM02: Prestressing (WIP)","text":"info: Info\nWe are preparing a research paper on this topic and will upstream the relevant code into Thunderbolt during review.","category":"page"},{"location":"tutorials/cm02_prestress/","page":"CM02: Prestressing (WIP)","title":"CM02: Prestressing (WIP)","text":"","category":"page"},{"location":"tutorials/cm02_prestress/","page":"CM02: Prestressing (WIP)","title":"CM02: Prestressing (WIP)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using Thunderbolt)","category":"page"},{"location":"#Thunderbolt.jl","page":"Home","title":"Thunderbolt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A high performance cardiac multiphysics system written in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for Thunderbolt. The main goal of this project is to provide a single framework where we can develop new models and high  performance parallel solvers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis package is under heavy development. Expect regular breaking changes for now. If you are interested in joining development, then either comment an issue or reach out via julialang.zulipchat.com, via mail or via  julialang.slack.com. Alternatively open a discussion if you have something  specific in mind.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIf you are interested in using this package, then I am also happy to to get some constructive feedback, especially if things don't work out in the current design. This can be done via julialang.slack.com, julialang.zulipchat.com or via mail.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIf you use this package in an academic context, then I would be happy if you could cite it. Please also cite additionally the corresponding sources for models, numerical methods and utilities used in your code via this package.","category":"page"},{"location":"#How-the-documentation-is-organized","page":"Home","title":"How the documentation is organized","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This high level view of the documentation structure will help you find what you are looking for. The document is organized as follows[1]:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorials are thoroughly documented examples which guides you through the process of building and solving cardiac models in Thunderbolt.\nTopic guides contains more in-depth explanations and discussions about multiphysics modeling concepts and their numerical treatment, and specifically how  these are realized in Thunderbolt.\nAPI Reference contains the technical API reference of functions and methods (e.g. the documentation strings).\nHow-to guides will guide you through the steps involved in addressing common tasks and use-cases. These usually build on top of the tutorials and thus assume basic knowledge of how Thunderbolt works.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: The organization of the document follows the Diátaxis Framework.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition there is the Developer documentation, for documentation of Ferrite internal code.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are new to the Thunderbolt project, it is suggested to start with the tutorials section before tackling more complex problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"todo: Todo\nWe should provide a template for computational studies, possibly via DrWatson.jl (DrWatsonSim.jl?), to guide users towards best practices for computational studies.","category":"page"},{"location":"#Getting-help","page":"Home","title":"Getting help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have questions about Thunderbolt it is suggested to use the #Thunderbolt.jl stream on Zulip. Zulip is preferred over Slack, because the discussions are available over longer time periods.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use Thunderbolt you first need to install Julia, see https://julialang.org/ for details. Installing Thunderbolt can then be done from the Pkg REPL; press ] at the julia> promp to enter pkg> mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/JuliaHealth/Thunderbolt.jl#main","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install Thunderbolt and all necessary dependencies. Press backspace to get back to the julia> prompt. (See the documentation for Pkg, Julia's package manager, for more help regarding package installation and project management.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, to load Thunderbolt, use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Thunderbolt","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are now all set to start using Thunderbolt!","category":"page"},{"location":"#Contributing-to-Thunderbolt","page":"Home","title":"Contributing to Thunderbolt","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Thunderbolt is under very active development. If you find a bug, then please open an issue on GitHub with a reproducer. If you are interested in joining development, then either comment an issue or reach out via Zulip, via mail or via  Slack. Alternatively open a discussion if you have something  specific in mind - please just check for open discussion before opening a new one.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A detailed contributor guide is coming soon...","category":"page"},{"location":"api-reference/discretization/","page":"Discretization","title":"Discretization","text":"DocTestSetup = :(using Thunderbolt)","category":"page"},{"location":"api-reference/discretization/#Discretization","page":"Discretization","title":"Discretization","text":"","category":"section"},{"location":"api-reference/discretization/#Interface","page":"Discretization","title":"Interface","text":"","category":"section"},{"location":"api-reference/discretization/","page":"Discretization","title":"Discretization","text":"FiniteElementDiscretization\nThunderbolt.semidiscretize","category":"page"},{"location":"api-reference/discretization/#Thunderbolt.FiniteElementDiscretization","page":"Discretization","title":"Thunderbolt.FiniteElementDiscretization","text":"Descriptor for a finite element discretization of a part of a PDE over some subdomain.\n\nnote: Note\nThe current implementation is restricted to Bubnov-Galerkin methods. Petrov-Galerkin support will come in the future.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/discretization/#Thunderbolt.semidiscretize","page":"Discretization","title":"Thunderbolt.semidiscretize","text":"semidiscretize(model, discretization, mesh)\n\nTransform a space-time model into a pure time-dependent problem.\n\n\n\n\n\n","category":"function"}]
}
